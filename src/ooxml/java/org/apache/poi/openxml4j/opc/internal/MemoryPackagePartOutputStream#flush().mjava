	/**
	 * Flush this output stream. This method is called by the close() method.
	 * Warning : don't call this method for output consistency.
	 * @see #close()
	 */
	@Override
	public void flush() throws IOException {
		buff.flush();
		if (part.data != null) {
			byte[] newArray = new byte[part.data.length + buff.size()];
			// copy the previous contents of part.data in newArray
			System.arraycopy(part.data, 0, newArray, 0, part.data.length);

			// append the newly added data
			byte[] buffArr = buff.toByteArray();
			System.arraycopy(buffArr, 0, newArray, part.data.length,
					buffArr.length);

			// save the result as new data
			part.data = newArray;
		} else {
			// was empty, just fill it
			part.data = buff.toByteArray();
		}
		
		/* 
		 * Clear this streams buffer, in case flush() is called a second time
		 * Fix bug 1921637 - provided by Rainer Schwarze
		 */
		buff.reset();
	}

