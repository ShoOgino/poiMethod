   public void endElement(String uri, String localName, String name)
           throws SAXException {
       String thisStr = null;

       // v => contents of a cell
       if (isTextTag(name)) {
           vIsOpen = false;
           
           // Process the value contents as required, now we have it all
           switch (nextDataType) {
               case BOOLEAN:
                   char first = value.charAt(0);
                   thisStr = first == '0' ? "FALSE" : "TRUE";
                   break;

               case ERROR:
                   thisStr = "ERROR:" + value.toString();
                   break;

               case FORMULA:
                   if(formulasNotResults) {
                      thisStr = formula.toString();
                   } else {
                      String fv = value.toString();
                      
                      if (this.formatString != null) {
                         try {
                            // Try to use the value as a formattable number
                            double d = Double.parseDouble(fv);
                            thisStr = formatter.formatRawCellContents(d, this.formatIndex, this.formatString);
                         } catch(NumberFormatException e) {
                            // Formula is a String result not a Numeric one
                            thisStr = fv;
                         }
                      } else {
                         // No formating applied, just do raw value in all cases
                         thisStr = fv;
                      }
                   }
                   break;

               case INLINE_STRING:
                   // TODO: Can these ever have formatting on them?
                   XSSFRichTextString rtsi = new XSSFRichTextString(value.toString());
                   thisStr = rtsi.toString();
                   break;

               case SST_STRING:
                   String sstIndex = value.toString();
                   try {
                       int idx = Integer.parseInt(sstIndex);
                       XSSFRichTextString rtss = new XSSFRichTextString(sharedStringsTable.getEntryAt(idx));
                       thisStr = rtss.toString();
                   }
                   catch (NumberFormatException ex) {
                       System.err.println("Failed to parse SST index '" + sstIndex + "': " + ex.toString());
                   }
                   break;

               case NUMBER:
                   String n = value.toString();
                   if (this.formatString != null)
                       thisStr = formatter.formatRawCellContents(Double.parseDouble(n), this.formatIndex, this.formatString);
                   else
                       thisStr = n;
                   break;

               default:
                   thisStr = "(TODO: Unexpected type: " + nextDataType + ")";
                   break;
           }
           
           // Output
           output.cell(cellRef, thisStr);
       } else if ("f".equals(name)) {
          fIsOpen = false;
       } else if ("is".equals(name)) {
          isIsOpen = false;
       } else if ("row".equals(name)) {
          output.endRow();
       }
       else if("oddHeader".equals(name) || "evenHeader".equals(name) ||
             "firstHeader".equals(name)) {
          hfIsOpen = false;
          output.headerFooter(headerFooter.toString(), true, name);
       }
       else if("oddFooter".equals(name) || "evenFooter".equals(name) ||
             "firstFooter".equals(name)) {
          hfIsOpen = false;
          output.headerFooter(headerFooter.toString(), false, name);
       }
   }

