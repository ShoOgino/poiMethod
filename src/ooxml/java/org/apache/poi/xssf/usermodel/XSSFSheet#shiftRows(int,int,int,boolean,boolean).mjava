    /**
     * Shifts rows between startRow and endRow n number of rows.
     * If you use a negative number, it will shift rows up.
     * Code ensures that rows don't wrap around
     *
     * <p>
     * Additionally shifts merged regions that are completely defined in these
     * rows (ie. merged 2 cells on a row to be shifted).
     * <p>
     * @param startRow the row to start shifting
     * @param endRow the row to end shifting
     * @param n the number of rows to shift
     * @param copyRowHeight whether to copy the row height during the shift
     * @param resetOriginalRowHeight whether to set the original row's height to the default
     */
    public void shiftRows(int startRow, int endRow, int n, boolean copyRowHeight, boolean resetOriginalRowHeight) {
        for (Iterator<Row> it = rowIterator() ; it.hasNext() ; ) {
            XSSFRow row = (XSSFRow)it.next();
            int rownum = row.getRowNum();

            if (!copyRowHeight) {
                row.setHeight((short)-1);
            }

            if (resetOriginalRowHeight && getDefaultRowHeight() >= 0) {
                row.setHeight(getDefaultRowHeight());
            }
            if (removeRow(startRow, endRow, n, row.getRowNum())) {
                it.remove();
            }
            else if (row.getRowNum() >= startRow && row.getRowNum() <= endRow) {
                row.shift(n);
            }

            if(sheetComments != null){
                //TODO shift Note's anchor in the associated /xl/drawing/vmlDrawings#.vml
                CTCommentList lst = sheetComments.getCTComments().getCommentList();
                for (CTComment comment : lst.getCommentArray()) {
                    CellReference ref = new CellReference(comment.getRef());
                    if(ref.getRow() == rownum){
                        ref = new CellReference(rownum + n, ref.getCol());
                        comment.setRef(ref.formatAsString());
                    }
                }
            }
        }
        //rebuild the rows map
        int sheetIndex = getWorkbook().getSheetIndex(this);
        FormulaShifter shifter = FormulaShifter.createForRowShift(sheetIndex, startRow, endRow, n);
        TreeMap<Integer, Row> map = new TreeMap<Integer, Row>();
        for(Row r : this) {
            XSSFRow row = (XSSFRow)r;
            row.updateFormulasAfterCellShift(shifter);
            map.put(r.getRowNum(), r);
        }
        rows = map;

        //update formulas on other sheets
        for(XSSFSheet sheet : getWorkbook()) {
            if (sheet == this) continue;
            for(Row r : sheet) {
                XSSFRow row = (XSSFRow)r;
                row.updateFormulasAfterCellShift(shifter);
            }
        }

    }

