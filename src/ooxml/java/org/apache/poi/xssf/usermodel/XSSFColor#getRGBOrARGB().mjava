   private byte[] getRGBOrARGB() {
        byte[] rgb = null;

        if (ctColor.isSetIndexed() && ctColor.getIndexed() > 0) {
            HSSFColor indexed = HSSFColor.getIndexHash().get((int) ctColor.getIndexed());
            if (indexed != null) {
               rgb = new byte[3];
               rgb[0] = (byte) indexed.getTriplet()[0];
               rgb[1] = (byte) indexed.getTriplet()[1];
               rgb[2] = (byte) indexed.getTriplet()[2];
               return rgb;
            }
         }
        
         if (!ctColor.isSetRgb()) {
            // No colour is available, sorry
            return null;
         }

         // Grab the colour
         rgb = ctColor.getRgb();

         if(rgb.length == 4) {
            // Good to go, return it as-is
            return rgb;
         }
         
         // For RGB colours, but not ARGB (we think...)
         // Excel gets black and white the wrong way around, so switch them 
         if (rgb[0] == 0 && rgb[1] == 0 && rgb[2] == 0) {
            rgb = new byte[] {-1, -1, -1};
         }
         else if (rgb[0] == -1 && rgb[1] == -1 && rgb[2] == -1) {
            rgb = new byte[] {0, 0, 0};
         }
         return rgb;
    }

