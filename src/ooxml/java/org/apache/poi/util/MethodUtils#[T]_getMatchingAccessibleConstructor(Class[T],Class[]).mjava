    public static <T> Constructor<T> getMatchingAccessibleConstructor(
                                                Class<T> clazz,
                                                Class[] parameterTypes) {
        // trace logging
        Log log = LogFactory.getLog(MethodUtils.class);
        MethodDescriptor md = new MethodDescriptor(clazz, "dummy", parameterTypes, false);
        
        // see if we can find the method directly
        // most of the time this works and it's much faster
        try {
            Constructor<T> constructor = clazz.getConstructor(parameterTypes);
            if (log.isTraceEnabled()) {
                log.trace("Found straight match: " + constructor);
                log.trace("isPublic:" + Modifier.isPublic(constructor.getModifiers()));
            }
            
            setMethodAccessible(constructor); // Default access superclass workaround

            return constructor;
            
        } catch (NoSuchMethodException e) { /* SWALLOW */ }
        
        // search through all methods 
        int paramSize = parameterTypes.length;
        Constructor<T> bestMatch = null;
        Constructor<?>[] constructors = clazz.getConstructors();
        float bestMatchCost = Float.MAX_VALUE;
        float myCost = Float.MAX_VALUE;
        for (int i = 0, size = constructors.length; i < size ; i++) {
            // compare parameters
            Class[] methodsParams = constructors[i].getParameterTypes();
            int methodParamSize = methodsParams.length;
            if (methodParamSize == paramSize) {          
                boolean match = true;
                for (int n = 0 ; n < methodParamSize; n++) {
                    if (log.isTraceEnabled()) {
                        log.trace("Param=" + parameterTypes[n].getName());
                        log.trace("Method=" + methodsParams[n].getName());
                    }
                    if (!isAssignmentCompatible(methodsParams[n], parameterTypes[n])) {
                        if (log.isTraceEnabled()) {
                            log.trace(methodsParams[n] + " is not assignable from " 
                                        + parameterTypes[n]);
                        }    
                        match = false;
                        break;
                    }
                }
                
                if (match) {
                    // get accessible version of method
                    Constructor<T> cons = (Constructor<T>)constructors[i];
                    myCost = getTotalTransformationCost(parameterTypes,cons.getParameterTypes());
                    if ( myCost < bestMatchCost ) {
                       bestMatch = cons;
                       bestMatchCost = myCost;
                    }
                }
            }
        }
        if ( bestMatch == null ){
            // didn't find a match
               log.trace("No match found.");
        }
        
        return bestMatch;                                        
    }

