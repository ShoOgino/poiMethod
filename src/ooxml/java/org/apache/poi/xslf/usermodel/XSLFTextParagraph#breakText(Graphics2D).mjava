    /**
     * break text into lines
     *
     * @param graphics
     * @return array of text fragments,
     * each representing a line of text that fits in the wrapping width
     */
    List<TextFragment> breakText(Graphics2D graphics){
        _lines = new ArrayList<TextFragment>();

        // does this paragraph contain text?
        boolean emptyParagraph = _runs.size() == 0;

        // ensure that the paragraph contains at least one character
        if(_runs.size() == 0) ensureNotEmpty();

        String text = getRenderableText();
        if(text.length() == 0) return _lines;

        AttributedString at = getAttributedString(graphics);
        AttributedCharacterIterator it = at.getIterator();
        LineBreakMeasurer measurer = new LineBreakMeasurer(it, graphics.getFontRenderContext())  ;
        for (;;) {
            int startIndex = measurer.getPosition();

            double wrappingWidth = getWrappingWidth(_lines.size() == 0, graphics) + 1; // add a pixel to compensate rounding errors
            // shape width can be smaller that the sum of insets (this was proved by a test file)
            if(wrappingWidth < 0) wrappingWidth = 1;

            int nextBreak = text.indexOf('\n', startIndex + 1);
            if(nextBreak == -1) nextBreak = it.getEndIndex();

            TextLayout layout = measurer.nextLayout((float)wrappingWidth, nextBreak, true);
            if (layout == null) {
                 // layout can be null if the entire word at the current position
                 // does not fit within the wrapping width. Try with requireNextWord=false.
                 layout = measurer.nextLayout((float)wrappingWidth, nextBreak, false);
            }

            if(layout == null) {
                // exit if can't break any more
                break;
            }

            int endIndex = measurer.getPosition();
            // skip over new line breaks (we paint 'clear' text runs not starting or ending with \n)
            if(endIndex < it.getEndIndex() && text.charAt(endIndex) == '\n'){
                measurer.setPosition(endIndex + 1);
            }

            TextAlign hAlign = getTextAlign();
            if(hAlign == TextAlign.JUSTIFY || hAlign == TextAlign.JUSTIFY_LOW) {
                layout = layout.getJustifiedLayout((float)wrappingWidth);
            }

            AttributedString str = new AttributedString(it, startIndex, endIndex);
            TextFragment line = new TextFragment(
                    layout, // we will not paint empty paragraphs
                    emptyParagraph ? null : str);
            _lines.add(line);

            _maxLineHeight = Math.max(_maxLineHeight, line.getHeight());

            if(endIndex == it.getEndIndex()) break;

        }

        if(isBullet() && !emptyParagraph) {
            String buCharacter = getBulletCharacter();
            String buFont = getBulletFont();
            if(buFont == null) buFont = getTextRuns().get(0).getFontFamily();
            if(buCharacter != null && buFont != null && _lines.size() > 0) {
                AttributedString str = new AttributedString(buCharacter);

                TextFragment firstLine = _lines.get(0);
                AttributedCharacterIterator bit = firstLine._str.getIterator();

                Color buColor = getBulletFontColor();
                str.addAttribute(TextAttribute.FOREGROUND, buColor == null ?
                        bit.getAttribute(TextAttribute.FOREGROUND) : buColor);
                str.addAttribute(TextAttribute.FAMILY, buFont);

                float fontSize = (Float)bit.getAttribute(TextAttribute.SIZE);
                float buSz = (float)getBulletFontSize();
                if(buSz > 0) fontSize *= buSz* 0.01;
                else fontSize = -buSz;

                str.addAttribute(TextAttribute.SIZE, fontSize);

                TextLayout layout = new TextLayout(str.getIterator(), graphics.getFontRenderContext());
                _bullet = new TextFragment(layout, str);
            }
        }
        return _lines;
    }

