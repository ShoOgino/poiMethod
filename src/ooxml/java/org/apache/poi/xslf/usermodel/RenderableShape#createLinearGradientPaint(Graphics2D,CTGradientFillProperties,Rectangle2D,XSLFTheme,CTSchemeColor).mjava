    private Paint createLinearGradientPaint(
            Graphics2D graphics,
            CTGradientFillProperties gradFill, Rectangle2D anchor,
            XSLFTheme theme, CTSchemeColor phClr) {
        double angle = gradFill.getLin().getAng() / 60000;
        @SuppressWarnings("deprecation")
        CTGradientStop[] gs = gradFill.getGsLst().getGsArray();

        Arrays.sort(gs, new Comparator<CTGradientStop>() {
            public int compare(CTGradientStop o1, CTGradientStop o2) {
                Integer pos1 = o1.getPos();
                Integer pos2 = o2.getPos();
                return pos1.compareTo(pos2);
            }
        });

        Color[] colors = new Color[gs.length];
        float[] fractions = new float[gs.length];

        AffineTransform at = AffineTransform.getRotateInstance(
                Math.toRadians(angle),
                anchor.getX() + anchor.getWidth() / 2,
                anchor.getY() + anchor.getHeight() / 2);

        double diagonal = Math.sqrt(anchor.getHeight() * anchor.getHeight() + anchor.getWidth() * anchor.getWidth());
        Point2D p1 = new Point2D.Double(anchor.getX() + anchor.getWidth() / 2 - diagonal / 2,
                anchor.getY() + anchor.getHeight() / 2);
        p1 = at.transform(p1, null);

        Point2D p2 = new Point2D.Double(anchor.getX() + anchor.getWidth(), anchor.getY() + anchor.getHeight() / 2);
        p2 = at.transform(p2, null);

        snapToAnchor(p1, anchor);
        snapToAnchor(p2, anchor);

        for (int i = 0; i < gs.length; i++) {
            CTGradientStop stop = gs[i];
            colors[i] = new XSLFColor(stop, theme, phClr).getColor();
            fractions[i] = stop.getPos() / 100000.f;
        }

        AffineTransform grAt  = new AffineTransform();
        if(gradFill.isSetRotWithShape() || !gradFill.getRotWithShape()) {
            double rotation = _shape.getRotation();
            if (rotation != 0.) {
                double centerX = anchor.getX() + anchor.getWidth() / 2;
                double centerY = anchor.getY() + anchor.getHeight() / 2;

                grAt.translate(centerX, centerY);
                grAt.rotate(Math.toRadians(-rotation));
                grAt.translate(-centerX, -centerY);
            }
        }

        // Trick to return GradientPaint on JDK 1.5 and LinearGradientPaint on JDK 1.6+
        Paint paint;
        try {
            Class clz = Class.forName("java.awt.LinearGradientPaint");
            Class clzCycleMethod = Class.forName("java.awt.MultipleGradientPaint$CycleMethod");
            Class clzColorSpaceType = Class.forName("java.awt.MultipleGradientPaint$ColorSpaceType");
            Constructor c =
                    clz.getConstructor(Point2D.class, Point2D.class, float[].class, Color[].class,
                            clzCycleMethod, clzColorSpaceType, AffineTransform.class);
            paint = (Paint) c.newInstance(p1, p2, fractions, colors,
                    Enum.valueOf(clzCycleMethod, "NO_CYCLE"),
                    Enum.valueOf(clzColorSpaceType, "SRGB"), grAt);
        } catch (ClassNotFoundException e) {
            paint = new GradientPaint(p1, colors[0], p2, colors[colors.length - 1]);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return paint;
    }

