    private static Paint createRadialGradientPaint(
            CTGradientFillProperties gradFill, Rectangle2D anchor,
            XSLFTheme theme, CTSchemeColor phClr) {
        @SuppressWarnings("deprecation")
        CTGradientStop[] gs = gradFill.getGsLst().getGsArray();

        Point2D pCenter = new Point2D.Double(anchor.getX() + anchor.getWidth()/2,
                anchor.getY() + anchor.getHeight()/2);

        float radius = (float)Math.max(anchor.getWidth(), anchor.getHeight());

        Arrays.sort(gs, new Comparator<CTGradientStop>() {
            public int compare(CTGradientStop o1, CTGradientStop o2) {
                Integer pos1 = o1.getPos();
                Integer pos2 = o2.getPos();
                return pos1.compareTo(pos2);
            }
        });

        Color[] colors = new Color[gs.length];
        float[] fractions = new float[gs.length];


        for (int i = 0; i < gs.length; i++) {
            CTGradientStop stop = gs[i];
            colors[i] = new XSLFColor(stop, theme, phClr).getColor();
            fractions[i] = stop.getPos() / 100000.f;
        }

        // Trick to return GradientPaint on JDK 1.5 and RadialGradientPaint on JDK 1.6+
        Paint paint;
        try {
            Class clz = Class.forName("java.awt.RadialGradientPaint");
            Constructor c =
                    clz.getConstructor(Point2D.class, float.class,
                            float[].class, Color[].class);
            paint = (Paint) c.newInstance(pCenter, radius, fractions, colors);
        } catch (ClassNotFoundException e) {
            // the result on JDK 1.5 is incorrect, but it is better than nothing
            paint = new GradientPaint(
                    new Point2D.Double(anchor.getX(), anchor.getY()),
                    colors[0], pCenter, colors[colors.length - 1]);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return paint;
    }

