    static X509Certificate generateCertificate(PublicKey subjectPublicKey,
            String subjectDn, Date notBefore, Date notAfter,
            X509Certificate issuerCertificate, PrivateKey issuerPrivateKey,
            boolean caFlag, int pathLength, String crlUri, String ocspUri,
            KeyUsageIf keyUsage)
    throws IOException, InvalidKeyException, IllegalStateException, NoSuchAlgorithmException
        , SignatureException, CertificateException, InvocationTargetException, IllegalAccessException
        , InstantiationException, NoSuchMethodException, ClassNotFoundException, NoSuchFieldException
    {
        String signatureAlgorithm = "SHA1withRSA";
        X509V3CertificateGeneratorIf certificateGenerator = HorribleProxy.newProxy(X509V3CertificateGeneratorIf.class);
        certificateGenerator.reset();
        certificateGenerator.setPublicKey(subjectPublicKey);
        certificateGenerator.setSignatureAlgorithm(signatureAlgorithm);
        certificateGenerator.setNotBefore(notBefore);
        certificateGenerator.setNotAfter(notAfter);
        X509PrincipalIf subjectDN = HorribleProxy.newProxy(X509PrincipalIf.class, subjectDn);
        X509PrincipalIf issuerDN;
        if (null != issuerCertificate) {
            issuerDN = HorribleProxy.newProxy(X509PrincipalIf.class, issuerCertificate
                    .getSubjectX500Principal().toString());
        } else {
            issuerDN = subjectDN;
        }
        certificateGenerator.setIssuerDN(issuerDN);
        certificateGenerator.setSubjectDN(subjectDN);
        certificateGenerator.setSerialNumber(new BigInteger(128,
                new SecureRandom()));

        X509ExtensionsIf X509Extensions = HorribleProxy.newProxy(X509ExtensionsIf.class);
        
        certificateGenerator.addExtension(X509Extensions.SubjectKeyIdentifier(),
                false, createSubjectKeyId(subjectPublicKey));
        PublicKey issuerPublicKey;
        issuerPublicKey = subjectPublicKey;
        certificateGenerator.addExtension(
                X509Extensions.AuthorityKeyIdentifier(), false,
                createAuthorityKeyId(issuerPublicKey));

        if (caFlag) {
            BasicConstraintsIf bc;
            
            if (-1 == pathLength) {
                bc = HorribleProxy.newProxy(BasicConstraintsIf.class, true);
            } else {
                bc = HorribleProxy.newProxy(BasicConstraintsIf.class, pathLength);
            }
            certificateGenerator.addExtension(X509Extensions.BasicConstraints(), false, bc);
        }

        if (null != crlUri) {
            GeneralNameIf gn = HorribleProxy.newProxy(GeneralNameIf.class);
            int uri = gn.uniformResourceIdentifier();
            DERIA5StringIf crlUriDer = HorribleProxy.newProxy(DERIA5StringIf.class, crlUri);
            gn = HorribleProxy.newProxy(GeneralNameIf.class, uri, crlUriDer);

            DERSequenceIf gnDer = HorribleProxy.newProxy(DERSequenceIf.class, gn);
            GeneralNamesIf gns = HorribleProxy.newProxy(GeneralNamesIf.class, gnDer);
            
            DistributionPointNameIf dpn = HorribleProxy.newProxy(DistributionPointNameIf.class, 0, gns);
            DistributionPointIf distp = HorribleProxy.newProxy(DistributionPointIf.class, dpn, null, null);
            DERSequenceIf distpDer = HorribleProxy.newProxy(DERSequenceIf.class, distp);
            certificateGenerator.addExtension(X509Extensions.CRLDistributionPoints(), false, distpDer);
        }

        if (null != ocspUri) {
            GeneralNameIf ocspName = HorribleProxy.newProxy(GeneralNameIf.class);
            int uri = ocspName.uniformResourceIdentifier();
            ocspName = HorribleProxy.newProxy(GeneralNameIf.class, uri, ocspUri);
            
            X509ObjectIdentifiersIf X509ObjectIdentifiers = HorribleProxy.newProxy(X509ObjectIdentifiersIf.class);
            AuthorityInformationAccessIf authorityInformationAccess =
                HorribleProxy.newProxy(AuthorityInformationAccessIf.class
                    , X509ObjectIdentifiers.ocspAccessMethod(), ocspName);
            
            certificateGenerator.addExtension(
                    X509Extensions.AuthorityInfoAccess(), false,
                    authorityInformationAccess);
        }

        if (null != keyUsage) {
            certificateGenerator.addExtension(X509Extensions.KeyUsage(), true, keyUsage);
        }

        X509Certificate certificate;
        certificate = certificateGenerator.generate(issuerPrivateKey);

        /*
         * Next certificate factory trick is needed to make sure that the
         * certificate delivered to the caller is provided by the default
         * security provider instead of BouncyCastle. If we don't do this trick
         * we might run into trouble when trying to use the CertPath validator.
         */
        CertificateFactory certificateFactory = CertificateFactory
                .getInstance("X.509");
        certificate = (X509Certificate) certificateFactory
                .generateCertificate(new ByteArrayInputStream(certificate
                        .getEncoded()));
        return certificate;
    }

