    @Test
    public void testSignEnvelopingDocument() throws Exception {
        String testFile = "hello-world-unsigned.xlsx";
        OPCPackage pkg = OPCPackage.open(copy(testdata.getFile(testFile)), PackageAccess.READ_WRITE);

        initKeyPair("Test", "CN=Test");
        final X509CRL crl = PkiTestUtils.generateCrl(x509, keyPair.getPrivate());
        
        // setup
        SignatureConfig signatureConfig = new SignatureConfig();
        signatureConfig.setOpcPackage(pkg);
        signatureConfig.setKey(keyPair.getPrivate());

        /*
         * We need at least 2 certificates for the XAdES-C complete certificate
         * refs construction.
         */
        List<X509Certificate> certificateChain = new ArrayList<X509Certificate>();
        certificateChain.add(x509);
        certificateChain.add(x509);
        signatureConfig.setSigningCertificateChain(certificateChain);
        
        signatureConfig.addSignatureFacet(new EnvelopedSignatureFacet());
        signatureConfig.addSignatureFacet(new KeyInfoSignatureFacet());
        signatureConfig.addSignatureFacet(new XAdESSignatureFacet());
        signatureConfig.addSignatureFacet(new XAdESXLSignatureFacet());
        
        // check for internet, no error means it works
        boolean mockTsp = (getAccessError("http://timestamp.comodoca.com/rfc3161", true, 10000) == null);
        
        // http://timestamping.edelweb.fr/service/tsp
        // http://tsa.belgium.be/connect
        // http://timestamp.comodoca.com/authenticode
        // http://timestamp.comodoca.com/rfc3161
        // http://services.globaltrustfinder.com/adss/tsa
        signatureConfig.setTspUrl("http://timestamp.comodoca.com/rfc3161");
        signatureConfig.setTspRequestPolicy(null); // comodoca request fails, if default policy is set ...
        signatureConfig.setTspOldProtocol(false);
        
        //set proxy info if any
        String proxy = System.getProperty("http_proxy");
        if (proxy != null && proxy.trim().length() > 0) {
            signatureConfig.setProxyUrl(proxy);
        }

        if (mockTsp) {
            TimeStampService tspService = new TimeStampService(){
                @Override
                public byte[] timeStamp(byte[] data, RevocationData revocationData) throws Exception {
                    revocationData.addCRL(crl);
                    return "time-stamp-token".getBytes();                
                }
                @Override
                public void setSignatureConfig(SignatureConfig config) {
                    // empty on purpose
                }
            };
            signatureConfig.setTspService(tspService);
        } else {
            TimeStampServiceValidator tspValidator = new TimeStampServiceValidator() {
                @Override
                public void validate(List<X509Certificate> certificateChain,
                RevocationData revocationData) throws Exception {
                    for (X509Certificate certificate : certificateChain) {
                        LOG.log(POILogger.DEBUG, "certificate: " + certificate.getSubjectX500Principal());
                        LOG.log(POILogger.DEBUG, "validity: " + certificate.getNotBefore() + " - " + certificate.getNotAfter());
                    }
                }
            };
            signatureConfig.setTspValidator(tspValidator);
            signatureConfig.setTspOldProtocol(signatureConfig.getTspUrl().contains("edelweb"));
        }
        
        final RevocationData revocationData = new RevocationData();
        revocationData.addCRL(crl);
        OCSPResp ocspResp = PkiTestUtils.createOcspResp(x509, false,
                x509, x509, keyPair.getPrivate(), "SHA1withRSA", cal.getTimeInMillis());
        revocationData.addOCSP(ocspResp.getEncoded());

        RevocationDataService revocationDataService = new RevocationDataService(){
            @Override
            public RevocationData getRevocationData(List<X509Certificate> certificateChain) {
                return revocationData;
            }
        };
        signatureConfig.setRevocationDataService(revocationDataService);

        // operate
        SignatureInfo si = new SignatureInfo();
        si.setSignatureConfig(signatureConfig);
        try {
            si.confirmSignature();
        } catch (RuntimeException e) {
            // only allow a ConnectException because of timeout, we see this in Jenkins from time to time...
            assertNotNull("Only allowing ConnectException here, but had: " + e, e.getCause());
            assertTrue("Only allowing ConnectException here, but had: " + e, e.getCause() instanceof ConnectException);
            assertTrue("Only allowing ConnectException here, but had: " + e, e.getCause().getMessage().contains("timed out"));
        }
        
        // verify
        Iterator<SignaturePart> spIter = si.getSignatureParts().iterator();
        assertTrue(spIter.hasNext());
        SignaturePart sp = spIter.next();
        boolean valid = sp.validate();
        assertTrue(valid);
        
        SignatureDocument sigDoc = sp.getSignatureDocument();
        String declareNS = 
            "declare namespace xades='http://uri.etsi.org/01903/v1.3.2#'; "
          + "declare namespace ds='http://www.w3.org/2000/09/xmldsig#'; ";
        
        String digestValXQuery = declareNS +
            "$this/ds:Signature/ds:SignedInfo/ds:Reference";
        for (ReferenceType rt : (ReferenceType[])sigDoc.selectPath(digestValXQuery)) {
            assertNotNull(rt.getDigestValue());
            assertEquals(signatureConfig.getDigestMethodUri(), rt.getDigestMethod().getAlgorithm());
        }

        String certDigestXQuery = declareNS +
            "$this//xades:SigningCertificate/xades:Cert/xades:CertDigest";
        XmlObject xoList[] = sigDoc.selectPath(certDigestXQuery);
        assertEquals(xoList.length, 1);
        DigestAlgAndValueType certDigest = (DigestAlgAndValueType)xoList[0];
        assertNotNull(certDigest.getDigestValue());

        String qualPropXQuery = declareNS +
            "$this/ds:Signature/ds:Object/xades:QualifyingProperties";
        xoList = sigDoc.selectPath(qualPropXQuery);
        assertEquals(xoList.length, 1);
        QualifyingPropertiesType qualProp = (QualifyingPropertiesType)xoList[0];
        boolean qualPropXsdOk = qualProp.validate();
        assertTrue(qualPropXsdOk);

        pkg.close();
    }

