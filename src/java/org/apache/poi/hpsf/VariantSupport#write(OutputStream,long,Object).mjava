    /**
     * <p>Writes a variant value to an output stream.</p>
     *
     * @param out The stream to write the value to.
     * @param type The variant's type.
     * @param value The variant's value.
     * @return The number of entities that have been written. In many cases an
     * "entity" is a byte but this is not always the case.
     */
    public static int write(final OutputStream out, final long type,
                               final Object value)
        throws IOException, WritingNotSupportedException
    {
        switch ((int) type)
        {
            case Variant.VT_BOOL:
            {
                int trueOrFalse;
                int length = 0;
                if (((Boolean) value).booleanValue())
                    trueOrFalse = 1;
                else
                    trueOrFalse = 0;
                length += TypeWriter.writeUIntToStream(out, trueOrFalse);
                return length;
            }
            case Variant.VT_LPSTR:
            {
                TypeWriter.writeUIntToStream
                    (out, ((String) value).length() + 1);
                char[] s = toPaddedCharArray((String) value);
                /* FIXME: The following line forces characters to bytes. This
                 * is generally wrong and should only be done according to a
                 * codepage. Alternatively Unicode could be written (see 
                 * Variant.VT_LPWSTR). */
                byte[] b = new byte[s.length];
                for (int i = 0; i < s.length; i++)
                    b[i] = (byte) s[i];
                out.write(b);
                return b.length;
            }
            case Variant.VT_LPWSTR:
            {
                final int nrOfChars = ((String) value).length() + 1; 
                TypeWriter.writeUIntToStream(out, nrOfChars);
                char[] s = toPaddedCharArray((String) value);
                for (int i = 0; i < s.length; i++)
                {
                    final int high = (int) ((s[i] & 0xff00) >> 8);
                    final int low = (int) (s[i] & 0x00ff);
                    final byte highb = (byte) high;
                    final byte lowb = (byte) low;
                    out.write(lowb);
                    out.write(highb);
                }
                return nrOfChars * 2;
            }
            case Variant.VT_CF:
            {
                final byte[] b = (byte[]) value; 
                out.write(b);
                return b.length;
            }
            case Variant.VT_EMPTY:
            {
                TypeWriter.writeUIntToStream(out, Variant.VT_EMPTY);
                return LittleEndianConsts.INT_SIZE;
            }
            case Variant.VT_I2:
            {
                TypeWriter.writeToStream(out, ((Integer) value).shortValue());
                return LittleEndianConsts.SHORT_SIZE;
            }
            case Variant.VT_I4:
            {
                TypeWriter.writeToStream(out, ((Long) value).intValue());
                return LittleEndianConsts.INT_SIZE;
            }
            case Variant.VT_FILETIME:
            {
                int length = 0;
                long filetime = Util.dateToFileTime((Date) value);
                int high = (int) ((filetime >> 32) & 0xFFFFFFFFL);
                int low = (int) (filetime & 0x00000000FFFFFFFFL);
                length += TypeWriter.writeUIntToStream(out, 0x0000000FFFFFFFFL & low);
                length += TypeWriter.writeUIntToStream(out, 0x0000000FFFFFFFFL & high);
                return length;
            }
            default:
            {
                throw new WritingNotSupportedException(type, value);
             }
        }
    }

