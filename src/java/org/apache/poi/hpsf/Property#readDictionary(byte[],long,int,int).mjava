    /**
     * <p>Reads a dictionary.</p>
     *
     * @param src The byte array containing the bytes making out the
     * dictionary.
     * @param offset At this offset within <var>src</var> the
     * dictionary starts.
     * @param length The dictionary contains at most this many bytes.
     * @param codepage The codepage of the string values.
     * @return The dictonary
     */
    protected Map readDictionary(final byte[] src, final long offset,
                                 final int length, final int codepage)
    {
        /* Check whether "offset" points into the "src" array". */
        if (offset < 0 || offset > src.length)
            throw new HPSFRuntimeException
                ("Illegal offset " + offset + " while HPSF stream contains " +
                 length + " bytes.");
        int o = (int) offset;

        /*
         * Read the number of dictionary entries.
         */
        final long nrEntries = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;

        final Map m = new HashMap((int) nrEntries, (float) 1.0);
        for (int i = 0; i < nrEntries; i++)
        {
            /* The key. */
            final Long id = new Long(LittleEndian.getUInt(src, o));
            o += LittleEndian.INT_SIZE;

            /* The value (a string). The length is the either the
             * number of characters if the character set is Unicode or
             * else the number of bytes. The length includes
             * terminating 0x00 bytes which we have to strip off to
             * create a Java string. */
            long sLength = LittleEndian.getUInt(src, o);
            o += LittleEndian.INT_SIZE;

            /* Read the bytes or characters depending on whether the
             * character set is Unicode or not. */
            StringBuffer b = new StringBuffer((int) sLength);
            for (int j = 0; j < sLength; j++)
                if (codepage == Constants.CP_UNICODE)
                {
                    final int i1 = o + (j * 2);
                    final int i2 = i1 + 1;
                    b.append((char) ((src[i2] << 8) + src[i1]));
                }
                else
                    b.append((char) src[o + j]);

            /* Strip 0x00 characters from the end of the string: */
            while (b.length() > 0 && b.charAt(b.length() - 1) == 0x00)
                b.setLength(b.length() - 1);
            if (codepage == Constants.CP_UNICODE)
            {
                if (sLength % 2 == 1)
                    sLength++;
                o += (sLength + sLength);
            }
            else
                o += sLength;
            m.put(id, b.toString());
        }
        return m;
    }

