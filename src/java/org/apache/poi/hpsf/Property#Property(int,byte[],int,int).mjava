    /**
     * <p>Creates a {@link Property} instance by reading its bytes
     * from the property set stream.</p>
     *
     * @param id The property's ID.
     *
     * @param src The bytes the property set stream consists of.
     *
     * @param offset The property's type/value pair's offset in the
     * section.
     *
     * @param length The property's type/value pair's length in bytes.
     * list.
     */
    public Property(final int id, final byte[] src, final int offset,
                    final int length)
    {
        this.id = id;

        /* ID 0 is a special case since it specifies a dictionary of
         * property IDs and property names. */
        if (id == 0)
        {
            value = readDictionary(src, offset, length);
            return;
        }

        /* FIXME: Support this! */
//        /* ID 1 is another special case: It denotes the code page of
//         * byte strings in this section. */
//        if (id == 1)
//        {
//            value = readCodepage(src, offset);
//            return;
//        }

        int o = offset;
        type = new DWord(src, o).intValue();
        o += DWord.LENGTH;

        /* FIXME: Support reading more types! */
        switch (type)
        {
            case Variant.VT_I4:
            {
                /* Read a word. In Java it is represented as an
                   Integer object. */
                value = new Integer(new DWord(src, o).intValue());
                break;
            }
            case Variant.VT_FILETIME:
            {
                /* Read a FILETIME object. In Java it is represented
                   as a Date. */
                final int low = new DWord(src, o).intValue();
                o += DWord.LENGTH;
                final int high = new DWord(src, o).intValue();
                value = Util.filetimeToDate(high, low);
                break;
            }
            case Variant.VT_LPSTR:
            {
                /* Read a byte string. In Java it is represented as a
                   String. The null bytes at the end of the byte
                   strings must be stripped. */
                final int first = o + DWord.LENGTH;
                int last = first + new DWord(src, o).intValue() - 1;
                o += DWord.LENGTH;
                while (src[last] == 0 && first <= last)
                    last--;
                value = new String(src, first, last - first + 1);
                break;
            }
            case Variant.VT_CF:
            {
                /* The first four bytes in src, from rc[offset] to
                 * src[offset + 3] contain the DWord for VT_CF, so
                 * skip it, we don't need it. */

                /* Truncate the length of the return array by a DWord
                 * length (4 bytes). */
                length = length - DWord.LENGTH;

                final byte[] v = new byte[length];
                for (int i = 0; i < length; i++)
                    v[i] = src[o + i];
                value = v;
                break;
            }
            case Variant.VT_BOOL:
            {
                /* The first four bytes in src, from src[offset] to
                 * src[offset + 3] contain the DWord for VT_BOOL, so
                 * skip it, we don't need it. */
                final int first = o + DWord.LENGTH;
                DWord bool = new DWord(src,o);
                if (bool.intValue() == -1)
                {
                    value = new Boolean(true);
                }
                else if (bool.intValue() == 0)
                {
                    value = new Boolean(false);
                }
                else
                    /* FIXME: Someone might invent a new
                     * HPSFRuntimeException subclass
                     * IllegalPropertySetDataException for this and
                     * similar cases. */
                    throw new HPSFRuntimeException
                        ("Illegal property set data: A boolean must be " +
                         "either -1 (true) or 0 (false).");
                break;
            }
            default:
            {
                final byte[] v = new byte[length];
                for (int i = 0; i < length; i++)
                    v[i] = src[offset + i];
                value = v;
                break;
            }
        }
    }

