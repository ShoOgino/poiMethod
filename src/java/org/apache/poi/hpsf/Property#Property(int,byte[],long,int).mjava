    /**
     *  <p>
     *
     *  Creates a {@link Property} instance by reading its bytes from the
     *  property set stream.</p>
     *
     *@param  id      The property's ID.
     *@param  src     The bytes the property set stream consists of.
     *@param  offset  The property's type/value pair's offset in the section.
     *@param  length  The property's type/value pair's length in bytes. list.
     */
    public Property(final int id, final byte[] src, final long offset,
            int length) {
        this.id = id;

        /*
         *  ID 0 is a special case since it specifies a dictionary of
         *  property IDs and property names.
         */
        if (id == 0) {
            value = readDictionary(src, offset, length);
            return;
        }

        /*
         *  FIXME: Support this!
         */
//        /* ID 1 is another special case: It denotes the code page of
//         * byte strings in this section. */
//        if (id == 1)
//        {
//            value = readCodepage(src, offset);
//            return;
//        }

        int o = (int) offset;
        type = LittleEndian.getUInt(src, o);
        o += LittleEndian.INT_SIZE;

        /*
         *  FIXME: Support reading more types!
         */
        switch ((int)type) {
            case Variant.VT_I4:
            {
                /*
                 *  Read a word. In Java it is represented as an
                 *  Integer object.
                 */
                value = new Long(LittleEndian.getUInt(src, o));
                break;
            }
            case Variant.VT_FILETIME:
            {
                /*
                 *  Read a FILETIME object. In Java it is represented
                 *  as a Date.
                 */
                final long low = LittleEndian.getUInt(src, o);
                o += LittleEndian.INT_SIZE;
                final long high = LittleEndian.getUInt(src, o);
                value = Util.filetimeToDate((int)high, (int)low);
                break;
            }
            case Variant.VT_LPSTR:
            {
                /*
                 *  Read a byte string. In Java it is represented as a
                 *  String. The null bytes at the end of the byte
                 *  strings must be stripped.
                 */
                final int first = o + LittleEndian.INT_SIZE;
                long last = first + LittleEndian.getUInt(src, o) - 1;
                o += LittleEndian.INT_SIZE;
                while (src[(int)last] == 0 && first <= last) {
                    last--;
                }
                value = new String(src, (int)first, (int)(last - first + 1));
                break;
            }
            case Variant.VT_CF:
            {
                /*
                 *  The first four bytes in src, from rc[offset] to
                 *  src[offset + 3] contain the DWord for VT_CF, so
                 *  skip it, we don't need it.
                 */
                /*
                 *  Truncate the length of the return array by a DWord
                 *  length (4 bytes).
                 */
                length = length - LittleEndian.INT_SIZE;

                final byte[] v = new byte[length];
                for (int i = 0; i < length; i++) {
                    v[i] = src[(int)(o + i)];
                }
                value = v;
                break;
            }
            case Variant.VT_BOOL:
            {
                /*
                 *  The first four bytes in src, from src[offset] to
                 *  src[offset + 3] contain the DWord for VT_BOOL, so
                 *  skip it, we don't need it.
                 */
                final int first = o + LittleEndian.INT_SIZE;
                long bool = LittleEndian.getUInt(src, o);
                if (bool == -1) {
                    value = new Boolean(true);
                } else if (bool == 0) {
                    value = new Boolean(false);
                } else {
                    /*
                     *  FIXME: Someone might invent a new
                     *  HPSFRuntimeException subclass
                     *  IllegalPropertySetDataException for this and
                     *  similar cases.
                     */
                    throw new HPSFRuntimeException
                            ("Illegal property set data: A boolean must be " +
                            "either -1 (true) or 0 (false).");
                }
                break;
            }
            default:
            {
                final byte[] v = new byte[length];
                for (int i = 0; i < length; i++) {
                    v[i] = src[(int)(offset + i)];
                }
                value = v;
                break;
            }
        }
    }

