    /**
     * Writes a variant value to an output stream. This method ensures that
     * always a multiple of 4 bytes is written.<p>
     *
     * If the codepage is UTF-16, which is encouraged, strings
     * <strong>must</strong> always be written as {@link Variant#VT_LPWSTR}
     * strings, not as {@link Variant#VT_LPSTR} strings. This method ensure this
     * by converting strings appropriately, if needed.
     *
     * @param out The stream to write the value to.
     * @param type The variant's type.
     * @param value The variant's value.
     * @param codepage The codepage to use to write non-wide strings
     * @return The number of entities that have been written. In many cases an
     * "entity" is a byte but this is not always the case.
     * @exception IOException if an I/O exceptions occurs
     * @exception WritingNotSupportedException if a property is to be written
     * who's variant type HPSF does not yet support
     */
    public static int write(final OutputStream out, final long type,
                            final Object value, final int codepage)
    throws IOException, WritingNotSupportedException {
        int length = 0;
        switch ((int) type) {
            case Variant.VT_BOOL:
                if ( ( (Boolean) value ).booleanValue() ) {
                    out.write( 0xff );
                    out.write( 0xff );
                } else {
                    out.write( 0x00 );
                    out.write( 0x00 );
                }
                length += 2;
                break;

            case Variant.VT_LPSTR:
                CodePageString codePageString = new CodePageString( (String) value, codepage );
                length += codePageString.write( out );
                break;

            case Variant.VT_LPWSTR:
                final int nrOfChars = ( (String) value ).length() + 1;
                length += TypeWriter.writeUIntToStream( out, nrOfChars );
                for ( char s : ( (String) value ).toCharArray() ) {
                    final int high = ( ( s & 0x0000ff00 ) >> 8 );
                    final int low = ( s & 0x000000ff );
                    final byte highb = (byte) high;
                    final byte lowb = (byte) low;
                    out.write( lowb );
                    out.write( highb );
                    length += 2;
                }
                // NullTerminator
                out.write( 0x00 );
                out.write( 0x00 );
                length += 2;
                break;

            case Variant.VT_CF:
                final byte[] cf = (byte[]) value;
                out.write(cf);
                length = cf.length;
                break;

            case Variant.VT_EMPTY:
                length += TypeWriter.writeUIntToStream( out, Variant.VT_EMPTY );
                break;

            case Variant.VT_I2:
                length += TypeWriter.writeToStream( out, ( (Integer) value ).shortValue() );
                break;

            case Variant.VT_I4:
                if (!(value instanceof Integer)) {
                    throw new ClassCastException("Could not cast an object to "
                            + Integer.class + ": "
                            + value.getClass() + ", "
                            + value);
                }
                length += TypeWriter.writeToStream(out, ((Integer) value).intValue());
                break;

            case Variant.VT_I8:
                length += TypeWriter.writeToStream(out, ((Long) value).longValue());
                break;

            case Variant.VT_R8:
                length += TypeWriter.writeToStream(out, ((Double) value).doubleValue());
                break;

            case Variant.VT_FILETIME:
                long filetime = Util.dateToFileTime((Date) value);
                int high = (int) ((filetime >> 32) & 0x00000000FFFFFFFFL);
                int low = (int) (filetime & 0x00000000FFFFFFFFL);
                Filetime filetimeValue = new Filetime( low, high);
                length += filetimeValue.write( out );
                break;

            default:
                /* The variant type is not supported yet. However, if the value
                 * is a byte array we can write it nevertheless. */
                if (value instanceof byte[]) {
                    final byte[] b = (byte[]) value;
                    out.write(b);
                    length = b.length;
                    writeUnsupportedTypeMessage(new WritingNotSupportedException(type, value));
                } else {
                    throw new WritingNotSupportedException(type, value);
                }
                break;
        }

        /* pad values to 4-bytes */
        while ( ( length & 0x3 ) != 0 ) {
            out.write( 0x00 );
            length++;
        }

        return length;
    }

