    /**
     * Writes this section into an output stream.<p>
     *
     * Internally this is done by writing into three byte array output
     * streams: one for the properties, one for the property list and one for
     * the section as such. The two former are appended to the latter when they
     * have received all their data.
     *
     * @param out The stream to write into.
     *
     * @return The number of bytes written, i.e. the section's size.
     * @exception IOException if an I/O error occurs
     * @exception WritingNotSupportedException if HPSF does not yet support
     * writing a property's variant type.
     */
    public int write(final OutputStream out) throws WritingNotSupportedException, IOException {
        /* Check whether we have already generated the bytes making out the
         * section. */
        if (!dirty && sectionBytes != null) {
            out.write(sectionBytes);
            return sectionBytes.length;
        }

        /* Writing the section's dictionary it tricky. If there is a dictionary
         * (property 0) the codepage property (property 1) must be set, too. */
        int codepage = getCodepage();
        if (codepage == -1) {
            String msg =
                "The codepage property is not set although a dictionary is present. "+
                "Defaulting to ISO-8859-1.";
            LOG.log(POILogger.WARN, msg);
            codepage = Property.DEFAULT_CODEPAGE;
        }

        /* The properties are written to this stream. */
        final ByteArrayOutputStream propertyStream = new ByteArrayOutputStream();

        /* The property list is established here. After each property that has
         * been written to "propertyStream", a property list entry is written to
         * "propertyListStream". */
        final ByteArrayOutputStream propertyListStream = new ByteArrayOutputStream();

        /* Maintain the current position in the list. */
        int position = 0;

        /* Increase the position variable by the size of the property list so
         * that it points behind the property list and to the beginning of the
         * properties themselves. */
        position += 2 * LittleEndianConsts.INT_SIZE + getPropertyCount() * 2 * LittleEndianConsts.INT_SIZE;

        /* Write the properties and the property list into their respective
         * streams: */
        for (Property p : properties.values()) {
            final long id = p.getID();

            /* Write the property list entry. */
            LittleEndian.putUInt(id, propertyListStream);
            LittleEndian.putUInt(position, propertyListStream);

            /* If the property ID is not equal 0 we write the property and all
             * is fine. However, if it equals 0 we have to write the section's
             * dictionary which has an implicit type only and an explicit
             * value. */
            if (id != 0) {
                /* Write the property and update the position to the next
                 * property. */
                position += p.write(propertyStream, codepage);
            } else {
                if (codepage == -1) {
                    throw new IllegalPropertySetDataException("Codepage (property 1) is undefined.");
                }
                position += writeDictionary(propertyStream, codepage);
            }
        }

        /* Write the section: */
        int streamLength = LittleEndianConsts.INT_SIZE * 2 + propertyListStream.size() + propertyStream.size();

        /* Write the section's length: */
        LittleEndian.putInt(streamLength, out);

        /* Write the section's number of properties: */
        LittleEndian.putInt(getPropertyCount(), out);

        /* Write the property list: */
        propertyListStream.writeTo(out);

        /* Write the properties: */
        propertyStream.writeTo(out);

        return streamLength;
    }

