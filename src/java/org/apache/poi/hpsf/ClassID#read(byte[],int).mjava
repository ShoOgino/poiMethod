    /**
     *  Description of the Method - REWRITE ME REWRITE ME REWRITE ME
     *  ISNT += offset a bug?  -- doesn't the order of operations evaluate that
     * last?
     *
     *@param  src     Description of the Parameter
     *@param  offset  Description of the Parameter
     *@return         Description of the Return Value
     */
    public byte[] read(byte[] src, int offset) {
        byte[] retval = new byte[24];

        throw new RuntimeException("This fucntion must be rewritten");
/*
        Object[] b = new Object[11]; 
        b[0] = new Long(LittleEndian.getUInt(src, offset));
        b[1] = new Integer(LittleEndian.getInt(src, offset += LittleEndian.INT_SIZE));
        b[2] = new Integer(LittleEndian.getInt(src, offset += LittleEndian.INT_SIZE));
        b[3] = new Byte(LittleEndian.getUnsignedByte(src, offset += LittleEndian.INT_SIZE);  
        b[4] = new Byte(LittleEndian.getUnsignedByte(src, offset += 1));
        b[5] = new Byte(LittleEndian.getUnsignedByte(src, offset += 1));
        b[6] = new Byte(LittleEndian.getUnsignedByte(src, offset += 1));
        b[7] = new Byte(LittleEndian.getUnsignedByte(src, offset += 1));
        b[8] = new Byte(LittleEndian.getUnsignedByte(src, offset += 1));
        b[9] = new Byte(LittleEndian.getUnsignedByte(src, offset += 1));
        b[10] = new Byte(LittleEndian.getUnsignedByte(src, offset += 1));
        int capacity = 24;
//        for (int i = 0; i < b.length; i++) {
//            capacity += b[i].getBytes().length;
//        }
        bytes = new byte[capacity];
        int pos = 0;
        
        for (int i = 0; i < b.length; i++) {
            byte[] s = b[i].getBytes();
            for (int j = 0; j < s.length; j++) {
                bytes[pos++] = s[j];
            }
        }
        return bytes;*/
    }

