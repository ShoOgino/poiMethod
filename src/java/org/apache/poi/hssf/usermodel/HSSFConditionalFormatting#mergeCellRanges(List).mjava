	/**
	 * Do all possible cell merges between cells of the list so that:<br>
	 * 	<li>if a cell range is completely inside of another cell range, it gets removed from the list 
	 * 	<li>if two cells have a shared border, merge them into one bigger cell range
	 * @param cellRangeList
	 * @return updated List of cell ranges
	 */
	private static List mergeCellRanges(List cellRangeList)
	{
		boolean merged = false;
		
		do
		{
			merged = false;
			
			if( cellRangeList.size()>1 )
			{
				for( int i=0; i<cellRangeList.size(); i++)
				{
					CellRange range1 = (CellRange)cellRangeList.get(i);
					for( int j=i+1; j<cellRangeList.size(); j++)
					{
						CellRange range2 = (CellRange)cellRangeList.get(j);
						
						switch(range1.intersect(range2))
						{
							case CellRange.NO_INTERSECTION: 
							{
								if( range1.hasSharedBorder(range2))
								{
									cellRangeList.set(i, range1.createEnclosingCellRange(range2));
									cellRangeList.remove(j--);
									merged = true;
								}
								else
								{
									// No intersection and no shared border: do nothing 
								}
								break;
							}
							case CellRange.OVERLAP:
							{
								// TODO split and re-merge the intersected area
								break;
							}
							case CellRange.INSIDE:
							{
								// Remove range2, since it is completely inside of range1
								cellRangeList.remove(j--);
								merged = true;
								break;
							}
							case CellRange.ENCLOSES:
							{
								// range2 encloses range1, so replace it with the enclosing one
								cellRangeList.set(i, range2);
								cellRangeList.remove(j--);
								merged = true;
								break;
							}
						}
					}
				}
			}
		}
		while( merged );
		
		return cellRangeList;
	}

