	/**
	 * Create an array of records from an input stream
	 *
	 * @param in the InputStream from which the records will be obtained
	 *
	 * @return an array of Records created from the InputStream
	 *
	 * @exception RecordFormatException on error processing the InputStream
	 */
	public static List<Record> createRecords(InputStream in) throws RecordFormatException {

		List<Record> records = new ArrayList<Record>(NUM_RECORDS);

		RecordInputStream recStream = new RecordInputStream(in);
		DrawingRecord lastDrawingRecord = new DrawingRecord( );
		Record lastRecord = null;
		/*
		 * How to recognise end of stream?
		 * In the best case, the underlying input stream (in) ends just after the last EOF record
		 * Usually however, the stream is padded with an arbitrary byte count.  Excel and most apps
		 * reliably use zeros for padding and if this were always the case, this code could just
		 * skip all the (zero sized) records with sid==0.  However, bug 46987 shows a file with
		 * non-zero padding that is read OK by Excel (Excel also fixes the padding).
		 * 
		 * So to properly detect the workbook end of stream, this code has to identify the last
		 * EOF record.  This is not so easy because the worbook bof+eof pair do not bracket the 
		 * whole stream.  The worksheets follow the workbook, but it is not easy to tell how many 
		 * sheet sub-streams should be present.  Hence we are looking for an EOF record that is not 
		 * immediately followed by a BOF record.  One extra complication is that bof+eof sub-
		 * streams can be nested within worksheet streams and it's not clear in these cases what
		 * record might follow any EOF record.  So we also need to keep track of the bof/eof 
		 * nesting level.
		 */
		 
		int bofDepth=0;
		boolean lastRecordWasEOFLevelZero = false;
		while (recStream.hasNextRecord()) {
			recStream.nextRecord();
			if (lastRecordWasEOFLevelZero && recStream.getSid() != BOFRecord.sid) {
				// Normally InputStream (in) contains only zero padding after this point
				break;
			}
			Record record = createSingleRecord(recStream);
			lastRecordWasEOFLevelZero = false;
			if (record instanceof BOFRecord) {
				bofDepth++;
				records.add(record);
				continue;
			}
			if (record instanceof EOFRecord) {
				bofDepth--;
				records.add(record);
				if (bofDepth<1) {
					lastRecordWasEOFLevelZero = true;
				}
				continue;
			}
			
			if (record instanceof DBCellRecord) {
				// Not needed by POI.  Regenerated from scratch by POI when spreadsheet is written
				continue;
			}

			if (record instanceof RKRecord) {
				records.add(convertToNumberRecord((RKRecord) record));
				continue;
			}
			if (record instanceof MulRKRecord) {
				addAll(records, convertRKRecords((MulRKRecord)record));
				continue;
			}

			if (record.getSid() == DrawingGroupRecord.sid
				   && lastRecord instanceof DrawingGroupRecord) {
				DrawingGroupRecord lastDGRecord = (DrawingGroupRecord) lastRecord;
				lastDGRecord.join((AbstractEscherHolderRecord) record);
			} else if (record.getSid() == ContinueRecord.sid) {
				ContinueRecord contRec = (ContinueRecord)record;
				
				if (lastRecord instanceof ObjRecord || lastRecord instanceof TextObjectRecord) {
					// Drawing records have a very strange continue behaviour.
					//There can actually be OBJ records mixed between the continues.
					lastDrawingRecord.processContinueRecord(contRec.getData() );
					//we must remember the position of the continue record.
					//in the serialization procedure the original structure of records must be preserved
					records.add(record);
				} else if (lastRecord instanceof DrawingGroupRecord) {
					((DrawingGroupRecord)lastRecord).processContinueRecord(contRec.getData());
				} else if (lastRecord instanceof UnknownRecord) {
					//Gracefully handle records that we don't know about,
					//that happen to be continued
					records.add(record);
				} else if (lastRecord instanceof EOFRecord) {
					// This is really odd, but excel still sometimes
					//  outputs a file like this all the same
					records.add(record);
				} else {
					throw new RecordFormatException("Unhandled Continue Record");
				}
			} else {
				lastRecord = record;
				if (record instanceof DrawingRecord) {
					lastDrawingRecord = (DrawingRecord) record;
				}
				records.add(record);
			}
		}
		return records;
	}

