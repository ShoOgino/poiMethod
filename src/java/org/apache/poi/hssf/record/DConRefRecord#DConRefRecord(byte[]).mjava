    /**
     * Read constructor.
     *
     * @param data byte array containing a DConRef Record, including the header.
     */
    public DConRefRecord(byte[] data)
    {
        int offset = 0;
        if (!(LittleEndian.getShort(data, offset) == DConRefRecord.sid))
            throw new RecordFormatException("incompatible sid.");
        offset += LittleEndian.SHORT_SIZE;

        //length = LittleEndian.getShort(data, offset);
        offset += LittleEndian.SHORT_SIZE;

        firstRow = LittleEndian.getUShort(data, offset);
        offset += LittleEndian.SHORT_SIZE;
        lastRow = LittleEndian.getUShort(data, offset);
        offset += LittleEndian.SHORT_SIZE;
        firstCol = LittleEndian.getUByte(data, offset);
        offset += LittleEndian.BYTE_SIZE;
        lastCol = LittleEndian.getUByte(data, offset);
        offset += LittleEndian.BYTE_SIZE;
        charCount = LittleEndian.getUShort(data, offset);
        offset += LittleEndian.SHORT_SIZE;
        if (charCount < 2)
            throw new org.apache.poi.hssf.record.RecordFormatException(
                    "Character count must be >= 2");

        charType = LittleEndian.getUByte(data, offset);
        offset += LittleEndian.BYTE_SIZE; //7 bits reserved + 1 bit type

        /*
         * bytelength is the length of the string in bytes, which depends on whether the string is
         * made of single- or double-byte chars. This is given by charType, which equals 0 if
         * single-byte, 1 if double-byte.
         */
        int byteLength = charCount * ((charType & 1) + 1);

        path = LittleEndian.getByteArray(data, offset, byteLength);
        offset += byteLength;

        /*
         * If it's a self reference, the last one or two bytes (depending on char type) are the
         * unused field. Not sure If i need to bother with this...
         */
        if (path[0] == 0x02)
            _unused = LittleEndian.getByteArray(data, offset, (charType + 1));

    }

