	/**
	 * Converts the Records into UserModel
	 *  objects on the bound HSSFPatriarch
	 */
	public void convertRecordsToUserModel() {
		if(patriarch == null) {
			throw new IllegalStateException("Must call setPatriarch() first");
		}

		// The top level container ought to have
		//  the DgRecord and the container of one container
		//  per shape group (patriach overall first)
		EscherContainerRecord topContainer = getEscherContainer();
		if(topContainer == null) {
			return;
		}
		topContainer = topContainer.getChildContainers().get(0);

		List tcc = topContainer.getChildContainers();
		if(tcc.size() == 0) {
			throw new IllegalStateException("No child escher containers at the point that should hold the patriach data, and one container per top level shape!");
		}

		// First up, get the patriach position
		// This is in the first EscherSpgrRecord, in
		//  the first container, with a EscherSRecord too
		EscherContainerRecord patriachContainer =
			(EscherContainerRecord)tcc.get(0);
		EscherSpgrRecord spgr = null;
		for(Iterator<EscherRecord> it = patriachContainer.getChildIterator(); it.hasNext();) {
			EscherRecord r = it.next();
			if(r instanceof EscherSpgrRecord) {
				spgr = (EscherSpgrRecord)r;
				break;
			}
		}
		if(spgr != null) {
			patriarch.setCoordinates(
					spgr.getRectX1(), spgr.getRectY1(),
					spgr.getRectX2(), spgr.getRectY2()
			);
		}

		convertRecordsToUserModelRecursive(tcc, patriarch, null);

		// Now, clear any trace of what records make up
		//  the patriarch
		// Otherwise, everything will go horribly wrong
		//  when we try to write out again....
//		clearEscherRecords();
		drawingManager.getDgg().setFileIdClusters(new EscherDggRecord.FileIdCluster[0]);

		// TODO: Support converting our records
		// back into shapes
		// log.log(POILogger.WARN, "Not processing objects into Patriarch!");
	}

