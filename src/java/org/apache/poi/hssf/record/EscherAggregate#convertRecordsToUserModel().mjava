	/**
	 * Converts the Records into UserModel
	 *  objects on the bound HSSFPatriarch
	 */
	public void convertRecordsToUserModel() {
		if(patriarch == null) {
			throw new IllegalStateException("Must call setPatriarch() first");
		}

		// The top level container ought to have
		//  the DgRecord and the container of one container
		//  per shape group (patriach overall first)
		EscherContainerRecord topContainer = getEscherContainer();
		if(topContainer == null) {
			return;
		}
		topContainer = topContainer.getChildContainers().get(0);

		List tcc = topContainer.getChildContainers();
		if(tcc.size() == 0) {
			throw new IllegalStateException("No child escher containers at the point that should hold the patriach data, and one container per top level shape!");
		}

		// First up, get the patriach position
		// This is in the first EscherSpgrRecord, in
		//  the first container, with a EscherSRecord too
		EscherContainerRecord patriachContainer =
			(EscherContainerRecord)tcc.get(0);
		EscherSpgrRecord spgr = null;
		for(Iterator<EscherRecord> it = patriachContainer.getChildIterator(); it.hasNext();) {
			EscherRecord r = it.next();
			if(r instanceof EscherSpgrRecord) {
				spgr = (EscherSpgrRecord)r;
				break;
			}
		}
		if(spgr != null) {
			patriarch.setCoordinates(
					spgr.getRectX1(), spgr.getRectY1(),
					spgr.getRectX2(), spgr.getRectY2()
			);
		}

		// Now process the containers for each group
		//  and objects
		for(int i=1; i<tcc.size(); i++) {
			EscherContainerRecord shapeContainer =
				(EscherContainerRecord)tcc.get(i);
			//System.err.println("\n\n*****\n\n");
			//System.err.println(shapeContainer);

			// Could be a group, or a base object
			if(shapeContainer.getChildRecords().size() == 1 &&
					shapeContainer.getChildContainers().size() == 1) {
				// Group
				HSSFShapeGroup group =
					new HSSFShapeGroup(null, new HSSFClientAnchor());
				patriarch.getChildren().add(group);

				EscherContainerRecord groupContainer =
					(EscherContainerRecord)shapeContainer.getChild(0);
				convertRecordsToUserModel(groupContainer, group);
			} else if(shapeContainer.hasChildOfType((short)0xF00D)) {
				// TextBox
				HSSFTextbox box =
					new HSSFTextbox(null, new HSSFClientAnchor());
				patriarch.getChildren().add(box);

				convertRecordsToUserModel(shapeContainer, box);
			} else if(shapeContainer.hasChildOfType((short)0xF011)) {
				// Not yet supporting EscherClientDataRecord stuff
			} else {
				// Base level
				convertRecordsToUserModel(shapeContainer, patriarch);
			}
		}

		// Now, clear any trace of what records make up
		//  the patriarch
		// Otherwise, everything will go horribly wrong
		//  when we try to write out again....
//		clearEscherRecords();
		drawingManager.getDgg().setFileIdClusters(new EscherDggRecord.FileIdCluster[0]);

		// TODO: Support converting our records
		//  back into shapes
		log.log(POILogger.WARN, "Not processing objects into Patriarch!");
	}

