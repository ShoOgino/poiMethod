    public int serialize(int offset, byte[] data)
    {
        int pos = offset;

        LittleEndian.putShort(data, pos, sid); pos += 2;
        LittleEndian.putShort(data, pos, (short)(getRecordSize() - 4)); pos += 2;

        LittleEndian.putShort(data, pos, field_1_stream_id_offset); pos += 2;
        LittleEndian.putShortArray(data, pos, field_2_unknown); pos += field_2_unknown.length * 2 + 2;
        LittleEndian.putShort(data, pos, field_3_unicode_len); pos += 2;
        data[pos] = field_4_unicode_flag ? (byte) 0x01 : (byte) 0x00; pos++;

        if ( field_4_unicode_flag )
        {
            StringUtil.putUnicodeLE( field_5_ole_classname, data, pos ); pos += field_5_ole_classname.length() * 2;
        }
        else
        {
            StringUtil.putCompressedUnicode( field_5_ole_classname, data, pos ); pos += field_5_ole_classname.length();
        }

        // Padded with the same number of NUL bytes as were originally skipped.
        // XXX: This is only accurate until we make the classname mutable.
        pos += field_5_ole_classname_padding;
        
        LittleEndian.putInt(data, pos, field_6_stream_id); pos += 4;

        System.arraycopy(remainingBytes, 0, data, pos, remainingBytes.length);

        return getRecordSize();
    }

