	public int serialize(int base, byte[] data) {

		int formulaSize = field_2_refPtg == null ? field_2_unknownFormulaData.length : field_2_refPtg.getSize();
		int idOffset = getStreamIDOffset(formulaSize);
		int dataSize = getDataSize(idOffset);
		

		LittleEndian.putUShort(data, base + 0, sid);
		LittleEndian.putUShort(data, base + 2, dataSize);

		LittleEndian.putUShort(data, base + 4, idOffset);
		LittleEndian.putUShort(data, base + 6, formulaSize);
		LittleEndian.putInt(data, base + 8, field_1_unknown_int);

		int pos = base+12;

		if (field_2_refPtg == null) {
			System.arraycopy(field_2_unknownFormulaData, 0, data, pos, field_2_unknownFormulaData.length);
		} else {
			field_2_refPtg.writeBytes(data, pos);
		}
	   	pos += formulaSize;

		int stringLen;
		if (field_4_ole_classname == null) {
			// don't write 0x03, stringLen, flag, text
			stringLen = 0;
		} else {
			LittleEndian.putByte(data, pos, 0x03);
			pos += 1;
			stringLen = field_4_ole_classname.length();
			LittleEndian.putUShort(data, pos, stringLen);
			pos += 2;
			LittleEndian.putByte(data, pos, field_3_unicode_flag ? 0x01 : 0x00);
			pos += 1;

			if (field_3_unicode_flag) {
				StringUtil.putUnicodeLE(field_4_ole_classname, data, pos);
				pos += stringLen * 2;
			} else {
				StringUtil.putCompressedUnicode(field_4_ole_classname, data, pos);
				pos += stringLen;
			}
		}

		// pad to next 2-byte boundary (requires 0 or 1 bytes)
		switch(idOffset - (pos - 6 - base)) { // 6 for 3 shorts: sid, dataSize, idOffset
			case 1:
				LittleEndian.putByte(data, pos, field_4_unknownByte == null ? 0x00 : field_4_unknownByte.intValue());
				pos ++;
			case 0:
				break;
			default:
				throw new IllegalStateException("Bad padding calculation (" + idOffset + ", " + (pos-base) + ")");	
		}

		if (field_5_stream_id != null) {
    		LittleEndian.putInt(data, pos, field_5_stream_id.intValue());
    		pos += 4;
		}
		System.arraycopy(field_6_unknown, 0, data, pos, field_6_unknown.length);

		return 4 + dataSize;
	}

