    private int calcRecordSizesForLongStrings( int unicodesize )
    {
        int retval;
        UnicodeString unistr = null;
        int stringreminant = 0;
        int unipos = 0;
        boolean lastneedcontinue = false;
        int stringbyteswritten = 0;
        boolean finished = false;
        boolean first_record = true;
        int totalWritten = 0;

        while ( !finished )
        {
            int record = 0;
            int pos = 0;

            if ( first_record )
            {

                // writing SST record
                record = SSTRecord.MAX_RECORD_SIZE;
                pos = 12;
                first_record = false;
                recordLengths.add( new Integer( record - SSTRecord.STD_RECORD_OVERHEAD ) );
            }
            else
            {

                // writing continue record
                pos = 0;
                int to_be_written = ( unicodesize - stringbyteswritten ) + ( lastneedcontinue ? 1 : 0 );
                int size = Math.min( SSTRecord.MAX_RECORD_SIZE - SSTRecord.STD_RECORD_OVERHEAD, to_be_written );

                if ( size == to_be_written )
                {
                    finished = true;
                }
                record = size + SSTRecord.STD_RECORD_OVERHEAD;
                recordLengths.add( new Integer( size ) );
                pos = 4;
            }
            if ( lastneedcontinue )
            {
                int available = SSTRecord.MAX_RECORD_SIZE - pos;

                if ( stringreminant <= available )
                {

                    // write reminant
                    stringbyteswritten += stringreminant - 1;
                    pos += stringreminant;
                    lastneedcontinue = false;
                }
                else
                {

                    // write as much of the remnant as possible
                    int toBeWritten = unistr.maxBrokenLength( available );

                    if ( available != toBeWritten )
                    {
                        int shortrecord = record - ( available - toBeWritten );
                        recordLengths.set( recordLengths.size() - 1,
                                new Integer( shortrecord - SSTRecord.STD_RECORD_OVERHEAD ) );
                        record = shortrecord;
                    }
                    stringbyteswritten += toBeWritten - 1;
                    pos += toBeWritten;
                    stringreminant -= toBeWritten - 1;
                    lastneedcontinue = true;
                }
            }
            for ( ; unipos < strings.size(); unipos++ )
            {
                int available = SSTRecord.MAX_RECORD_SIZE - pos;
                Integer intunipos = new Integer( unipos );

                unistr = ( (UnicodeString) strings.get( intunipos ) );
                if ( unistr.getRecordSize() <= available )
                {
                    stringbyteswritten += unistr.getRecordSize();
                    pos += unistr.getRecordSize();
                }
                else
                {
                    if ( available >= SSTRecord.STRING_MINIMAL_OVERHEAD )
                    {
                        int toBeWritten =
                                unistr.maxBrokenLength( available );

                        stringbyteswritten += toBeWritten;
                        stringreminant =
                                ( unistr.getRecordSize() - toBeWritten )
                                + LittleEndianConsts.BYTE_SIZE;
                        if ( available != toBeWritten )
                        {
                            int shortrecord = record
                                    - ( available - toBeWritten );

                            recordLengths.set(
                                    recordLengths.size() - 1,
                                    new Integer(
                                            shortrecord - SSTRecord.STD_RECORD_OVERHEAD ) );
                            record = shortrecord;
                        }
                        lastneedcontinue = true;
                        unipos++;
                    }
                    else
                    {
                        int shortrecord = record - available;

                        recordLengths.set( recordLengths.size() - 1,
                                new Integer( shortrecord - SSTRecord.STD_RECORD_OVERHEAD ) );
                        record = shortrecord;
                    }
                    break;
                }
            }
            totalWritten += record;
        }
        retval = totalWritten;

        return retval;
    }

