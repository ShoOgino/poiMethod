	/**
	 * gets the record constructors and sticks them in the map by SID
	 * @return map of SIDs to short,short,byte[] constructors for Record classes
	 * most of org.apache.poi.hssf.record.*
	 */
	private static Map<Short, I_RecordCreator> recordsToMap(Class<? extends Record> [] records) {
		Map<Short, I_RecordCreator> result = new HashMap<Short, I_RecordCreator>();
		Set<Class<?>> uniqueRecClasses = new HashSet<Class<?>>(records.length * 3 / 2);

		for (int i = 0; i < records.length; i++) {

			Class<? extends Record> recClass = records[ i ];
			if(!Record.class.isAssignableFrom(recClass)) {
				throw new RuntimeException("Invalid record sub-class (" + recClass.getName() + ")");
			}
			if(Modifier.isAbstract(recClass.getModifiers())) {
				throw new RuntimeException("Invalid record class (" + recClass.getName() + ") - must not be abstract");
			}
			if(!uniqueRecClasses.add(recClass)) {
				throw new RuntimeException("duplicate record class (" + recClass.getName() + ")");
			}
			
			short sid;
			Constructor<? extends Record> constructor;
			try {
				sid = recClass.getField("sid").getShort(null);
				constructor = recClass.getConstructor(CONSTRUCTOR_ARGS);
			} catch (Exception illegalArgumentException) {
				throw new RecordFormatException(
					"Unable to determine record types");
			}
			Short key = new Short(sid);
			if (result.containsKey(key)) {
				String prevClassName = result.get(key).getRecordClassName();
				throw new RuntimeException("duplicate record sid 0x" + Integer.toHexString(sid).toUpperCase()
						+ " for classes (" + recClass.getName() + ") and (" + prevClassName + ")");
			}
			result.put(key, new ReflectionRecordCreator(constructor));
		}
		return result;
	}

