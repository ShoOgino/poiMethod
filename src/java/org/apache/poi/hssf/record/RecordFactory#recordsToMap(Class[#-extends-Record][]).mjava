    /**
     * gets the record constructors and sticks them in the map by SID
     * @return map of SIDs to short,short,byte[] constructors for Record classes
     * most of org.apache.poi.hssf.record.*
     */
    private static Map<Integer, I_RecordCreator> recordsToMap(Class<? extends Record> [] records) {
        Map<Integer, I_RecordCreator> result = new HashMap<>();
        Set<Class<?>> uniqueRecClasses = new HashSet<>(records.length * 3 / 2);

        for (Class<? extends Record> recClass : records) {
            if(!Record.class.isAssignableFrom(recClass)) {
                throw new RuntimeException("Invalid record sub-class (" + recClass.getName() + ")");
            }
            if(Modifier.isAbstract(recClass.getModifiers())) {
                throw new RuntimeException("Invalid record class (" + recClass.getName() + ") - must not be abstract");
            }
            if(!uniqueRecClasses.add(recClass)) {
                throw new RuntimeException("duplicate record class (" + recClass.getName() + ")");
            }

            int sid;
            try {
                sid = recClass.getField("sid").getShort(null);
            } catch (Exception illegalArgumentException) {
                throw new org.apache.poi.util.RecordFormatException(
                        "Unable to determine record types");
            }
            Integer key = Integer.valueOf(sid);
            if (result.containsKey(key)) {
                Class<?> prevClass = result.get(key).getRecordClass();
                throw new RuntimeException("duplicate record sid 0x" +
                        Integer.toHexString(sid).toUpperCase(Locale.ROOT)
                        + " for classes (" + recClass.getName() + ") and ("
                        + prevClass.getName() + ")");
            }
            result.put(key, getRecordCreator(recClass));
        }
        // result.put(Integer.valueOf(0x0406), result.get(Integer.valueOf(0x06)));
        return result;
    }

