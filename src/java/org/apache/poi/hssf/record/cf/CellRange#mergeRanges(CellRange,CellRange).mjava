	/**
	 * @return the new range(s) to replace the supplied ones.  <code>null</code> if no merge is possible
	 */
	private static CellRange[] mergeRanges(CellRange range1, CellRange range2) {
		
		int x = range1.intersect(range2);
		switch(x)
		{
			case CellRange.NO_INTERSECTION: 
				if( range1.hasExactSharedBorder(range2))
				{
					return new CellRange[] { range1.createEnclosingCellRange(range2), };
				}
				// else - No intersection and no shared border: do nothing 
				return null;
			case CellRange.OVERLAP:
				return resolveRangeOverlap(range1, range2);
			case CellRange.INSIDE:
				// Remove range2, since it is completely inside of range1
				return new CellRange[] { range1, };
			case CellRange.ENCLOSES:
				// range2 encloses range1, so replace it with the enclosing one
				return new CellRange[] { range2, };
		}
		throw new RuntimeException("unexpected intersection result (" + x + ")");
	}

