	/**
	 * @param crB never a full row or full column range
	 * @return an array including <b>this</b> <tt>CellRange</tt> and all parts of <tt>range</tt> 
	 * outside of this range  
	 */
	private static CellRangeAddress[] sliceUp(CellRangeAddress crA, CellRangeAddress crB) {
		
		List temp = new ArrayList();
		
		// Chop up range horizontally and vertically
		temp.add(crB);
		if(!crA.isFullColumnRange()) {
			temp = cutHorizontally(crA.getFirstRow(), temp);
			temp = cutHorizontally(crA.getLastRow()+1, temp);
		}
		if(!crA.isFullRowRange()) {
			temp = cutVertically(crA.getFirstColumn(), temp);
			temp = cutVertically(crA.getLastColumn()+1, temp);
		}
		CellRangeAddress[] crParts = toArray(temp);

		// form result array
		temp.clear();
		temp.add(crA);
		
		for (int i = 0; i < crParts.length; i++) {
			CellRangeAddress crPart = crParts[i];
			// only include parts that are not enclosed by this
			if(intersect(crA, crPart) != ENCLOSES) {
				temp.add(crPart);
			}
		}
		return toArray(temp);
	}

