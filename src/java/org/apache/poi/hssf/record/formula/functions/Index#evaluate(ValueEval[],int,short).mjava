	public ValueEval evaluate(ValueEval[] args, int srcCellRow, short srcCellCol) {
		int nArgs = args.length;
		if(nArgs < 2) {
			// too few arguments
			return ErrorEval.VALUE_INVALID;
		}
		Eval firstArg = args[0];
		if (firstArg instanceof RefEval) {
			// convert to area ref for simpler code in getValueFromArea()
			firstArg = ((RefEval)firstArg).offset(0, 0, 0, 0);
		}
		if(!(firstArg instanceof AreaEval)) {

			// else the other variation of this function takes an array as the first argument
			// it seems like interface 'ArrayEval' does not even exist yet
			throw new RuntimeException("Incomplete code - cannot handle first arg of type ("
					+ firstArg.getClass().getName() + ")");
		}
		AreaEval reference = (AreaEval) firstArg;

		int rowIx = 0;
		int columnIx = 0;
		boolean colArgWasPassed = false;
		try {
			switch(nArgs) {
				case 4:
					throw new RuntimeException("Incomplete code" +
							" - don't know how to support the 'area_num' parameter yet)");
					// Excel expression might look like this "INDEX( (A1:B4, C3:D6, D2:E5 ), 1, 2, 3)
					// In this example, the 3rd area would be used i.e. D2:E5, and the overall result would be E2
					// Token array might be encoded like this: MemAreaPtg, AreaPtg, AreaPtg, UnionPtg, UnionPtg, ParenthesesPtg
					// The formula parser doesn't seem to support this yet. Not sure if the evaluator does either

				case 3:
					columnIx = resolveIndexArg(args[2], srcCellRow, srcCellCol);
					colArgWasPassed = true;
				case 2:
					rowIx = resolveIndexArg(args[1], srcCellRow, srcCellCol);
					break;
				default:
					// too many arguments
					return ErrorEval.VALUE_INVALID;
			}
			return getValueFromArea(reference, rowIx, columnIx, colArgWasPassed, srcCellRow, srcCellCol);
		} catch (EvaluationException e) {
			return e.getErrorEval();
		}
	}

