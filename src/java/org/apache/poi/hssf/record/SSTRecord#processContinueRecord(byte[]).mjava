    /**
     * Process a Continue record. A Continue record for an SST record
     * contains the same kind of data that the SST record contains,
     * with the following exceptions:
     * <P>
     * <OL>
     * <LI>The string counts at the beginning of the SST record are
     *     not in the Continue record
     * <LI>The first string in the Continue record might NOT begin
     *     with a size. If the last string in the previous record is
     *     continued in this record, the size is determined by that
     *     last string in the previous record; the first string will
     *     begin with a flag byte, followed by the remaining bytes (or
     *     words) of the last string from the previous
     *     record. Otherwise, the first string in the record will
     *     begin with a string length
     * </OL>
     *
     * @param record the Continue record's byte data
     */

    public void processContinueRecord(final byte [] record)
    {
        if (getExpectedChars() == 0)
        {
            _unfinished_string  = "";
            _total_length_bytes = 0;
            _string_data_offset = 0;
            _wide_char          = false;
            manufactureStrings(record, 0, ( short ) record.length);
        }
        else
        {
            int data_length = record.length - LittleEndianConsts.BYTE_SIZE;

            if (calculateByteCount(getExpectedChars()) > data_length)
            {

                // create artificial data to create a UnicodeString
                byte[] input =
                    new byte[ record.length + LittleEndianConsts.SHORT_SIZE ];
                short  size  = ( short ) (((record[ 0 ] & 1) == 1)
                                          ? (data_length
                                             / LittleEndianConsts.SHORT_SIZE)
                                          : (data_length
                                             / LittleEndianConsts.BYTE_SIZE));

                LittleEndian.putShort(input, ( byte ) 0, size);
                System.arraycopy(record, 0, input,
                                 LittleEndianConsts.SHORT_SIZE,
                                 record.length);
                UnicodeString ucs = new UnicodeString(UnicodeString.sid,
                                                      ( short ) input.length,
                                                      input);

                _unfinished_string = _unfinished_string + ucs.getString();
                setExpectedChars(getExpectedChars() - size);
            }
            else
            {
                setupStringParameters(record, -LittleEndianConsts.SHORT_SIZE,
                                      getExpectedChars());
                byte[] str_data = new byte[ _total_length_bytes ];
                int    length   = _string_minimal_overhead
                                  + (calculateByteCount(getExpectedChars()));
                byte[] bstring  = new byte[ length ];

                // Copy data from the record into the string
                // buffer. Copy skips the length of a short in the
                // string buffer, to leave room for the string length.
                System.arraycopy(record, 0, str_data,
                                 LittleEndianConsts.SHORT_SIZE,
                                 str_data.length
                                 - LittleEndianConsts.SHORT_SIZE);

                // write the string length
                LittleEndian.putShort(bstring, 0,
                                      ( short ) getExpectedChars());

                // write the options flag
                bstring[ LittleEndianConsts.SHORT_SIZE ] =
                    str_data[ LittleEndianConsts.SHORT_SIZE ];

                // copy the bytes/words making up the string; skipping
                // past all the overhead of the str_data array
                System.arraycopy(str_data, _string_data_offset, bstring,
                                 _string_minimal_overhead,
                                 bstring.length - _string_minimal_overhead);

                // use special constructor to create the final string
                UnicodeString string  =
                    new UnicodeString(UnicodeString.sid,
                                      ( short ) bstring.length, bstring,
                                      _unfinished_string);
                Integer       integer = new Integer(field_3_strings.size());

                field_3_strings.put(integer, string);
                manufactureStrings(record,
                                   _total_length_bytes
                                   - LittleEndianConsts
                                       .SHORT_SIZE, ( short ) record.length);
            }
        }
    }

