	/**
	 * called by the class that is responsible for writing this sucker.
	 * Subclasses should implement this so that their data is passed back in a
	 * byte array.
	 *
	 * @param pOffset to begin writing at
	 * @param data byte array containing instance data
	 * @return number of bytes written
	 */
	public int serialize(int pOffset, byte [] data) {
		
		int formula1Len=getFormulaSize(field_17_formula1);
		int formula2Len=getFormulaSize(field_18_formula2);
		
		int recordsize = getRecordSize();
		
		LittleEndianByteArrayOutputStream out = new LittleEndianByteArrayOutputStream(data, pOffset, recordsize);
		
		out.writeShort(sid);
		out.writeShort(recordsize-4);
		out.writeByte(field_1_condition_type);
		out.writeByte(field_2_comparison_operator);
		out.writeShort(formula1Len);
		out.writeShort(formula2Len);
		out.writeInt(field_5_options);
		out.writeShort(field_6_not_used);
		
		if (containsFontFormattingBlock()) {
			byte[] fontFormattingRawRecord  = fontFormatting.getRawRecord();
			out.write(fontFormattingRawRecord);
		}
		
		if (containsBorderFormattingBlock()) {
			borderFormatting.serialize(out);
		}
		
		if (containsPatternFormattingBlock()) {
			patternFormatting.serialize(out);
		}
		
		field_17_formula1.serializeTokens(out);
		field_18_formula2.serializeTokens(out);
		
		if(out.getWriteIndex() - pOffset != recordsize) {
			throw new IllegalStateException("write mismatch (" 
					+ (out.getWriteIndex() - pOffset) + "!=" + recordsize + ")");
		}
		return recordsize;
	}

