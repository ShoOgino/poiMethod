	/**
	 * called by the class that is responsible for writing this sucker.
	 * Subclasses should implement this so that their data is passed back in a
	 * byte array.
	 *
	 * @param offset to begin writing at
	 * @param data byte array containing instance data
	 * @return number of bytes written
	 */
	public int serialize(int pOffset, byte [] data)
	{
		
		int formula1Len=getFormulaSize(field_17_formula1);
		int formula2Len=getFormulaSize(field_18_formula2);
		
		int offset = pOffset;
		int recordsize = getRecordSize();
		LittleEndian.putShort(data, 0 + offset, sid);
		LittleEndian.putShort(data, 2 + offset, (short)(recordsize-4));
		data[4 + offset] = field_1_condition_type;
		data[5 + offset] = field_2_comparison_operator;
		LittleEndian.putUShort(data, 6 + offset, formula1Len);
		LittleEndian.putUShort(data, 8 + offset, formula2Len);
		LittleEndian.putInt(data,  10 + offset, field_5_options);
		LittleEndian.putShort(data,14 + offset, field_6_not_used);
		
		offset += 16;
		
		if( containsFontFormattingBlock() )
		{
			byte[] fontFormattingRawRecord  = fontFormatting.getRawRecord();
			System.arraycopy(fontFormattingRawRecord, 0, data, offset, fontFormattingRawRecord.length);
			offset += fontFormattingRawRecord.length;
		}
		
		if( containsBorderFormattingBlock())
		{
			offset += borderFormatting.serialize(offset, data);
		}
		
		if( containsPatternFormattingBlock() )
		{
			offset += patternFormatting.serialize(offset, data);
		}
		
		if (field_17_formula1 != null) {
			offset += Ptg.serializePtgs(field_17_formula1, data, offset);
		}

		if (field_18_formula2 != null) {
			offset += Ptg.serializePtgs(field_18_formula2, data, offset);
		}
		if(offset - pOffset != recordsize) {
			throw new IllegalStateException("write mismatch (" + (offset - pOffset) + "!=" + recordsize + ")");
		}
		return recordsize;
	}

