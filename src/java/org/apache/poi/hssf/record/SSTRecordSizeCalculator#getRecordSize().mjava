    public int getRecordSize() {
       //Indicates how much of the current base or continue record has
       //been written
       int continueSize = SSTRecord.SST_RECORD_OVERHEAD;
       int recordSize = 0;
        for (int i=0; i < strings.size(); i++ )
        {
          Integer intunipos = new Integer(i);    
          UnicodeString unistr = ( (UnicodeString) strings.get(intunipos));
          final int stringLength = unistr.getRecordSize();
          if ((continueSize + stringLength) <= SSTRecord.MAX_RECORD_SIZE) {
            //String can fit within the bounds of the current record (SST or Continue)
            continueSize += stringLength;
            
            if ((i < (strings.size()-1)) && !canFitStringInRecord(continueSize)) {
              //Start new continueRecord if there is another string              
              recordLengths.add(new Integer(continueSize));
              recordSize += continueSize;
              //Minimum ammount of space for a new continue record.
              continueSize = 4;   
            }
          } else {
            int stringRemainder = stringLength;
            while (stringRemainder != 0) {              
              if ( (continueSize + stringRemainder) > SSTRecord.MAX_RECORD_SIZE) {
                //Determine number of bytes that can be written in the space
                //available
                int bytesWritten = Math.min((SSTRecord.MAX_RECORD_SIZE - continueSize), stringRemainder);

                //Ensure that the Unicode String writes both the high and low
                //byte in the one action. Since the string overhead is 3 bytes
                //if the bytes that can be written is even, then we need to 
                //write one less byte to capture both the high and low bytes.
                bytesWritten = unistr.maxBrokenLength(bytesWritten);
                continueSize += bytesWritten;
                stringRemainder -= bytesWritten;
                recordLengths.add(new Integer(continueSize));
                recordSize += continueSize;
                //Minimum ammount of space for a new continue record.
                continueSize = 4;
                //Add one to the size of the string that is remaining, since the
                //first byte for the next continue record will be compressed unicode indicator
                stringRemainder++;
              } else {
                //Remainder of string can fit within the bounds of the current
                //continue record
                continueSize += stringRemainder;
                stringRemainder = 0;
                if ((i < (strings.size()-1)) && !canFitStringInRecord(continueSize)) {
                  //Start new continueRecord if there is another string
                  recordLengths.add(new Integer(continueSize));
                  recordSize += continueSize;
                  //Minimum ammount of space for a new continue record.
                  continueSize = 4;          
        }
    }
        }
            }
        }
        recordLengths.add(new Integer(continueSize));
        recordSize += continueSize;        
        return recordSize;
    }

