	public EmbeddedObjectRefSubRecord(RecordInputStream in) {
		// Much guess-work going on here due to lack of any documentation.
		// See similar source code in OOO:
		// http://lxr.go-oo.org/source/sc/sc/source/filter/excel/xiescher.cxx
		// 1223 void XclImpOleObj::ReadPictFmla( XclImpStream& rStrm, sal_uInt16 nRecSize )

		int streamIdOffset = in.readShort(); // OOO calls this 'nFmlaLen'

		int dataLenAfterFormula = in.remaining() - streamIdOffset;
		int formulaSize = in.readUShort();
		field_1_unknown_int = in.readInt();
		byte[] formulaRawBytes = readRawData(in, formulaSize);
		field_2_refPtg = readRefPtg(formulaRawBytes);
		if (field_2_refPtg == null) {
			// common case
			// field_2_n16 seems to be 5 here
			// The formula almost looks like tTbl but the row/column values seem like garbage.
			field_2_unknownFormulaData = formulaRawBytes;
		} else {
			field_2_unknownFormulaData = null;
		}

		int stringByteCount;
		if (in.remaining() >= dataLenAfterFormula + 3) {
			int tag = in.readByte();
			if (tag != 0x03) {
				throw new RecordFormatException("Expected byte 0x03 here");
			}
			int nChars = in.readUShort();
			if (nChars > 0) {
				 // OOO: the 4th way Xcl stores a unicode string: not even a Grbit byte present if length 0
				field_3_unicode_flag		   = ( in.readByte() & 0x01 ) != 0;
				if (field_3_unicode_flag) {
					field_4_ole_classname = in.readUnicodeLEString(nChars);
					stringByteCount = nChars * 2;
				} else {
					field_4_ole_classname = in.readCompressedUnicode(nChars);
					stringByteCount = nChars;
				}
			} else {
				field_4_ole_classname = "";
				stringByteCount = 0;
			}
		} else {
			field_4_ole_classname = null;
			stringByteCount = 0;
		}
		// Pad to next 2-byte boundary
		if (((stringByteCount + formulaSize) % 2) != 0) {
			int b = in.readByte();
			if (field_2_refPtg != null && field_4_ole_classname == null) {
				field_4_unknownByte = new Byte((byte)b);
			}
		}
		int nUnexpectedPadding = in.remaining() - dataLenAfterFormula;

		if (nUnexpectedPadding > 0) {
			System.err.println("Discarding " + nUnexpectedPadding + " unexpected padding bytes ");
			readRawData(in, nUnexpectedPadding);
		}

		// Fetch the stream ID
		if (dataLenAfterFormula >= 4) {
			field_5_stream_id = new Integer(in.readInt());
		} else {
			field_5_stream_id = null;
		}

		field_6_unknown = in.readRemainder();
	}

