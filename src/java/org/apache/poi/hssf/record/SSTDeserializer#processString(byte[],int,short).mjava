    private void processString( final byte[] data, final int index,
                                final short char_count )
    {
        byte[] stringDataBuffer = new byte[totalLengthBytes];
        int length = SSTRecord.STRING_MINIMAL_OVERHEAD + calculateByteCount( char_count );
        byte[] bstring = new byte[length];

        System.arraycopy( data, index, stringDataBuffer, 0, stringDataBuffer.length );
        int offset = 0;

        LittleEndian.putShort( bstring, offset, char_count );
        offset += LittleEndianConsts.SHORT_SIZE;
        bstring[offset] = stringDataBuffer[offset];

//        System.out.println( "offset = " + stringDataOffset );
//        System.out.println( "length = " + (bstring.length - STRING_MINIMAL_OVERHEAD) );
//        System.out.println( "src.length = " + str_data.length );
//        try
//        {
//            System.out.println( "----------------------- DUMP -------------------------" );
//            HexDump.dump( stringDataBuffer, (long)stringDataOffset, System.out, 1);
//        }
//        catch ( IOException e )
//        {
//        }
//        catch ( ArrayIndexOutOfBoundsException e )
//        {
//        }
//        catch ( IllegalArgumentException e )
//        {
//        }
        System.arraycopy( stringDataBuffer, stringDataOffset, bstring,
                SSTRecord.STRING_MINIMAL_OVERHEAD,
                bstring.length - SSTRecord.STRING_MINIMAL_OVERHEAD );
        UnicodeString string = new UnicodeString( UnicodeString.sid,
                (short) bstring.length,
                bstring );

        if ( getExpectedChars() != 0 )
        {
            unfinishedString = string.getString();
        }
        else
        {
            Integer integer = new Integer( strings.size() );
            addToStringTable( strings, integer, string );
        }
    }

