    /**
     * gets the record constructors and sticks them in the map by SID
     * @return map of SIDs to short,short,byte[] constructors for Record classes
     * most of org.apache.poi.hssf.record.*
     */
    private static Map recordsToMap(Class [] records) {
        Map result = new HashMap();
        Set uniqueRecClasses = new HashSet(records.length * 3 / 2);

        for (int i = 0; i < records.length; i++) {

            Class recClass = records[ i ];
            String cn = recClass.getName();
			System.out.println(cn.substring(cn.lastIndexOf('.')+1) + ".class,");
            if(!Record.class.isAssignableFrom(recClass)) {
                throw new RuntimeException("Invalid record sub-class (" + cn + ")");
            }
            if(Modifier.isAbstract(recClass.getModifiers())) {
                throw new RuntimeException("Invalid record class (" + cn + ") - must not be abstract");
            }
            if(!uniqueRecClasses.add(recClass)) {
                throw new RuntimeException("duplicate record class (" + cn + ")");
            }
            
            short sid;
            Constructor constructor;
            try {
                sid         = recClass.getField("sid").getShort(null);
                constructor = recClass.getConstructor(CONSTRUCTOR_ARGS);
            } catch (Exception illegalArgumentException) {
                throw new RecordFormatException(
                    "Unable to determine record types");
            }
            Short key = new Short(sid);
			if (result.containsKey(key)) {
            	Class prev = (Class)result.get(key);
                throw new RuntimeException("duplicate record sid 0x" + Integer.toHexString(sid).toUpperCase()
                		+ " for classes (" + cn + ") and (" + prev.getName() + ")");
            }
            result.put(key, constructor);
        }
        return result;
    }

