	/**
	 * @param callerForceArrayFlag <code>true</code> if one of the current node's parents is a 
	 * function Ptg which has been changed from default 'V' to 'A' type (due to requirements on
	 * the function return value).
	 */
	private void transformNode(ParseNode node, byte desiredOperandClass,
			boolean callerForceArrayFlag, boolean isDirectChildOfValueOperator) {
		Ptg token = node.getToken();
		ParseNode[] children = node.getChildren();
		if (token instanceof ValueOperatorPtg || token instanceof ControlPtg) {
			// Value Operator Ptgs and Control are base tokens, so token will be unchanged
			
			// but any child nodes are processed according to desiredOperandClass and callerForceArrayFlag
			for (int i = 0; i < children.length; i++) {
				ParseNode child = children[i];
				transformNode(child, desiredOperandClass, callerForceArrayFlag, true);
			}
			return;
		}
		if (token instanceof AbstractFunctionPtg) {
			transformFunctionNode((AbstractFunctionPtg) token, children, desiredOperandClass,
					callerForceArrayFlag);
			return;
		}
		if (children.length > 0) {
			throw new IllegalStateException("Node should not have any children");
		}

		if (token.isBaseToken()) {
			// nothing to do
			return;
		}
		if (isDirectChildOfValueOperator) {
			// As per OOO documentation Sec 3.2.4 "Token Class Transformation", "Step 1"
			// All direct operands of value operators that are initially 'R' type will 
			// be converted to 'V' type.
			if (token.getPtgClass() == Ptg.CLASS_REF) {
				token.setClass(Ptg.CLASS_VALUE); 
			}
		}
		token.setClass(transformClass(token.getPtgClass(), desiredOperandClass, callerForceArrayFlag));
	}

