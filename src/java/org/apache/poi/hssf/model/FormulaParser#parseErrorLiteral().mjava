    private int parseErrorLiteral() {
        Match('#');
        String part1 = parseIdentifier().toUpperCase();

        switch(part1.charAt(0)) {
            case 'V':
                if(part1.equals("VALUE")) {
                    Match('!');
                    return HSSFErrorConstants.ERROR_VALUE;
                }
                throw expected("#VALUE!");
            case 'R':
                if(part1.equals("REF")) {
                    Match('!');
                    return HSSFErrorConstants.ERROR_REF;
                }
                throw expected("#REF!");
            case 'D':
                if(part1.equals("DIV")) {
                    Match('/');
                    Match('0');
                    Match('!');
                    return HSSFErrorConstants.ERROR_DIV_0;
                }
                throw expected("#DIV/0!");
            case 'N':
                if(part1.equals("NAME")) {
                    Match('?');  // only one that ends in '?'
                    return HSSFErrorConstants.ERROR_NAME;
                }
                if(part1.equals("NUM")) {
                    Match('!');
                    return HSSFErrorConstants.ERROR_NUM;
                }
                if(part1.equals("NULL")) {
                    Match('!');
                    return HSSFErrorConstants.ERROR_NULL;
                }
                if(part1.equals("N")) {
                    Match('/');
                    if(look != 'A' && look != 'a') {
                        throw expected("#N/A");
                    }
                    Match(look);
                    // Note - no '!' or '?' suffix
                    return HSSFErrorConstants.ERROR_NA;
                }
                throw expected("#NAME?, #NUM!, #NULL! or #N/A");

        }
        throw expected("#VALUE!, #REF!, #DIV/0!, #NAME?, #NUM!, #NULL! or #N/A");
    }

