    /**
     * Static method to convert an array of Ptgs in RPN order
     * to a human readable string format in infix mode.
     * @param book  workbook for named and 3D references
     * @param ptgs  array of Ptg, can be null or empty
     * @return a human readable String
     */
    public static String toFormulaString(Workbook book, Ptg[] ptgs) {
        if (ptgs == null || ptgs.length == 0) {
            // TODO - what is the justification for returning "#NAME" (which is not "#NAME?", btw)
            return "#NAME";
        }
        Stack stack = new Stack();

           // Excel allows to have AttrPtg at position 0 (such as Blanks) which
           // do not have any operands. Skip them.
        int i;
        if(ptgs[0] instanceof AttrPtg) {
            AttrPtg attrPtg0 = (AttrPtg) ptgs[0];
            if(attrPtg0.isSemiVolatile()) {
                // no visible formula for semi-volatile
            } else {
                // TODO -this requirement is unclear and is not addressed by any junits
                stack.push(ptgs[0].toFormulaString(book));
            }
            i=1;
        } else {
            i=0;
        }

        for ( ; i < ptgs.length; i++) {
            Ptg ptg = ptgs[i];
            // TODO - what about MemNoMemPtg?
            if(ptg instanceof MemAreaPtg || ptg instanceof MemFuncPtg || ptg instanceof MemErrPtg) {
                // marks the start of a list of area expressions which will be naturally combined
                // by their trailing operators (e.g. UnionPtg)
                // TODO - put comment and throw exception in toFormulaString() of these classes
                continue;
            }
            if (! (ptg instanceof OperationPtg)) {
                stack.push(ptg.toFormulaString(book));
                continue;
            }

            if (ptg instanceof AttrPtg && ((AttrPtg) ptg).isOptimizedIf()) {
                continue;
            }

            final OperationPtg o = (OperationPtg) ptg;
            int nOperands = o.getNumberOfOperands();
            final String[] operands = new String[nOperands];

            for (int j = nOperands-1; j >= 0; j--) {
                if(stack.isEmpty()) {
                    //TODO: write junit to prove this works
                   String msg = "Too few arguments suppled to operation token ("
                        + o.getClass().getName() + "). Expected (" + nOperands
                        + " but got " + (nOperands - j + 1);
                    throw new FormulaParseException(msg);
                }
                operands[j] = (String) stack.pop();
            }
            stack.push(o.toFormulaString(operands));
        }
        if(stack.isEmpty()) {
            // inspection of the code above reveals that every stack.pop() is followed by a 
            // stack.push(). So this is either an internal error or impossible.
            throw new IllegalStateException("Stack underflow");
        }
        String result = (String) stack.pop();
        if(!stack.isEmpty()) {
            // Might be caused by some tokens like AttrPtg and Mem*Ptg, which really shouldn't
            // put anything on the stack
            throw new IllegalStateException("too much stuff left on the stack");
        }
        return result;
    }

