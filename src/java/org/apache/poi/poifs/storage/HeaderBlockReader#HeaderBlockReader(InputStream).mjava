	/**
	 * create a new HeaderBlockReader from an InputStream
	 *
	 * @param stream the source InputStream
	 *
	 * @exception IOException on errors or bad data
	 */
	public HeaderBlockReader(InputStream stream) throws IOException {
		// At this point, we don't know how big our
		//  block sizes are
		// So, read the first 32 bytes to check, then
		//  read the rest of the block
		byte[] blockStart = new byte[32];
		int bsCount = IOUtils.readFully(stream, blockStart);
		if(bsCount != 32) {
			throw alertShortRead(bsCount, 32);
		}

		// verify signature
		long signature = LittleEndian.getLong(blockStart, _signature_offset);

		if (signature != _signature) {
			// Is it one of the usual suspects?
			byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;
			if(blockStart[0] == OOXML_FILE_HEADER[0] &&
				blockStart[1] == OOXML_FILE_HEADER[1] &&
				blockStart[2] == OOXML_FILE_HEADER[2] &&
				blockStart[3] == OOXML_FILE_HEADER[3]) {
				throw new OfficeXmlFileException("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");
			}
			if ((signature & 0xFF8FFFFFFFFFFFFFL) == 0x0010000200040009L) {
				// BIFF2 raw stream starts with BOF (sid=0x0009, size=0x0004, data=0x00t0)
				throw new IllegalArgumentException("The supplied data appears to be in BIFF2 format.  "
						+ "POI only supports BIFF8 format");
			}

			// Give a generic error
			throw new IOException("Invalid header signature; read "
				                  + longToHex(signature) + ", expected "
				                  + longToHex(_signature));
		}


		// Figure out our block size
		switch (blockStart[30]) {
			case 12:
				bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE; break;
			case  9:
				bigBlockSize = POIFSConstants.BIG_BLOCK_SIZE; break;
			default:
				throw new IOException("Unsupported blocksize  (2^"
						+ blockStart[30] + "). Expected 2^9 or 2^12.");
		}
		_data = new byte[ bigBlockSize ];
		System.arraycopy(blockStart, 0, _data, 0, blockStart.length);

		// Now we can read the rest of our header
		int byte_count = IOUtils.readFully(stream, _data, blockStart.length, _data.length - blockStart.length);
		if (byte_count+bsCount != bigBlockSize) {
			throw alertShortRead(byte_count, bigBlockSize);
		}

		_bat_count      = getInt(_bat_count_offset, _data);
		_property_start = getInt(_property_start_offset, _data);
		_sbat_start     = getInt(_sbat_start_offset, _data);
		_xbat_start     = getInt(_xbat_start_offset, _data);
		_xbat_count     = getInt(_xbat_count_offset, _data);
	}

