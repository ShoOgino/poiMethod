	/* package */ static int readFullyInternal(byte[] buf, int off, int len, int currentOffset, int maxSize, Function<Integer,DataInputBlock> nextDataInputBlock) {
		DataInputBlock currentBlock = nextDataInputBlock.apply(currentOffset);
		if (currentBlock == null) {
			throw new IllegalStateException("reached end of document stream unexpectedly");
		}
		int blockAvailable = currentBlock.available();
		if (blockAvailable > len) {
			currentBlock.readFully(buf, off, len);
			return currentOffset + len;
		}
		// else read big amount in chunks
		int remaining = len;
		int writePos = off;
		int offset = currentOffset;
		while (remaining > 0) {
			final boolean blockIsExpiring = remaining >= blockAvailable;
			final int reqSize = (blockIsExpiring) ? blockAvailable : remaining;
			currentBlock.readFully(buf, writePos, reqSize);
			remaining -= reqSize;
			writePos += reqSize;
			offset += reqSize;
			if (blockIsExpiring) {
				if (offset >= maxSize) {
					if (remaining > 0) {
						throw new IllegalStateException(
								"reached end of document stream unexpectedly");
					}
					break;
				}
				currentBlock = nextDataInputBlock.apply(offset);
				if (currentBlock == null) {
					throw new IllegalStateException(
							"reached end of document stream unexpectedly");
				}
				blockAvailable = currentBlock.available();
			}
		}
		return offset;
	}

