    /**
     * Skips over and discards n bytes of data from this input
     * stream. The skip method may, for a variety of reasons, end up
     * skipping over some smaller number of bytes, possibly 0. This
     * may result from any of a number of conditions; reaching end of
     * file before n bytes have been skipped is only one
     * possibility. The actual number of bytes skipped is returned. If
     * n is negative, no bytes are skipped.
     *
     * @param n the number of bytes to be skipped.
     *
     * @return the actual number of bytes skipped.
     *
     * @exception IOException
     */

    public long skip(final long n)
        throws IOException
    {
        dieIfClosed();
        if (n < 0)
        {
            return 0;
        }
        int new_offset = _current_offset + ( int ) n;

        if (new_offset < _current_offset)
        {

            // wrap around in converting a VERY large long to an int
            new_offset = _document_size;
        }
        else if (new_offset > _document_size)
        {
            new_offset = _document_size;
        }
        long rval = new_offset - _current_offset;

        _current_offset = new_offset;
        return rval;
    }

