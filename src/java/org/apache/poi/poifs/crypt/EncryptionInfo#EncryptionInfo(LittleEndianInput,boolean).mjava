    public EncryptionInfo(LittleEndianInput dis, boolean isCryptoAPI) throws IOException {
        final EncryptionMode encryptionMode;
        versionMajor = dis.readShort();
        versionMinor = dis.readShort();

        if (!isCryptoAPI
            && versionMajor == binaryRC4.versionMajor
            && versionMinor == binaryRC4.versionMinor) {
            encryptionMode = binaryRC4;
            encryptionFlags = -1;
        } else if (!isCryptoAPI
            && versionMajor == agile.versionMajor
            && versionMinor == agile.versionMinor){
            encryptionMode = agile;
            encryptionFlags = dis.readInt();
        } else if (!isCryptoAPI
            && 2 <= versionMajor && versionMajor <= 4
            && versionMinor == standard.versionMinor) {
            encryptionMode = standard;
            encryptionFlags = dis.readInt();
        } else if (isCryptoAPI
            && 2 <= versionMajor && versionMajor <= 4
            && versionMinor == cryptoAPI.versionMinor) {
            encryptionMode = cryptoAPI;
            encryptionFlags = dis.readInt();
        } else {
            encryptionFlags = dis.readInt();
            throw new EncryptedDocumentException(
                "Unknown encryption: version major: "+versionMajor+
                " / version minor: "+versionMinor+
                " / fCrypto: "+flagCryptoAPI.isSet(encryptionFlags)+
                " / fExternal: "+flagExternal.isSet(encryptionFlags)+
                " / fDocProps: "+flagDocProps.isSet(encryptionFlags)+
                " / fAES: "+flagAES.isSet(encryptionFlags));
        }
        
        EncryptionInfoBuilder eib;
        try {
            eib = getBuilder(encryptionMode);
        } catch (Exception e) {
            throw new IOException(e);
        }

        eib.initialize(this, dis);
        header = eib.getHeader();
        verifier = eib.getVerifier();
        decryptor = eib.getDecryptor();
        encryptor = eib.getEncryptor();
    }

