    /**
     * We have this method because the way in which arrays in escher works
     * is screwed for seemly arbitrary reasons.  While most properties are
     * fairly consistent and have a predictable array size, escher arrays
     * have special cases.
     *
     * @param data      The data array containing the escher array information
     * @param offset    The offset into the array to start reading from.
     * @return  the number of bytes used by this complex property.
     */
    public int setArrayData(byte[] data, int offset) {
        if (emptyComplexPart){
            resizeComplexData(0, 0);
            return 0;
        }
        
        short numElements = LittleEndian.getShort(data, offset);
        // LittleEndian.getShort(data, offset + 2); // numReserved
        short sizeOfElements = LittleEndian.getShort(data, offset + 4);

        // TODO: this part is strange - it doesn't make sense to compare
        // the size of the existing data when setting a new data array ...
        int arraySize = getArraySizeInBytes(numElements, sizeOfElements);
        if (arraySize - FIXED_SIZE == getComplexData().length) {
            // The stored data size in the simple block excludes the header size
            sizeIncludesHeaderSize = false;
        }
        int cpySize = Math.min(arraySize, data.length-offset);
        resizeComplexData(cpySize, 0);
        System.arraycopy(data, offset, getComplexData(), 0, cpySize);
        return cpySize;
    }

