    protected AttributedString getAttributedString(Graphics2D graphics, StringBuilder text){
        List<AttributedStringData> attList = new ArrayList<AttributedStringData>();
        if (text == null) text = new StringBuilder();

        PlaceableShape<?,?> ps = getParagraphShape();

        DrawFontManager fontHandler = (DrawFontManager)graphics.getRenderingHint(Drawable.FONT_HANDLER);
        @SuppressWarnings("unchecked")
        Map<String,String> fontMap = (Map<String,String>)graphics.getRenderingHint(Drawable.FONT_MAP);
        @SuppressWarnings("unchecked")
        Map<String,String> fallbackMap = (Map<String,String>)graphics.getRenderingHint(Drawable.FONT_FALLBACK);

        for (TextRun run : paragraph){
            String runText = getRenderableText(run);
            // skip empty runs
            if (runText.isEmpty()) continue;

            // user can pass an custom object to convert fonts
            String mappedFont = run.getFontFamily();
            String fallbackFont = Font.SANS_SERIF;

            if (mappedFont == null) {
                mappedFont = paragraph.getDefaultFontFamily();
            }
            if (mappedFont == null) {
                mappedFont = Font.SANS_SERIF;
            }            
            if (fontHandler != null) {
                String font = fontHandler.getRendererableFont(mappedFont, run.getPitchAndFamily());
                if (font != null) {
                    mappedFont = font;
                }
                font = fontHandler.getFallbackFont(mappedFont, run.getPitchAndFamily());
                if (font != null) {
                    fallbackFont = font;
                }
            } else {
                if (fontMap != null) {
                    if (fontMap.containsKey(mappedFont)) {
                        mappedFont = fontMap.get(mappedFont);
                    } else if (fontMap.containsKey("*")) {
                        mappedFont = fontMap.get("*");
                    }
                }
                if (fallbackMap != null) {
                    if (fallbackMap.containsKey(mappedFont)) {
                        fallbackFont = fallbackMap.get(mappedFont);
                    } else if (fallbackMap.containsKey("*")) {
                        fallbackFont = fallbackMap.get("*");
                    }
                }
            }
            
            runText = mapFontCharset(runText,mappedFont);
            int beginIndex = text.length();
            text.append(runText);
            int endIndex = text.length();

            attList.add(new AttributedStringData(TextAttribute.FAMILY, mappedFont, beginIndex, endIndex));

            PaintStyle fgPaintStyle = run.getFontColor();
            Paint fgPaint = new DrawPaint(ps).getPaint(graphics, fgPaintStyle);
            attList.add(new AttributedStringData(TextAttribute.FOREGROUND, fgPaint, beginIndex, endIndex));

            Double fontSz = run.getFontSize();
            if (fontSz == null) {
                fontSz = paragraph.getDefaultFontSize();
            }
            attList.add(new AttributedStringData(TextAttribute.SIZE, fontSz.floatValue(), beginIndex, endIndex));

            if(run.isBold()) {
                attList.add(new AttributedStringData(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD, beginIndex, endIndex));
            }
            if(run.isItalic()) {
                attList.add(new AttributedStringData(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE, beginIndex, endIndex));
            }
            if(run.isUnderlined()) {
                attList.add(new AttributedStringData(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON, beginIndex, endIndex));
                attList.add(new AttributedStringData(TextAttribute.INPUT_METHOD_UNDERLINE, TextAttribute.UNDERLINE_LOW_TWO_PIXEL, beginIndex, endIndex));
            }
            if(run.isStrikethrough()) {
                attList.add(new AttributedStringData(TextAttribute.STRIKETHROUGH, TextAttribute.STRIKETHROUGH_ON, beginIndex, endIndex));
            }
            if(run.isSubscript()) {
                attList.add(new AttributedStringData(TextAttribute.SUPERSCRIPT, TextAttribute.SUPERSCRIPT_SUB, beginIndex, endIndex));
            }
            if(run.isSuperscript()) {
                attList.add(new AttributedStringData(TextAttribute.SUPERSCRIPT, TextAttribute.SUPERSCRIPT_SUPER, beginIndex, endIndex));
            }
            
            Hyperlink<?,?> hl = run.getHyperlink();
            if (hl != null) {
                attList.add(new AttributedStringData(HYPERLINK_HREF, hl.getAddress(), beginIndex, endIndex));
                attList.add(new AttributedStringData(HYPERLINK_LABEL, hl.getLabel(), beginIndex, endIndex));
            }
            
            int style = (run.isBold() ? Font.BOLD : 0) | (run.isItalic() ? Font.ITALIC : 0);
            Font f = new Font(mappedFont, style, (int)Math.rint(fontSz));
            
            // check for unsupported characters and add a fallback font for these
            char textChr[] = runText.toCharArray();
            int nextEnd = f.canDisplayUpTo(textChr, 0, textChr.length);
            int last = nextEnd;
            boolean isNextValid = (nextEnd == 0);
            while ( nextEnd != -1 && nextEnd <= textChr.length ) {
                if (isNextValid) {
                    nextEnd = f.canDisplayUpTo(textChr, nextEnd, textChr.length);
                    isNextValid = false;
                } else {
                    if (nextEnd >= textChr.length || f.canDisplay(Character.codePointAt(textChr, nextEnd, textChr.length)) ) {
                        attList.add(new AttributedStringData(TextAttribute.FAMILY, fallbackFont, beginIndex+last, beginIndex+Math.min(nextEnd,textChr.length)));
                        if (nextEnd >= textChr.length) {
                            break;
                        }
                        last = nextEnd;
                        isNextValid = true;
                    } else {
                        boolean isHS = Character.isHighSurrogate(textChr[nextEnd]);
                        nextEnd+=(isHS?2:1);
                    }
                }
            } 
        }

        // ensure that the paragraph contains at least one character
        // We need this trick to correctly measure text
        if (text.length() == 0) {
            Double fontSz = paragraph.getDefaultFontSize();
            text.append(" ");
            attList.add(new AttributedStringData(TextAttribute.SIZE, fontSz.floatValue(), 0, 1));
        }

        AttributedString string = new AttributedString(text.toString());
        for (AttributedStringData asd : attList) {
            string.addAttribute(asd.attribute, asd.value, asd.beginIndex, asd.endIndex);
        }

        return string;
    }

