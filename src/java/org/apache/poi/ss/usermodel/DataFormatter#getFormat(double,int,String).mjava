    private Format getFormat(double cellValue, int formatIndex, String formatStrIn) {
        localeChangedObervable.checkForLocaleChange();
        
//      // Might be better to separate out the n p and z formats, falling back to p when n and z are not set.
//      // That however would require other code to be re factored.
//      String[] formatBits = formatStrIn.split(";");
//      int i = cellValue > 0.0 ? 0 : cellValue < 0.0 ? 1 : 2; 
//      String formatStr = (i < formatBits.length) ? formatBits[i] : formatBits[0];

        String formatStr = formatStrIn;
        
        // Excel supports 3+ part conditional data formats, eg positive/negative/zero,
        //  or (>1000),(>0),(0),(negative). As Java doesn't handle these kinds
        //  of different formats for different ranges, just +ve/-ve, we need to 
        //  handle these ourselves in a special way.
        // For now, if we detect 3+ parts, we call out to CellFormat to handle it
        // TODO Going forward, we should really merge the logic between the two classes
        if (formatStr.indexOf(";") != -1 && 
                formatStr.indexOf(';') != formatStr.lastIndexOf(';')) {
            try {
                // Ask CellFormat to get a formatter for it
                CellFormat cfmt = CellFormat.getInstance(formatStr);
                // CellFormat requires callers to identify date vs not, so do so
                Object cellValueO = Double.valueOf(cellValue);
                if (DateUtil.isADateFormat(formatIndex, formatStr)) {
                    cellValueO = DateUtil.getJavaDate(cellValue);
                }
                // Wrap and return (non-cachable - CellFormat does that)
                return new CellFormatResultWrapper( cfmt.apply(cellValueO) );
            } catch (Exception e) {
                logger.log(POILogger.WARN, "Formatting failed as " + formatStr + ", falling back", e);
            }
        }
        
       // Excel's # with value 0 will output empty where Java will output 0. This hack removes the # from the format.
       if (emulateCsv && cellValue == 0.0 && formatStr.contains("#") && !formatStr.contains("0")) {
           formatStr = formatStr.replaceAll("#", "");
       }
       
        // See if we already have it cached
        Format format = formats.get(formatStr);
        if (format != null) {
            return format;
        }
        
        // Is it one of the special built in types, General or @?
        if ("General".equalsIgnoreCase(formatStr) || "@".equals(formatStr)) {
            return generalNumberFormat;
        }
        
        // Build a formatter, and cache it
        format = createFormat(cellValue, formatIndex, formatStr);
        return format;
    }

