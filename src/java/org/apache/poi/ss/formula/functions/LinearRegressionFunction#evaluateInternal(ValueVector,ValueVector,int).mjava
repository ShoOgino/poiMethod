	private double evaluateInternal(ValueVector x, ValueVector y, int size)
			throws EvaluationException {

		// error handling is as if the x is fully evaluated before y
		ErrorEval firstXerr = null;
		ErrorEval firstYerr = null;
		boolean accumlatedSome = false;
		double result = 0.0;
        // first pass: read in data, compute xbar and ybar
        double sumx = 0.0, sumy = 0.0;
        
		for (int i = 0; i < size; i++) {
			ValueEval vx = x.getItem(i);
			ValueEval vy = y.getItem(i);
			if (vx instanceof ErrorEval) {
				if (firstXerr == null) {
					firstXerr = (ErrorEval) vx;
					continue;
				}
			}
			if (vy instanceof ErrorEval) {
				if (firstYerr == null) {
					firstYerr = (ErrorEval) vy;
					continue;
				}
			}
			// only count pairs if both elements are numbers
			if (vx instanceof NumberEval && vy instanceof NumberEval) {
				accumlatedSome = true;
				NumberEval nx = (NumberEval) vx;
				NumberEval ny = (NumberEval) vy;
				sumx  += nx.getNumberValue();
	            sumy  += ny.getNumberValue();
			} else {
				// all other combinations of value types are silently ignored
			}
		}
		double xbar = sumx / size;
        double ybar = sumy / size;
		
		 // second pass: compute summary statistics
        double xxbar = 0.0, xybar = 0.0;
        for (int i = 0; i < size; i++) {
			ValueEval vx = x.getItem(i);
			ValueEval vy = y.getItem(i);
			
			if (vx instanceof ErrorEval) {
				if (firstXerr == null) {
					firstXerr = (ErrorEval) vx;
					continue;
				}
			}
			if (vy instanceof ErrorEval) {
				if (firstYerr == null) {
					firstYerr = (ErrorEval) vy;
					continue;
				}
			}
			
			// only count pairs if both elements are numbers
			if (vx instanceof NumberEval && vy instanceof NumberEval) {
				NumberEval nx = (NumberEval) vx;
				NumberEval ny = (NumberEval) vy;
	            xxbar += (nx.getNumberValue() - xbar) * (nx.getNumberValue() - xbar);
	            xybar += (nx.getNumberValue() - xbar) * (ny.getNumberValue() - ybar);
			} else {
				// all other combinations of value types are silently ignored
			}
        }
        double beta1 = xybar / xxbar;
        double beta0 = ybar - beta1 * xbar;
		
		if (firstXerr != null) {
			throw new EvaluationException(firstXerr);
		}
		if (firstYerr != null) {
			throw new EvaluationException(firstYerr);
		}
		if (!accumlatedSome) {
			throw new EvaluationException(ErrorEval.DIV_ZERO);
		}
		
		if(function == FUNCTION.INTERCEPT) {
			return beta0;
		} else {
			return beta1;
		}
	}

