	/**
	 * Notifies this evaluation tracker that the evaluation of the specified
	 * cell is complete. <p/>
	 * 
	 * Every successful call to <tt>startEvaluate</tt> must be followed by a
	 * call to <tt>endEvaluate</tt> (recommended in a finally block) to enable
	 * proper tracking of which cells are being evaluated at any point in time.<p/>
	 * 
	 * Assuming a well behaved client, parameters to this method would not be
	 * required. However, they have been included to assert correct behaviour,
	 * and form more meaningful error messages.
	 * @param result 
	 */
	public void endEvaluate(CellLocation cellLoc, ValueEval result, boolean isPlainValueCell) {

		int nFrames = _evaluationFrames.size();
		if (nFrames < 1) {
			throw new IllegalStateException("Call to endEvaluate without matching call to startEvaluate");
		}

		nFrames--;
		CellEvaluationFrame frame = (CellEvaluationFrame) _evaluationFrames.get(nFrames);
		CellLocation coordinates = frame.getCoordinates();
		if (!coordinates.equals(cellLoc)) {
			throw new RuntimeException("Wrong cell specified. "
					+ "Corresponding startEvaluate() call was for cell {"
					+ coordinates.formatAsString() + "} this endEvaluate() call is for cell {"
					+ cellLoc.formatAsString() + "}");
		}
		// else - no problems so pop current frame 
		_evaluationFrames.remove(nFrames);
		_currentlyEvaluatingCells.remove(coordinates);

		// TODO - don't cache results of volatile formulas 
		_cache.setValue(coordinates, isPlainValueCell, frame.getUsedCells(), result);
	}

