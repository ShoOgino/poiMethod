	/**
	 * @param startRowIndex row index in the spreadsheet where the first function/operator is found
	 * @param testFocusFunctionName name of a single function/operator to test alone.
	 * Typically pass <code>null</code> to test all functions
	 */
	private void processFunctionGroup(int startRowIndex, String testFocusFunctionName) {
		HSSFFormulaEvaluator evaluator = new HSSFFormulaEvaluator(workbook);
        Collection<String> funcs = FunctionEval.getSupportedFunctionNames();

		int rowIndex = startRowIndex;
		while (true) {
			Row r = sheet.getRow(rowIndex);
			
			// only evaluate non empty row
			if( r != null )
			{
				String targetFunctionName = getTargetFunctionName(r);
				String targetTestName = getTargetTestName(r);
				if(targetFunctionName == null) {
					throw new AssertionFailedError("Test spreadsheet cell empty on row ("
							+ (rowIndex+1) + "). Expected function name or '"
							+ SS.FUNCTION_NAMES_END_SENTINEL + "'");
				}
				if(targetFunctionName.equals(SS.FUNCTION_NAMES_END_SENTINEL)) {
					// found end of functions list
					break;
				}
				if(testFocusFunctionName == null || targetFunctionName.equalsIgnoreCase(testFocusFunctionName)) {

					// expected results are on the row below
					Cell expectedValueCell = r.getCell(SS.COLUMN_INDEX_EXPECTED_VALUE);
					if(expectedValueCell == null) {
						int missingRowNum = rowIndex + 1;
						throw new AssertionFailedError("Missing expected values cell for function '"
								+ targetFunctionName + ", test" + targetTestName + " (row " + 
								missingRowNum + ")");
					}
					
					switch(processFunctionRow(evaluator, targetFunctionName, targetTestName, r, expectedValueCell)) {
						case Result.ALL_EVALUATIONS_SUCCEEDED: _functionSuccessCount++; break;
						case Result.SOME_EVALUATIONS_FAILED: _functionFailureCount++; break;
						default:
							throw new RuntimeException("unexpected result");
						case Result.NO_EVALUATIONS_FOUND: // do nothing
							String uname = targetFunctionName.toUpperCase();
							if(startRowIndex >= SS.START_FUNCTIONS_ROW_INDEX &&
									funcs.contains(uname)) {
								logger.log(POILogger.WARN, uname + ": function is supported but missing test data");
							}
							break;
					}
				}
			}
			rowIndex ++;
		}
	}

