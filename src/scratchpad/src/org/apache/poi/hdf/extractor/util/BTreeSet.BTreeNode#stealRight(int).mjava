        /*
         * This method is called only when stealLeft can't be called, the BTreeNode
         * has the minimum number of elements, has a rightSibling, and the rightSibling
         * has more than the minimum number of elements.
        */
        private void stealRight(int parentIndex) {
            BTreeNode p = _parent;
            BTreeNode rs = p._entries[parentIndex + 1].child;

            if (isLeaf()) { // When stealing from leaf to leaf don't worry about children
                _entries[_nrElements] = new Entry();
                _entries[_nrElements].element = p._entries[parentIndex].element;
                p._entries[parentIndex].element = rs._entries[0].element;
                for (int i = 0; i < rs._nrElements; i++) rs._entries[i] = rs._entries[i + 1];
                rs._entries[rs._nrElements - 1] = null;
                _nrElements++;
                rs._nrElements--;
            }

            else { // Was called recursively to fix an undermanned parent
                for (int i = 0; i <= _nrElements; i++) _entries[i] = _entries[i + 1];
                _entries[_nrElements].element = p._entries[parentIndex].element;
                p._entries[parentIndex].element = rs._entries[0].element;
                _entries[_nrElements + 1] = new Entry();
                _entries[_nrElements + 1].child = rs._entries[0].child;
                _entries[_nrElements + 1].child._parent = this;
                for (int i = 0; i <= rs._nrElements; i++) rs._entries[i] = rs._entries[i + 1];
                rs._entries[rs._nrElements] = null;
                _nrElements++;
                rs._nrElements--;
            }
        }

