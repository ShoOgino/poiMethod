        /*
         * This method is called only when the BTreeNode has the minimum number of elements,
         * has a leftSibling, and the leftSibling has more than the minimum number of elements.
        */
        private void stealLeft(int parentIndex) {
            BTreeNode p = _parent;
            BTreeNode ls = _parent._entries[parentIndex - 1].child;

            if (isLeaf()) { // When stealing from leaf to leaf don't worry about children
                int add = childToInsertAt(p._entries[parentIndex - 1].element, true);
                insertNewElement(p._entries[parentIndex - 1].element, add);
                p._entries[parentIndex - 1].element = ls._entries[ls._nrElements - 1].element;
                ls._entries[ls._nrElements - 1] = null;
                ls._nrElements--;
            }

            else { // Was called recursively to fix an undermanned parent
                _entries[0].element = p._entries[parentIndex - 1].element;
                p._entries[parentIndex - 1].element = ls._entries[ls._nrElements - 1].element;
                _entries[0].child = ls._entries[ls._nrElements].child;
                _entries[0].child._parent = this;
                ls._entries[ls._nrElements] = null;
                ls._entries[ls._nrElements - 1].element = null;
                _nrElements++;
                ls._nrElements--;
            }
        }

