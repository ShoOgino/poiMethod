  static void doPAPOperation(PAP newPAP, int operand, int param,
                             byte[] varParam, byte[] grpprl, int offset,
                             int spra)
  {
      switch(operand)
      {
          case 0:
               newPAP._istd = param;
               break;
          case 0x1:
               //permuteIstd(newPAP, varParam);
               break;
          case 0x2:
               if(newPAP._istd <=9 || newPAP._istd >=1)
               {
                  newPAP._istd += param;
                  if(param > 0)
                  {
                      newPAP._istd = Math.max(newPAP._istd, 9);
                  }
                  else
                  {
                      newPAP._istd = Math.min(newPAP._istd, 1);
                  }
               }
               break;
          case 0x3:
               newPAP._jc = (byte)param;
               break;
          case 0x4:
               newPAP._fSideBySide = (byte)param;
               break;
          case 0x5:
               newPAP._fKeep = (byte)param;
               break;
          case 0x6:
               newPAP._fKeepFollow = (byte)param;
               break;
          case 0x7:
               newPAP._fPageBreakBefore = (byte)param;
               break;
          case 0x8:
               newPAP._brcl = (byte)param;
               break;
          case 0x9:
               newPAP._brcp = (byte)param;
               break;
          case 0xa:
               newPAP._ilvl = (byte)param;
               break;
          case 0xb:
               newPAP._ilfo = param;
               break;
          case 0xc:
               newPAP._fNoLnn = (byte)param;
               break;
          case 0xd:
               /**@todo handle tabs*/
               break;
          case 0xe:
               newPAP._dxaRight = param;
               break;
          case 0xf:
               newPAP._dxaLeft = param;
               break;
          case 0x10:
               newPAP._dxaLeft += param;
               newPAP._dxaLeft = Math.max(0, newPAP._dxaLeft);
               break;
          case 0x11:
               newPAP._dxaLeft1 = param;
               break;
          case 0x12:
               newPAP._lspd[0] = Utils.convertBytesToShort(grpprl, offset - 4);
               newPAP._lspd[1] = Utils.convertBytesToShort(grpprl, offset - 2);
               break;
          case 0x13:
               newPAP._dyaBefore = param;
               break;
          case 0x14:
               newPAP._dyaAfter = param;
               break;
          case 0x15:
               /**@todo handle tabs*/
               break;
          case 0x16:
               newPAP._fInTable = (byte)param;
               break;
          case 0x17:
               newPAP._fTtp =(byte)param;
               break;
          case 0x18:
               newPAP._dxaAbs = param;
               break;
          case 0x19:
               newPAP._dyaAbs = param;
               break;
          case 0x1a:
               newPAP._dxaWidth = param;
               break;
          case 0x1b:
               /** @todo handle paragraph postioning*/
               /*byte pcVert = (param & 0x0c) >> 2;
               byte pcHorz = param & 0x03;
               if(pcVert != 3)
               {
                  newPAP._pcVert = pcVert;
               }
               if(pcHorz != 3)
               {
                  newPAP._pcHorz = pcHorz;
               }*/
               break;
          case 0x1c:
               newPAP._brcTop1 = (short)param;
               break;
          case 0x1d:
               newPAP._brcLeft1 = (short)param;
               break;
          case 0x1e:
               newPAP._brcBottom1 = (short)param;
               break;
          case 0x1f:
               newPAP._brcRight1 = (short)param;
               break;
          case 0x20:
               newPAP._brcBetween1 = (short)param;
               break;
          case 0x21:
               newPAP._brcBar1 = (byte)param;
               break;
          case 0x22:
               newPAP._dxaFromText = param;
               break;
          case 0x23:
               newPAP._wr = (byte)param;
               break;
          case 0x24:
               newPAP._brcTop[0] = (short)Utils.convertBytesToShort(grpprl, offset - 4);
               newPAP._brcTop[1] = (short)Utils.convertBytesToShort(grpprl, offset - 2);
               break;
          case 0x25:
               newPAP._brcLeft[0] = (short)Utils.convertBytesToShort(grpprl, offset - 4);
               newPAP._brcLeft[1] = (short)Utils.convertBytesToShort(grpprl, offset - 2);
               break;
          case 0x26:
               newPAP._brcBottom[0] = (short)Utils.convertBytesToShort(grpprl, offset - 4);
               newPAP._brcBottom[1] = (short)Utils.convertBytesToShort(grpprl, offset - 2);
               break;
          case 0x27:
               newPAP._brcRight[0] = (short)Utils.convertBytesToShort(grpprl, offset - 4);
               newPAP._brcRight[1] = (short)Utils.convertBytesToShort(grpprl, offset - 2);
               break;
          case 0x28:
               newPAP._brcBetween[0] = (short)Utils.convertBytesToShort(grpprl, offset - 4);
               newPAP._brcBetween[1] = (short)Utils.convertBytesToShort(grpprl, offset - 2);
               break;
          case 0x29:
               newPAP._brcBar[0] = (short)Utils.convertBytesToShort(grpprl, offset - 4);
               newPAP._brcBar[1] = (short)Utils.convertBytesToShort(grpprl, offset - 2);
               break;
          case 0x2a:
               newPAP._fNoAutoHyph = (byte)param;
               break;
          case 0x2b:
               newPAP._dyaHeight = param;
               break;
          case 0x2c:
               newPAP._dcs = param;
               break;
          case 0x2d:
               newPAP._shd = param;
               break;
          case 0x2e:
               newPAP._dyaFromText = param;
               break;
          case 0x2f:
               newPAP._dxaFromText = param;
               break;
          case 0x30:
               newPAP._fLocked = (byte)param;
               break;
          case 0x31:
               newPAP._fWindowControl = (byte)param;
               break;
          case 0x32:
               //undocumented
               break;
          case 0x33:
               newPAP._fKinsoku = (byte)param;
               break;
          case 0x34:
               newPAP._fWordWrap = (byte)param;
               break;
          case 0x35:
               newPAP._fOverflowPunct = (byte)param;
               break;
          case 0x36:
               newPAP._fTopLinePunct = (byte)param;
               break;
          case 0x37:
               newPAP._fAutoSpaceDE = (byte)param;
               break;
          case 0x38:
               newPAP._fAutoSpaceDN = (byte)param;
               break;
          case 0x39:
               newPAP._wAlignFont = param;
               break;
          case 0x3a:
               newPAP._fontAlign = (short)param;
               break;
          case 0x3b:
               //obsolete
               break;
          case 0x3e:
               newPAP._anld = varParam;
               break;
          case 0x3f:
               //don't really need this. spec is confusing regarding this
               //sprm
               break;
          case 0x40:
               //newPAP._lvl = param;
               break;
          case 0x41:
               //?
               break;
          case 0x43:
               //?
              break;
          case 0x44:
               //?
               break;
          case 0x45:
               if(spra == 6)
               {
                  newPAP._numrm = varParam;
               }
               else
               {
                  /**@todo handle large PAPX from data stream*/
               }
               break;

          case 0x47:
               newPAP._fUsePgsuSettings = (byte)param;
               break;
          case 0x48:
               newPAP._fAdjustRight = (byte)param;
               break;
          default:
               break;
      }
  }

