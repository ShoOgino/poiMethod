        /*
         * This method is called only when stealLeft, stealRight, and mergeLeft could not be called,
         * the BTreeNode has the minimum number of elements, has a rightSibling, and the
         * rightSibling has more than the minimum number of elements.  If after completion
         * parent has fewer than the minimum number of elements than the parents entries[0]
         * slot is left empty in anticipation of a recursive call to stealLeft, stealRight,
         * mergeLeft, or mergeRight to fix the parent. All of the before-mentioned methods
         * expect the parent to be in such a condition.
        */
        private void mergeRight(int parentIndex) {
            BTreeNode p = _parent;
            BTreeNode rs = p._entries[parentIndex + 1].child;

            if (isLeaf()) { // Don't worry about children
                _entries[_nrElements] = new Entry();
                _entries[_nrElements].element = p._entries[parentIndex].element;
                _nrElements++;
                for (int i = 0, nr = _nrElements; i < rs._nrElements; i++, nr++) {
                    _entries[nr] = rs._entries[i];
                    _nrElements++;
                }
                p._entries[parentIndex].element = p._entries[parentIndex + 1].element;
                if (p._nrElements == MIN && p != BTreeSet.this.root) {
                    for (int x = parentIndex + 1, y = parentIndex; y >= 0; x--, y--)
                        p._entries[x] = p._entries[y];
                    p._entries[0] = new Entry();
                    p._entries[0].child = rs; // So it doesn't think it's a leaf, this child will be deleted in the next recursive call
                }

                else {
                    for (int x = parentIndex + 1, y = parentIndex + 2; y <= p._nrElements; x++, y++)
                        p._entries[x] = p._entries[y];
                    p._entries[p._nrElements] = null;
                }

                p._nrElements--;
                if (p.isRoot() && p._nrElements == 0) { // It's the root and it's empty
                    BTreeSet.this.root = this;
                    _parent = null;
                }
           }

           else { // It's not a leaf

               _entries[_nrElements].element = p._entries[parentIndex].element;
               _nrElements++;

               for (int x = _nrElements + 1, y = 0; y <= rs._nrElements; x++, y++) {
                   _entries[x] = rs._entries[y];
                   rs._entries[y].child._parent = this;
                   _nrElements++;
               }
               _nrElements--;

               p._entries[++parentIndex].child = this;

               if (p._nrElements == MIN && p != BTreeSet.this.root) {
                  for (int x = parentIndex - 1, y = parentIndex - 2; y >= 0; x--, y--)
                      p._entries[x] = p._entries[y];
                  p._entries[0] = new Entry();
               }

               else {
                   for (int x = parentIndex - 1, y = parentIndex; y <= p._nrElements; x++, y++)
                       p._entries[x] = p._entries[y];
                   p._entries[p._nrElements] = null;
               }

               p._nrElements--;

               if (p.isRoot() && p._nrElements == 0) { // It's the root and it's empty
                   BTreeSet.this.root = this;
                   _parent = null;
               }
            }
        }

