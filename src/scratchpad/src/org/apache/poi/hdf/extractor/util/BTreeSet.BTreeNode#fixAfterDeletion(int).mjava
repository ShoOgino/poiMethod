        private void fixAfterDeletion(int parentIndex) {
            if (isRoot() || _parent.isRoot()) return; // No fixing needed

            if (_parent._nrElements < MIN) { // If parent lost it's n/2 element repair it
                BTreeNode temp = _parent;
                temp.prepareForDeletion(parentIndex);
                if (temp._parent == null) return; // Root changed
                if (!temp._parent.isRoot() && temp._parent._nrElements < MIN) { // If need be recurse
                    BTreeNode x = temp._parent._parent;
                    int i = 0;
                    // Find parent's parentIndex
                    for (; i < _entries.length; i++) if (x._entries[i].child == temp._parent) break;
                    temp._parent.fixAfterDeletion(i);
                }
            }
        }

