        /*
         * This method is called only when stealLeft and stealRight could not be called,
         * the BTreeNode has the minimum number of elements, has a leftSibling, and the
         * leftSibling has more than the minimum number of elements.  If after completion
         * parent has fewer than the minimum number of elements than the parents entries[0]
         * slot is left empty in anticipation of a recursive call to stealLeft, stealRight,
         * mergeLeft, or mergeRight to fix the parent. All of the before-mentioned methods
         * expect the parent to be in such a condition.
        */
        private void mergeLeft(int parentIndex) {
            BTreeNode p = _parent;
            BTreeNode ls = p._entries[parentIndex - 1].child;

            if (isLeaf()) { // Don't worry about children
                int add = childToInsertAt(p._entries[parentIndex - 1].element, true);
                insertNewElement(p._entries[parentIndex - 1].element, add); // Could have been a successor switch
                p._entries[parentIndex - 1].element = null;

                for (int i = _nrElements - 1, nr = ls._nrElements; i >= 0; i--)
                    _entries[i + nr] = _entries[i];

                for (int i = ls._nrElements - 1; i >= 0; i--) {
                    _entries[i] = ls._entries[i];
                    _nrElements++;
                }

                if (p._nrElements == MIN && p != BTreeSet.this.root) {

                    for (int x = parentIndex - 1, y = parentIndex - 2; y >= 0; x--, y--)
                        p._entries[x] = p._entries[y];
                    p._entries[0] = new Entry();
                    p._entries[0].child = ls; //So p doesn't think it's a leaf this will be deleted in the next recursive call
                }

                else {

                    for (int x = parentIndex - 1, y = parentIndex; y <= p._nrElements; x++, y++)
                        p._entries[x] = p._entries[y];
                    p._entries[p._nrElements] = null;
                }

                p._nrElements--;

                if (p.isRoot() && p._nrElements == 0) { // It's the root and it's empty
                    BTreeSet.this.root = this;
                    _parent = null;
                }
            }

            else { // I'm not a leaf but fixing the tree structure
                _entries[0].element = p._entries[parentIndex - 1].element;
                _entries[0].child = ls._entries[ls._nrElements].child;
                _nrElements++;

                for (int x = _nrElements, nr = ls._nrElements; x >= 0; x--)
                    _entries[x + nr] = _entries[x];

                for (int x = ls._nrElements - 1; x >= 0; x--) {
                    _entries[x] = ls._entries[x];
                    _entries[x].child._parent = this;
                    _nrElements++;
                }

                if (p._nrElements == MIN && p != BTreeSet.this.root) { // Push everything to the right
                    for (int x = parentIndex - 1, y = parentIndex - 2; y >= 0; x++, y++){
                        System.out.println(x + " " + y);
                        p._entries[x] = p._entries[y];}
                    p._entries[0] = new Entry();
                }

                else { // Either p.nrElements > MIN or p == BTreeSet.this.root so push everything to the left
                    for (int x = parentIndex - 1, y = parentIndex; y <= p._nrElements; x++, y++)
                        p._entries[x] = p._entries[y];
                    p._entries[p._nrElements] = null;
                }

                p._nrElements--;

                if (p.isRoot() && p._nrElements == 0) { // p == BTreeSet.this.root and it's empty
                    BTreeSet.this.root = this;
                    _parent = null;
                }
            }
        }

