//  /**
//   * Used to uncompress a property stored in a grpprl. These include
//   * CharacterProperties, ParagraphProperties, TableProperties, and
//   * SectionProperties.
//   *
//   * @param grpprl The compressed form of the property.
//   * @param parent The base property of the property.
//   * @param styleSheet The document's stylesheet.
//   *
//   * @return An object that should be casted to the appropriate property.
//   */
//  public static Object uncompressProperty(byte[] grpprl, Object parent, StyleSheet styleSheet, boolean doIstd)
//  {
//      Object newProperty = null;
//      int offset = 0;
//      int propertyType = PAP_TYPE;
//
//
//      if(parent instanceof ParagraphProperties)
//      {
//          try
//          {
//              newProperty = ((ParagraphProperties)parent).clone();
//          }
//          catch(Exception e){}
//          if(doIstd)
//          {
//            ((ParagraphProperties)newProperty).setIstd(LittleEndian.getShort(grpprl, 0));
//
//            offset = 2;
//          }
//      }
//      else if(parent instanceof CharacterProperties)
//      {
//          try
//          {
//              newProperty = ((CharacterProperties)parent).clone();
//              ((CharacterProperties)newProperty).setBaseIstd(((CharacterProperties)parent).getIstd());
//          }
//          catch(Exception e){}
//          propertyType = CHP_TYPE;
//      }
//      else if(parent instanceof SectionProperties)
//      {
//          newProperty = parent;
//          propertyType = SEP_TYPE;
//      }
//      else if(parent instanceof TableProperties)
//      {
//          newProperty = parent;
//          propertyType = TAP_TYPE;
//          offset = 2;//because this is really just a papx
//      }
//      else
//      {
//          return null;
//      }
//
//      while(offset < grpprl.length)
//      {
//          short sprm = LittleEndian.getShort(grpprl, offset);
//          offset += 2;
//
//          byte spra = (byte)((sprm & 0xe000) >> 13);
//          int opSize = 0;
//          int param = 0;
//          byte[] varParam = null;
//
//          switch(spra)
//          {
//              case 0:
//              case 1:
//                   opSize = 1;
//                   param = grpprl[offset];
//                   break;
//              case 2:
//                   opSize = 2;
//                   param = LittleEndian.getShort(grpprl, offset);
//                   break;
//              case 3:
//                   opSize = 4;
//                   param = LittleEndian.getInt(grpprl, offset);
//                   break;
//              case 4:
//              case 5:
//                   opSize = 2;
//                   param = LittleEndian.getShort(grpprl, offset);
//                   break;
//              case 6://variable size
//
//                   //there is one sprm that is a very special case
//                   if(sprm != (short)0xd608)
//                   {
//                     opSize = LittleEndian.getUnsignedByte(grpprl, offset);
//                     offset++;
//                   }
//                   else
//                   {
//                     opSize = LittleEndian.getShort(grpprl, offset) - 1;
//                     offset += 2;
//                   }
//                   varParam = new byte[opSize];
//                   System.arraycopy(grpprl, offset, varParam, 0, opSize);
//
//                   break;
//              case 7:
//                   opSize = 3;
//                   byte threeByteInt[] = new byte[4];
//                   threeByteInt[0] = grpprl[offset];
//                   threeByteInt[1] = grpprl[offset + 1];
//                   threeByteInt[2] = grpprl[offset + 2];
//                   threeByteInt[3] = (byte)0;
//                   param = LittleEndian.getInt(threeByteInt, 0);
//                   break;
//              default:
//                  throw new RuntimeException("unrecognized pap opcode");
//          }
//
//          offset += opSize;
//          short operand = (short)(sprm & 0x1ff);
//          byte type = (byte)((sprm & 0x1c00) >> 10);
//          switch(propertyType)
//          {
//              case PAP_TYPE:
//                   if(type == 1)//papx stores TAP sprms along with PAP sprms
//                   {
//                     doPAPOperation((ParagraphProperties)newProperty, operand,
//                                    param, varParam, grpprl,
//                                    offset, spra);
//                   }
//                   break;
//              case CHP_TYPE:
//
//                   doCHPOperation((CharacterProperties)parent,
//                                  (CharacterProperties)newProperty,
//                                  operand, param, varParam,
//                                  grpprl, offset, styleSheet);
//                   break;
//              case SEP_TYPE:
//
//                   doSEPOperation((SectionProperties)newProperty, operand, param, varParam);
//                   break;
//              case TAP_TYPE:
//                   if(type == 5)
//                   {
//                     doTAPOperation((TableProperties)newProperty, operand, param, varParam);
//                   }
//                   break;
//          }
//
//
//      }
//      return newProperty;
//
//  }
//  /**
//   * Performs an operation on a ParagraphProperties object. Used to uncompress
//   * from a papx.
//   *
//   * @param newPAP The ParagraphProperties object to perform the operation on.
//   * @param operand The operand that defines the operation.
//   * @param param The operation's parameter.
//   * @param varParam The operation's variable length parameter.
//   * @param grpprl The original papx.
//   * @param offset The current offset in the papx.
//   * @param spra A part of the sprm that defined this operation.
//   */
//  static void doPAPOperation(ParagraphProperties newPAP, int operand, int param,
//                             byte[] varParam, byte[] grpprl, int offset,
//                             int spra)
//  {
//      switch(operand)
//      {
//          case 0:
//               newPAP.setIstd(param);
//               break;
//          case 0x1:
//               //permuteIstd(newPAP, varParam);
//               break;
//          case 0x2:
//               if(newPAP.getIstd() <=9 || newPAP.getIstd() >=1)
//               {
//                  newPAP.setIstd(newPAP.getIstd() + param);
//                  if(param > 0)
//                  {
//                      newPAP.setIstd(Math.max(newPAP.getIstd(), 9));
//                  }
//                  else
//                  {
//                      newPAP.setIstd(Math.min(newPAP.getIstd(), 1));
//                  }
//               }
//               break;
//          case 0x3:
//               newPAP.setJc((byte)param);
//               break;
//          case 0x4:
//               newPAP.setFSideBySide((byte)param);
//               break;
//          case 0x5:
//               newPAP.setFKeep((byte)param);
//               break;
//          case 0x6:
//               newPAP.setFKeepFollow((byte)param);
//               break;
//          case 0x7:
//               newPAP.setFPageBreakBefore((byte)param);
//               break;
//          case 0x8:
//               newPAP.setBrcl((byte)param);
//               break;
//          case 0x9:
//               newPAP.setBrcp((byte)param);
//               break;
//          case 0xa:
//               newPAP.setIlvl((byte)param);
//               break;
//          case 0xb:
//               newPAP.setIlfo(param);
//               break;
//          case 0xc:
//               newPAP.setFNoLnn((byte)param);
//               break;
//          case 0xd:
//               /**@todo handle tabs*/
//               break;
//          case 0xe:
//               newPAP.setDxaRight(param);
//               break;
//          case 0xf:
//               newPAP.setDxaLeft(param);
//               break;
//          case 0x10:
//               newPAP.setDxaLeft(newPAP.getDxaLeft() + param);
//               newPAP.setDxaLeft(Math.max(0, newPAP.getDxaLeft()));
//               break;
//          case 0x11:
//               newPAP.setDxaLeft1(param);
//               break;
//          case 0x12:
//               short[] lspd = newPAP.getLspd();
//               lspd[0] = LittleEndian.getShort(grpprl, offset - 4);
//               lspd[1] = LittleEndian.getShort(grpprl, offset - 2);
//               break;
//          case 0x13:
//               newPAP.setDyaBefore(param);
//               break;
//          case 0x14:
//               newPAP.setDyaAfter(param);
//               break;
//          case 0x15:
//               /**@todo handle tabs*/
//               break;
//          case 0x16:
//               newPAP.setFInTable((byte)param);
//               break;
//          case 0x17:
//               newPAP.setFTtp((byte)param);
//               break;
//          case 0x18:
//               newPAP.setDxaAbs(param);
//               break;
//          case 0x19:
//               newPAP.setDyaAbs(param);
//               break;
//          case 0x1a:
//               newPAP.setDxaWidth(param);
//               break;
//          case 0x1b:
//               /** @todo handle paragraph postioning*/
//               /*byte pcVert = (param & 0x0c) >> 2;
//               byte pcHorz = param & 0x03;
//               if(pcVert != 3)
//               {
//                  newPAP._pcVert = pcVert;
//               }
//               if(pcHorz != 3)
//               {
//                  newPAP._pcHorz = pcHorz;
//               }*/
//               break;
//          case 0x1c:
//               //newPAP.setBrcTop1((short)param);
//               break;
//          case 0x1d:
//               //newPAP.setBrcLeft1((short)param);
//               break;
//          case 0x1e:
//               //newPAP.setBrcBottom1((short)param);
//               break;
//          case 0x1f:
//               //newPAP.setBrcRight1((short)param);
//               break;
//          case 0x20:
//               //newPAP.setBrcBetween1((short)param);
//               break;
//          case 0x21:
//               //newPAP.setBrcBar1((byte)param);
//               break;
//          case 0x22:
//               newPAP.setDxaFromText(param);
//               break;
//          case 0x23:
//               newPAP.setWr((byte)param);
//               break;
//          case 0x24:
//               short[] brcTop = newPAP.getBrcTop();
//               brcTop[0] = (short)LittleEndian.getShort(grpprl, offset - 4);
//               brcTop[1] = (short)LittleEndian.getShort(grpprl, offset - 2);
//               break;
//          case 0x25:
//               short[] brcLeft = newPAP.getBrcLeft();
//               brcLeft[0] = (short)LittleEndian.getShort(grpprl, offset - 4);
//               brcLeft[1] = (short)LittleEndian.getShort(grpprl, offset - 2);
//               break;
//          case 0x26:
//               short[] brcBottom = newPAP.getBrcBottom();
//               brcBottom[0] = (short)LittleEndian.getShort(grpprl, offset - 4);
//               brcBottom[1] = (short)LittleEndian.getShort(grpprl, offset - 2);
//               break;
//          case 0x27:
//               short[] brcRight = newPAP.getBrcRight();
//               brcRight[0] = (short)LittleEndian.getShort(grpprl, offset - 4);
//               brcRight[1] = (short)LittleEndian.getShort(grpprl, offset - 2);
//               break;
//          case 0x28:
//               short[] brcBetween = newPAP.getBrcBetween();
//               brcBetween[0] = (short)LittleEndian.getShort(grpprl, offset - 4);
//               brcBetween[1] = (short)LittleEndian.getShort(grpprl, offset - 2);
//               break;
//          case 0x29:
//               short[] brcBar = newPAP.getBrcBar();
//               brcBar[0] = (short)LittleEndian.getShort(grpprl, offset - 4);
//               brcBar[1] = (short)LittleEndian.getShort(grpprl, offset - 2);
//               break;
//          case 0x2a:
//               newPAP.setFNoAutoHyph((byte)param);
//               break;
//          case 0x2b:
//               newPAP.setDyaHeight(param);
//               break;
//          case 0x2c:
//               newPAP.setDcs((short)param);
//               break;
//          case 0x2d:
//               newPAP.setShd((short)param);
//               break;
//          case 0x2e:
//               newPAP.setDyaFromText(param);
//               break;
//          case 0x2f:
//               newPAP.setDxaFromText(param);
//               break;
//          case 0x30:
//               newPAP.setFLocked((byte)param);
//               break;
//          case 0x31:
//               newPAP.setFWidowControl((byte)param);
//               break;
//          case 0x32:
//               //undocumented
//               break;
//          case 0x33:
//               newPAP.setFKinsoku((byte)param);
//               break;
//          case 0x34:
//               newPAP.setFWordWrap((byte)param);
//               break;
//          case 0x35:
//               newPAP.setFOverflowPunct((byte)param);
//               break;
//          case 0x36:
//               newPAP.setFTopLinePunct((byte)param);
//               break;
//          case 0x37:
//               newPAP.setFAutoSpaceDE((byte)param);
//               break;
//          case 0x38:
//               newPAP.setFAutoSpaceDN((byte)param);
//               break;
//          case 0x39:
//               newPAP.setWAlignFont(param);
//               break;
//          case 0x3a:
//               newPAP.setFontAlign((short)param);
//               break;
//          case 0x3b:
//               //obsolete
//               break;
//          case 0x3e:
//               newPAP.setAnld(varParam);
//               break;
//          case 0x3f:
//               //don't really need this. spec is confusing regarding this
//               //sprm
//               break;
//          case 0x40:
//               //newPAP._lvl = param;
//               break;
//          case 0x41:
//               //?
//               break;
//          case 0x43:
//               //?
//              break;
//          case 0x44:
//               //?
//               break;
//          case 0x45:
//               if(spra == 6)
//               {
//                  newPAP.setNumrm(varParam);
//               }
//               else
//               {
//                  /**@todo handle large PAPX from data stream*/
//               }
//               break;
//
//          case 0x47:
//               newPAP.setFUsePgsuSettings((byte)param);
//               break;
//          case 0x48:
//               newPAP.setFAdjustRight((byte)param);
//               break;
//          default:
//               break;
//      }
//  }
//  /**
//   * Used to uncompress a table property. Performs an operation defined
//   * by a sprm stored in a tapx.
//   *
//   * @param newTAP The TableProperties object to perform the operation on.
//   * @param operand The operand that defines this operation.
//   * @param param The parameter for this operation.
//   * @param varParam Variable length parameter for this operation.
//   */
//  static void doTAPOperation(TableProperties newTAP, int operand, int param, byte[] varParam)
//  {
//      switch(operand)
//      {
//          case 0:
//               newTAP.setJc((short)param);
//               break;
//          case 0x01:
//          {
//               short[] rgdxaCenter = newTAP.getRgdxaCenter();
//               short itcMac = newTAP.getItcMac();
//               int adjust = param - (rgdxaCenter[0] + newTAP.getDxaGapHalf());
//               for(int x = 0; x < itcMac; x++)
//               {
//                  rgdxaCenter[x] += adjust;
//               }
//               break;
//          }
//          case 0x02:
//          {
//               short[] rgdxaCenter = newTAP.getRgdxaCenter();
//               if(rgdxaCenter != null)
//               {
//                 int adjust = newTAP.getDxaGapHalf() - param;
//                 rgdxaCenter[0] += adjust;
//               }
//               newTAP.setDxaGapHalf(param);
//               break;
//          }
//          case 0x03:
//               newTAP.setFCantSplit(getFlag(param));
//               break;
//          case 0x04:
//               newTAP.setFTableHeader(getFlag(param));
//               break;
//          case 0x05:
//          {
//               short[] brcTop = newTAP.getBrcTop();
//               short[] brcLeft = newTAP.getBrcLeft();
//               short[] brcBottom = newTAP.getBrcBottom();
//               short[] brcRight = newTAP.getBrcRight();
//               short[] brcVertical = newTAP.getBrcVertical();
//               short[] brcHorizontal = newTAP.getBrcHorizontal();
//
//               brcTop[0] = LittleEndian.getShort(varParam, 0);
//               brcTop[1] = LittleEndian.getShort(varParam, 2);
//
//               brcLeft[0] = LittleEndian.getShort(varParam, 4);
//               brcLeft[1] = LittleEndian.getShort(varParam, 6);
//
//               brcBottom[0] = LittleEndian.getShort(varParam, 8);
//               brcBottom[1] = LittleEndian.getShort(varParam, 10);
//
//               brcRight[0] = LittleEndian.getShort(varParam, 12);
//               brcRight[1] = LittleEndian.getShort(varParam, 14);
//
//               brcHorizontal[0] = LittleEndian.getShort(varParam, 16);
//               brcHorizontal[1] = LittleEndian.getShort(varParam, 18);
//
//               brcVertical[0] = LittleEndian.getShort(varParam, 20);
//               brcVertical[1] = LittleEndian.getShort(varParam, 22);
//               break;
//          }
//          case 0x06:
//               //obsolete, used in word 1.x
//               break;
//          case 0x07:
//               newTAP.setDyaRowHeight(param);
//               break;
//          case 0x08:
//          {
//               short[] rgdxaCenter = new short[varParam[0] + 1];
//               TableCellDescriptor[] rgtc = new TableCellDescriptor[varParam[0]];
//               short itcMac = varParam[0];
//               //I use varParam[0] and newTAP._itcMac interchangably
//               newTAP.setItcMac(itcMac);
//               newTAP.setRgdxaCenter(rgdxaCenter) ;
//               newTAP.setRgtc(rgtc);
//
//               for(int x = 0; x < itcMac; x++)
//               {
//                 rgdxaCenter[x] = LittleEndian.getShort(varParam , 1 + (x * 2));
//                 rgtc[x] = TableCellDescriptor.convertBytesToTC(varParam, 1 + ((itcMac + 1) * 2) + (x * 20));
//               }
//               rgdxaCenter[itcMac] = LittleEndian.getShort(varParam , 1 + (itcMac * 2));
//               break;
//          }
//          case 0x09:
//               /** @todo handle cell shading*/
//               break;
//          case 0x0a:
//               /** @todo handle word defined table styles*/
//               break;
//          case 0x20:
//          {
//               TCAbstractType[] rgtc = newTAP.getRgtc();
//
//               for(int x = varParam[0]; x < varParam[1]; x++)
//               {
//
//                 if((varParam[2] & 0x08) > 0)
//                 {
//                   short[] brcRight = rgtc[x].getBrcRight();
//                   brcRight[0] = LittleEndian.getShort(varParam, 6);
//                   brcRight[1] = LittleEndian.getShort(varParam, 8);
//                 }
//                 else if((varParam[2] & 0x04) > 0)
//                 {
//                   short[] brcBottom = rgtc[x].getBrcBottom();
//                   brcBottom[0] = LittleEndian.getShort(varParam, 6);
//                   brcBottom[1] = LittleEndian.getShort(varParam, 8);
//                 }
//                 else if((varParam[2] & 0x02) > 0)
//                 {
//                   short[] brcLeft = rgtc[x].getBrcLeft();
//                   brcLeft[0] = LittleEndian.getShort(varParam, 6);
//                   brcLeft[1] = LittleEndian.getShort(varParam, 8);
//                 }
//                 else if((varParam[2] & 0x01) > 0)
//                 {
//                   short[] brcTop = rgtc[x].getBrcTop();
//                   brcTop[0] = LittleEndian.getShort(varParam, 6);
//                   brcTop[1] = LittleEndian.getShort(varParam, 8);
//                 }
//               }
//               break;
//          }
//          case 0x21:
//               int index = (param & 0xff000000) >> 24;
//               int count = (param & 0x00ff0000) >> 16;
//               int width = (param & 0x0000ffff);
//               int itcMac = newTAP.getItcMac();
//
//               short[] rgdxaCenter = new short[itcMac + count + 1];
//               TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];
//               if(index >= itcMac)
//               {
//                 index = itcMac;
//                 System.arraycopy(newTAP.getRgdxaCenter(), 0, rgdxaCenter, 0, itcMac + 1);
//                 System.arraycopy(newTAP.getRgtc(), 0, rgtc, 0, itcMac);
//               }
//               else
//               {
//                 //copy rgdxaCenter
//                 System.arraycopy(newTAP.getRgdxaCenter(), 0, rgdxaCenter, 0, index + 1);
//                 System.arraycopy(newTAP.getRgdxaCenter(), index + 1, rgdxaCenter, index + count, itcMac - (index));
//                 //copy rgtc
//                 System.arraycopy(newTAP.getRgtc(), 0, rgtc, 0, index);
//                 System.arraycopy(newTAP.getRgtc(), index, rgtc, index + count, itcMac - index);
//               }
//
//               for(int x = index; x < index + count; x++)
//               {
//                 rgtc[x] = new TableCellDescriptor();
//                 rgdxaCenter[x] = (short)(rgdxaCenter[x-1] + width);
//               }
//               rgdxaCenter[index + count] = (short)(rgdxaCenter[(index + count)-1] + width);
//               break;
//          /**@todo handle table sprms from complex files*/
//          case 0x22:
//          case 0x23:
//          case 0x24:
//          case 0x25:
//          case 0x26:
//          case 0x27:
//          case 0x28:
//          case 0x29:
//          case 0x2a:
//          case 0x2b:
//          case 0x2c:
//               break;
//          default:
//               break;
//      }
//  }
//  /**
//   * Used in decompression of a sepx. This performs an operation defined by
//   * a single sprm.
//   *
//   * @param newSEP The SectionProperty to perfrom the operation on.
//   * @param operand The operation to perform.
//   * @param param The operation's parameter.
//   * @param varParam The operation variable length parameter.
//   */
//  static void doSEPOperation(SectionProperties newSEP, int operand, int param, byte[] varParam)
//  {
//      switch(operand)
//      {
//          case 0:
//               newSEP.setCnsPgn((byte)param);
//               break;
//          case 0x1:
//               newSEP.setIHeadingPgn((byte)param);
//               break;
//          case 0x2:
//               newSEP.setOlstAnm(varParam);
//               break;
//          case 0x3:
//               //not quite sure
//               break;
//          case 0x4:
//               //not quite sure
//               break;
//          case 0x5:
//               newSEP.setFEvenlySpaced(getFlag(param));
//               break;
//          case 0x6:
//               newSEP.setFUnlocked(getFlag(param));
//               break;
//          case 0x7:
//               newSEP.setDmBinFirst((short)param);
//               break;
//          case 0x8:
//               newSEP.setDmBinOther((short)param);
//               break;
//          case 0x9:
//               newSEP.setBkc((byte)param);
//               break;
//          case 0xa:
//               newSEP.setFTitlePage(getFlag(param));
//               break;
//          case 0xb:
//               newSEP.setCcolM1((short)param);
//               break;
//          case 0xc:
//               newSEP.setDxaColumns(param);
//               break;
//          case 0xd:
//               newSEP.setFAutoPgn(getFlag(param));
//               break;
//          case 0xe:
//               newSEP.setNfcPgn((byte)param);
//               break;
//          case 0xf:
//               newSEP.setDyaPgn((short)param);
//               break;
//          case 0x10:
//               newSEP.setDxaPgn((short)param);
//               break;
//          case 0x11:
//               newSEP.setFPgnRestart(getFlag(param));
//               break;
//          case 0x12:
//               newSEP.setFEndNote(getFlag(param));
//               break;
//          case 0x13:
//               newSEP.setLnc((byte)param);
//               break;
//          case 0x14:
//               newSEP.setGrpfIhdt((byte)param);
//               break;
//          case 0x15:
//               newSEP.setNLnnMod((short)param);
//               break;
//          case 0x16:
//               newSEP.setDxaLnn(param);
//               break;
//          case 0x17:
//               newSEP.setDyaHdrTop(param);
//               break;
//          case 0x18:
//               newSEP.setDyaHdrBottom(param);
//               break;
//          case 0x19:
//               newSEP.setFLBetween(getFlag(param));
//               break;
//          case 0x1a:
//               newSEP.setVjc((byte)param);
//               break;
//          case 0x1b:
//               newSEP.setLnnMin((short)param);
//               break;
//          case 0x1c:
//               newSEP.setPgnStart((short)param);
//               break;
//          case 0x1d:
//               newSEP.setDmOrientPage((byte)param);
//               break;
//          case 0x1e:
//               //nothing
//               break;
//          case 0x1f:
//               newSEP.setXaPage(param);
//               break;
//          case 0x20:
//               newSEP.setYaPage(param);
//               break;
//          case 0x21:
//               newSEP.setDxaLeft(param);
//               break;
//          case 0x22:
//               newSEP.setDxaRight(param);
//               break;
//          case 0x23:
//               newSEP.setDyaTop(param);
//               break;
//          case 0x24:
//               newSEP.setDyaBottom(param);
//               break;
//          case 0x25:
//               newSEP.setDzaGutter(param);
//               break;
//          case 0x26:
//               newSEP.setDmPaperReq((short)param);
//               break;
//          case 0x27:
//               newSEP.setFPropMark(getFlag(varParam[0]));
//               break;
//          case 0x28:
//               break;
//          case 0x29:
//               break;
//          case 0x2a:
//               break;
//          case 0x2b:
//               short[] brcTop = newSEP.getBrcTop();
//               brcTop[0] = (short)(param & 0xffff);
//               brcTop[1] = (short)((param & 0xffff0000) >> 16);
//               break;
//          case 0x2c:
//               short[] brcLeft = newSEP.getBrcLeft();
//               brcLeft[0] = (short)(param & 0xffff);
//               brcLeft[1] = (short)((param & 0xffff0000) >> 16);
//               break;
//          case 0x2d:
//               short[] brcBottom = newSEP.getBrcBottom();
//               brcBottom[0] = (short)(param & 0xffff);
//               brcBottom[1] = (short)((param & 0xffff0000) >> 16);
//               break;
//          case 0x2e:
//               short[] brcRight = newSEP.getBrcRight();
//               brcRight[0] = (short)(param & 0xffff);
//               brcRight[1] = (short)((param & 0xffff0000) >> 16);
//               break;
//          case 0x2f:
//               newSEP.setPgbProp(param);
//               break;
//          case 0x30:
//               newSEP.setDxtCharSpace(param);
//               break;
//          case 0x31:
//               newSEP.setDyaLinePitch(param);
//               break;
//          case 0x33:
//               newSEP.setWTextFlow((short)param);
//               break;
//          default:
//               break;
//      }
//
//  }
  /**
   * Converts an byte value into a boolean. The byte parameter can be 1,0, 128,
   * or 129. if it is 128, this function returns the same value as oldVal. If
   * it is 129, this function returns !oldVal. This is used for certain sprms
   *
   * @param x The byte value to convert.
   * @param oldVal The old boolean value.
   *
   * @return A boolean whose value depends on x and oldVal.
   */
  private static boolean getCHPFlag(byte x, boolean oldVal)
  {
      switch(x)
      {
          case 0:
               return false;
          case 1:
               return true;
          case (byte)0x80:
               return oldVal;
          case (byte)0x81:
               return !oldVal;
          default:
               return false;
      }
  }

