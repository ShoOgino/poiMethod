        @Override
        public long init(LittleEndianInputStream leis, long recordSize, long recordId) throws IOException {
            if (recordSize < 0 || Integer.MAX_VALUE <= recordSize) {
                throw new RecordFormatException("recordSize must be a positive integer (0-0x7FFFFFFF)");
            }

            // A WMF RectL object. It is not used and MUST be ignored on receipt.
            long size = readRectL(leis, bounds);

            // A 32-bit unsigned integer that specifies the graphics mode from the GraphicsMode enumeration
            graphicsMode = EmfGraphicsMode.values()[leis.readInt()-1];
            size += LittleEndianConsts.INT_SIZE;

            size += readDimensionFloat(leis, scale);

            // A WMF PointL object that specifies the coordinates of the reference point used to position the string.
            // The reference point is defined by the last EMR_SETTEXTALIGN record.
            // If no such record has been set, the default alignment is TA_LEFT,TA_TOP.
            size += readPointL(leis, reference);
            // A 32-bit unsigned integer that specifies the number of characters in the string.
            stringLength = (int)leis.readUInt();
            // A 32-bit unsigned integer that specifies the offset to the output string, in bytes,
            // from the start of the record in which this object is contained.
            // This value MUST be 8- or 16-bit aligned, according to the character format.
            int offString = (int)leis.readUInt();
            size += 2*LittleEndianConsts.INT_SIZE;

            size += options.init(leis);
            // An optional WMF RectL object that defines a clipping and/or opaquing rectangle in logical units.
            // This rectangle is applied to the text output performed by the containing record.
            if (options.isClipped() || options.isOpaque()) {
                size += readRectL(leis, bounds);
            }

            // A 32-bit unsigned integer that specifies the offset to an intercharacter spacing array, in bytes,
            // from the start of the record in which this object is contained. This value MUST be 32-bit aligned.
            int offDx = (int)leis.readUInt();
            size += LittleEndianConsts.INT_SIZE;

            int undefinedSpace1 = (int)(offString - size - HEADER_SIZE);
            assert (undefinedSpace1 >= 0);
            leis.skipFully(undefinedSpace1);
            size += undefinedSpace1;

            rawTextBytes = IOUtils.safelyAllocate(stringLength*(isUnicode()?2:1), MAX_RECORD_LENGTH);
            leis.readFully(rawTextBytes);
            size += rawTextBytes.length;

            dx.clear();
            if (offDx > 0) {
                int undefinedSpace2 = (int) (offDx - size - HEADER_SIZE);
                assert (undefinedSpace2 >= 0);
                leis.skipFully(undefinedSpace2);
                size += undefinedSpace2;

                // An array of 32-bit unsigned integers that specify the output spacing between the origins of adjacent
                // character cells in logical units. The location of this field is specified by the value of offDx
                // in bytes from the start of this record. If spacing is defined, this field contains the same number
                // of values as characters in the output string.
                //
                // If the Options field of the EmrText object contains the ETO_PDY flag, then this buffer
                // contains twice as many values as there are characters in the output string, one
                // horizontal and one vertical offset for each, in that order.
                //
                // If ETO_RTLREADING is specified, characters are laid right to left instead of left to right.
                // No other options affect the interpretation of this field.
                while (size < recordSize) {
                    dx.add((int) leis.readUInt());
                    size += LittleEndianConsts.INT_SIZE;
                }
            }

            return size;
        }

