        /**
         * Converts the gdi pixel data to a buffered image
         * @param data the image data of all EmfPlusImage parts
         * @return the BufferedImage
         */
        public BufferedImage readGDIImage(final byte[] data) {
            if (getImageDataType() != EmfPlusImageDataType.BITMAP || getBitmapType() != EmfPlusBitmapDataType.PIXEL) {
                throw new RuntimeException("image data is not a GDI image");
            }

            final int width = getBitmapWidth();
            final int height = getBitmapHeight();
            final int stride = getBitmapStride();
            final EmfPlusPixelFormat pf = getPixelFormat();

            int[] nBits, bOffs;
            switch (pf) {
                case ARGB_32BPP:
                    nBits = new int[]{8, 8, 8, 8};
                    bOffs = new int[]{2, 1, 0, 3};
                    break;
                case RGB_24BPP:
                    nBits = new int[]{8, 8, 8};
                    bOffs = new int[]{2, 1, 0};
                    break;
                default:
                    throw new RuntimeException("not yet implemented");
            }

            ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);
            ComponentColorModel cm = new ComponentColorModel
                    (cs, nBits, pf.isAlpha(), pf.isPreMultiplied(), Transparency.TRANSLUCENT, DataBuffer.TYPE_BYTE);
            PixelInterleavedSampleModel csm =
                    new PixelInterleavedSampleModel(cm.getTransferType(), width, height, cm.getNumComponents(), stride, bOffs);

            DataBufferByte dbb = new DataBufferByte(data, data.length);
            WritableRaster raster = (WritableRaster) Raster.createRaster(csm, dbb, null);

            return new BufferedImage(cm, raster, cm.isAlphaPremultiplied(), null);
        }

