        private BufferedImage readImage(final byte[] data) {
            // TODO: instead of returning a BufferedImage, we might return a pair of raw data + image renderer
            // instead, so metafiles aren't pixelated, but directly written to the output graphics context
            try {
                switch (getImageDataType()) {
                    case BITMAP: {
                        BufferedImage bi = (getBitmapType() == EmfPlusBitmapDataType.PIXEL)
                                ? readGDIImage(data)
                                : ImageIO.read(new ByteArrayInputStream(data));

//                        final int w = bi.getWidth();
//                        final int h = bi.getHeight();
//
//                        int[] line = new int[w];
//
//                        WritableRaster wr = bi.getRaster();
//                        for (int row=0; row<h; row++) {
//                            wr.get
//                            for (int x=0; x<w; x++) {
//                                // TODO: use clamp color here
//                                if ((line[x] & 0xFFFFFF) == 0) {
//                                    // make it transparent
//                                    line[x] &= 0xFFFFFF;
//                                }
//                            }
//                            wr.setPixels(0, row, w, 1, line);
//                        }


                        return bi;
                    }
                    case METAFILE:
                        assert (getMetafileType() != null);
                        switch (getMetafileType()) {
                            case Wmf:
                            case WmfPlaceable:
                                HwmfPicture wmf = new HwmfPicture(new ByteArrayInputStream(data));
                                return readImage(wmf.getSize(), wmf::draw);

                            case Emf:
                            case EmfPlusDual:
                            case EmfPlusOnly:
                                HemfPicture emf = new HemfPicture(new ByteArrayInputStream(data));
                                return readImage(emf.getSize(), emf::draw);

                            default:
                                break;
                        }
                    default:
                        break;
                }
            } catch (IOException ignored) {
            }

            // fallback to empty image
            return new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);
        }

