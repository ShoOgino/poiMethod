	/**
	 * Adds the supplied text onto the end of the TextRun,
	 *  creating a new RichTextRun (returned) for it to
	 *  sit in.
	 * In many cases, before calling this, you'll want to add
	 *  a newline onto the end of your last RichTextRun
	 */
	public HSLFTextRun appendText(String s) {
		// We will need a StyleTextProp atom
		ensureStyleAtomPresent();

		// First up, append the text to the
		//  underlying text atom
		int oldSize = getRawText().length();
		storeText(
				getRawText() + s
		);

		// If either of the previous styles overran
		//  the text by one, we need to shuffle that
		//  extra character onto the new ones
		int pOverRun = _styleAtom.getParagraphTextLengthCovered() - oldSize;
		int cOverRun = _styleAtom.getCharacterTextLengthCovered() - oldSize;
		if(pOverRun > 0) {
			TextPropCollection tpc = _styleAtom.getParagraphStyles().getLast();
			tpc.updateTextSize(
					tpc.getCharactersCovered() - pOverRun
			);
		}
		if(cOverRun > 0) {
			TextPropCollection tpc = _styleAtom.getCharacterStyles().getLast();
			tpc.updateTextSize(
					tpc.getCharactersCovered() - cOverRun
			);
		}

		// Next, add the styles for its paragraph and characters
		TextPropCollection newPTP =
			_styleAtom.addParagraphTextPropCollection(s.length()+pOverRun);
		TextPropCollection newCTP =
			_styleAtom.addCharacterTextPropCollection(s.length()+cOverRun);

		// Now, create the new RichTextRun
		HSLFTextRun nr = new HSLFTextRun(
				this, oldSize, s.length(),
				newPTP, newCTP, false, false
		);

		// Add the new RichTextRun onto our list
		HSLFTextRun[] newRuns = new HSLFTextRun[_rtRuns.length+1];
		System.arraycopy(_rtRuns, 0, newRuns, 0, _rtRuns.length);
		newRuns[newRuns.length-1] = nr;
		_rtRuns = newRuns;

		// And return the new run to the caller
		return nr;
	}

