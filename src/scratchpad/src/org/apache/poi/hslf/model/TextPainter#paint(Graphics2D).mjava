    public void paint(Graphics2D graphics){
        AffineTransform tx = graphics.getTransform();

        Rectangle2D anchor = _shape.getLogicalAnchor2D();
        TextElement[] elem = getTextElements((float)anchor.getWidth(), graphics.getFontRenderContext());
        if(elem == null) return;

        float textHeight = 0;
        for (int i = 0; i < elem.length; i++) {
            textHeight += elem[i].ascent + elem[i].descent;
        }

        int valign = _shape.getVerticalAlignment();
        double y0 = anchor.getY();
        switch (valign){
            case TextShape.AnchorTopBaseline:
            case TextShape.AnchorTop:
                y0 += _shape.getMarginTop();
                break;
            case TextShape.AnchorBottom:
                y0 += anchor.getHeight() - textHeight - _shape.getMarginBottom();
                break;
            default:
            case TextShape.AnchorMiddle:
                float delta =  (float)anchor.getHeight() - textHeight - _shape.getMarginTop() - _shape.getMarginBottom();
                y0 += _shape.getMarginTop()  + delta/2;
                break;
        }


        // Transform of text in flipped shapes is special.
        // At this point the flip and rotation transform is already applied
        // (see XSLFShape#applyTransform ), but we need to restore it to avoid painting "upside down".
        // See Bugzilla 54210.
        if(_shape.getFlipVertical()){
            graphics.translate(anchor.getX(), anchor.getY() + anchor.getHeight());
            graphics.scale(1, -1);
            graphics.translate(-anchor.getX(), -anchor.getY());

            // text in vertically flipped shapes is rotated by 180 degrees
            double centerX = anchor.getX() + anchor.getWidth()/2;
            double centerY = anchor.getY() + anchor.getHeight()/2;
            graphics.translate(centerX, centerY);
            graphics.rotate(Math.toRadians(180));
            graphics.translate(-centerX, -centerY);
        }

        // Horizontal flipping applies only to shape outline and not to the text in the shape.
        // Applying flip second time restores the original not-flipped transform
        if(_shape.getFlipHorizontal()){
            graphics.translate(anchor.getX() + anchor.getWidth(), anchor.getY());
            graphics.scale(-1, 1);
            graphics.translate(-anchor.getX() , -anchor.getY());
        }

        //finally draw the text fragments
        for (int i = 0; i < elem.length; i++) {
            y0 += elem[i].ascent;

            Point2D.Double pen = new Point2D.Double();
            pen.y = y0;
            switch (elem[i]._align) {
                default:
                case TextShape.AlignLeft:
                    pen.x = anchor.getX() + _shape.getMarginLeft();
                    break;
                case TextShape.AlignCenter:
                    pen.x = anchor.getX() + _shape.getMarginLeft() +
                            (anchor.getWidth() - elem[i].advance - _shape.getMarginLeft() - _shape.getMarginRight()) / 2;
                    break;
                case TextShape.AlignRight:
                    pen.x = anchor.getX() + _shape.getMarginLeft() +
                            (anchor.getWidth() - elem[i].advance - _shape.getMarginLeft() - _shape.getMarginRight());
                    break;
            }
            if(elem[i]._bullet != null){
                graphics.drawString(elem[i]._bullet.getIterator(), (float)(pen.x + elem[i]._bulletOffset), (float)pen.y);
            }
            AttributedCharacterIterator chIt = elem[i]._text.getIterator();
            if(chIt.getEndIndex() > chIt.getBeginIndex()) {
                graphics.drawString(chIt, (float)(pen.x + elem[i]._textOffset), (float)pen.y);
            }
            y0 += elem[i].descent;
        }

        graphics.setTransform(tx);
    }

