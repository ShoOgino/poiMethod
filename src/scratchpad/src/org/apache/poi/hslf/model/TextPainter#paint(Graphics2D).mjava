    public void paint(Graphics2D graphics){
        TextRun run = _shape.getTextRun();
        if (run == null) return;

        String text = run.getText();
        if (text == null || text.equals("")) return;

        AttributedString at = getAttributedString(run);

        AttributedCharacterIterator it = at.getIterator();
        int paragraphStart = it.getBeginIndex();
        int paragraphEnd = it.getEndIndex();

        Rectangle2D anchor = _shape.getAnchor2D();

        float textHeight = 0;
        ArrayList lines = new ArrayList();
        LineBreakMeasurer measurer = new LineBreakMeasurer(it, graphics.getFontRenderContext());
        measurer.setPosition(paragraphStart);
        while (measurer.getPosition() < paragraphEnd) {
            int startIndex = measurer.getPosition();
            int nextBreak = text.indexOf('\n', measurer.getPosition() + 1);

            int rtIdx = startIndex == 0 ? 0 : startIndex + 1;
            if(startIndex == 0 || startIndex == text.length() - 1) rtIdx = startIndex;
            else rtIdx = startIndex + 1;

            RichTextRun rt = getRichTextRunAt(rtIdx);
            if(rt == null) {
                logger.log(POILogger.WARN,  "RichTextRun not found at pos" + (startIndex + 1) + "; text.length: " + text.length());
                break;
            }

            float wrappingWidth = (float)anchor.getWidth() - _shape.getMarginLeft() - _shape.getMarginRight();
            wrappingWidth -= rt.getTextOffset();

            if (_shape.getWordWrap() == TextShape.WrapNone) {
                wrappingWidth = _shape.getSheet().getSlideShow().getPageSize().width;
            }

            TextLayout textLayout = measurer.nextLayout(wrappingWidth + 1,
                    nextBreak == -1 ? paragraphEnd : nextBreak, true);
            if (textLayout == null) {
                textLayout = measurer.nextLayout(wrappingWidth,
                    nextBreak == -1 ? paragraphEnd : nextBreak, false);
            }
            if(textLayout == null){
                logger.log(POILogger.WARN, "Failed to break text into lines: wrappingWidth: "+wrappingWidth+
                        "; text: " + rt.getText());
                measurer.setPosition(rt.getEndIndex());
                continue;
            }
            int endIndex = measurer.getPosition();

            TextElement el = new TextElement();
            el._startIndex = startIndex;
            el._endIndex = endIndex;
            el._align = rt.getAlignment();
            el._text = textLayout;
            el._textOffset = rt.getTextOffset();

            boolean prStart = text.charAt(startIndex) == '\n' || startIndex == 0;
            if (text.charAt(startIndex) == '\n'){
                int spaceBefore = rt.getSpaceBefore();
                if (spaceBefore != 0) {
                    float val = (textLayout.getAscent() + textLayout.getDescent()) * spaceBefore/100;
                    textHeight += val;
                }
            }
            if(rt.isBullet() && prStart){
                it.setIndex(startIndex);

                AttributedString bat = new AttributedString(Character.toString(rt.getBulletChar()), it.getAttributes());
                int bulletSize = rt.getBulletSize();
                if (bulletSize != -1){
                    Float sz =  (Float)bat.getIterator().getAttribute(TextAttribute.SIZE);
                    if(sz != null) bat.addAttribute(TextAttribute.SIZE, new Float(sz.floatValue()*bulletSize/100));
                }

                TextLayout bulletLayout = new TextLayout(bat.getIterator(), graphics.getFontRenderContext());
                if(text.substring(startIndex, endIndex).length() > 1){
                    el._bullet = bulletLayout;
                    el._bulletOffset = rt.getBulletOffset();
                }
            }

            textHeight += textLayout.getAscent() + textLayout.getDescent();

            int lineSpacing = rt.getLineSpacing();
            if(lineSpacing != 0) el._spacing = textLayout.getLeading()*lineSpacing/100;
            else el._spacing = textLayout.getLeading();

            textHeight += el._spacing;

            lines.add(el);
        }

        int valign = _shape.getVerticalAlignment();
        double y0 = anchor.getY();
        switch (valign){
            case TextBox.AnchorTopBaseline:
            case TextBox.AnchorTop:
                y0 += _shape.getMarginTop();
                break;
            case TextBox.AnchorBottom:
                y0 += anchor.getHeight() - textHeight - _shape.getMarginBottom();
                break;
            default:
            case TextBox.AnchorMiddle:
                float delta =  (float)anchor.getHeight() - textHeight - _shape.getMarginTop() - _shape.getMarginBottom();
                y0 += _shape.getMarginTop()  + delta/2;
                break;
        }

        //finally draw the text fragments
        for (int i = 0; i < lines.size(); i++) {
            TextElement elem = (TextElement)lines.get(i);
            y0 += elem._text.getAscent();

            Point2D.Double pen = new Point2D.Double();
            pen.y = y0;
            switch (elem._align) {
                case TextShape.AlignLeft:
                    pen.x = anchor.getX() + _shape.getMarginLeft();
                    break;
                case TextShape.AlignCenter:
                    pen.x = anchor.getX() + _shape.getMarginLeft() +
                            (anchor.getWidth() - elem._text.getAdvance() - _shape.getMarginLeft() - _shape.getMarginRight()) / 2;
                    break;
                case TextShape.AlignRight:
                    pen.x = anchor.getX() + _shape.getMarginLeft() +
                            (anchor.getWidth() - elem._text.getAdvance() - _shape.getMarginLeft() - _shape.getMarginRight());
                    break;
                default:
                    pen.x = anchor.getX() + _shape.getMarginLeft();
                    break;
            }
            if(elem._bullet != null){
                elem._bullet.draw(graphics, (float)(pen.x + elem._bulletOffset), (float)pen.y);
            }
            elem._text.draw(graphics, (float)(pen.x + elem._textOffset), (float)pen.y);

            y0 += elem._text.getDescent();
            y0 += elem._text.getLeading();

            y0 += elem._spacing;
        }
    }

