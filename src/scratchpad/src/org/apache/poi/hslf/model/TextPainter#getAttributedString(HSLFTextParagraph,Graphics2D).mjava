    /**
     * Convert the underlying set of rich text runs into java.text.AttributedString
     */
    public AttributedString getAttributedString(HSLFTextParagraph txrun, Graphics2D graphics){
        String text = txrun.getText();
        //TODO: properly process tabs
        text = text.replace('\t', ' ');
        text = text.replace((char)160, ' ');

        AttributedString at = new AttributedString(text);
        HSLFTextRun[] rt = txrun.getRichTextRuns();
        for (int i = 0; i < rt.length; i++) {
            int start = rt[i].getStartIndex();
            int end = rt[i].getEndIndex();
            if(start == end) {
                logger.log(POILogger.INFO,  "Skipping RichTextRun with zero length");
                continue;
            }

            String mappedFont = rt[i].getFontName();
            String fallbackFont = Font.SANS_SERIF;
            if (graphics != null) {
                @SuppressWarnings("unchecked")
                Map<String,String> fontMap = (Map<String,String>)graphics.getRenderingHint(KEY_FONTMAP);
                if (fontMap != null && fontMap.containsKey(mappedFont)) {
                    mappedFont = fontMap.get(mappedFont);
                }
                @SuppressWarnings("unchecked")
                Map<String,String> fallbackMap = (Map<String,String>)graphics.getRenderingHint(KEY_FONTFALLBACK);
                if (fallbackMap != null && fallbackMap.containsKey(mappedFont)) {
                    fallbackFont = fallbackMap.get(mappedFont);
                }
            }
            
            at.addAttribute(TextAttribute.FAMILY, mappedFont, start, end);
            at.addAttribute(TextAttribute.SIZE, new Float(rt[i].getFontSize()), start, end);
            at.addAttribute(TextAttribute.FOREGROUND, rt[i].getFontColor(), start, end);
            if(rt[i].isBold()) at.addAttribute(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD, start, end);
            if(rt[i].isItalic()) at.addAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE, start, end);
            if(rt[i].isUnderlined()) {
                at.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON, start, end);
                at.addAttribute(TextAttribute.INPUT_METHOD_UNDERLINE, TextAttribute.UNDERLINE_LOW_TWO_PIXEL, start, end);
            }
            if(rt[i].isStrikethrough()) at.addAttribute(TextAttribute.STRIKETHROUGH, TextAttribute.STRIKETHROUGH_ON, start, end);
            int superScript = rt[i].getSuperscript();
            if(superScript != 0) at.addAttribute(TextAttribute.SUPERSCRIPT, superScript > 0 ? TextAttribute.SUPERSCRIPT_SUPER : TextAttribute.SUPERSCRIPT_SUB, start, end);
            
            
            int style = (rt[i].isBold() ? Font.BOLD : 0) | (rt[i].isItalic() ? Font.ITALIC : 0);
            Font f = new Font(mappedFont, style, rt[i].getFontSize());
            
            // check for unsupported characters and add a fallback font for these
            char textChr[] = text.toCharArray();
            int nextEnd = f.canDisplayUpTo(textChr, start, end);
            boolean isNextValid = nextEnd == start;
            for (int last = start; nextEnd != -1 && nextEnd <= end; ) {
                if (isNextValid) {
                    nextEnd = f.canDisplayUpTo(textChr, nextEnd, end);
                    isNextValid = false;
                } else {
                    if (nextEnd >= end || f.canDisplay(Character.codePointAt(textChr, nextEnd, end)) ) {
                        at.addAttribute(TextAttribute.FAMILY, fallbackFont, last, Math.min(nextEnd,end));
                        if (nextEnd >= end) break;
                        last = nextEnd;
                        isNextValid = true;
                    } else {
                        boolean isHS = Character.isHighSurrogate(textChr[nextEnd]);
                        nextEnd+=(isHS?2:1);
                    }
                }
            }            
        }
        return at;
    }

