	/**
	 * For an existing set of text properties, build the list of 
	 *  properties coded for in a given run of properties.
	 * @return the number of bytes that were used encoding the properties list
	 */
	public int buildTextPropList(int containsField, TextProp[] potentialProperties, byte[] data, int dataOffset) {
		int bytesPassed = 0;

		// For each possible entry, see if we match the mask
		// If we do, decode that, save it, and shuffle on
		for(int i=0; i<potentialProperties.length; i++) {
			// Check there's still data left to read
			if(dataOffset+bytesPassed >= data.length) {
				// Out of data, can't be any more properties to go
				return bytesPassed;
			}
			
			// Check if this property is found in the mask
			if((containsField & potentialProperties[i].getMask()) != 0) {
				// Bingo, data contains this property
				TextProp prop = (TextProp)potentialProperties[i].clone();
				int val = 0;
				if(prop.getSize() == 2) {
					val = LittleEndian.getShort(data,dataOffset+bytesPassed);
				} else {
					val = LittleEndian.getInt(data,dataOffset+bytesPassed);
				}
				prop.setValue(val);
				bytesPassed += prop.getSize();
				textPropList.add(prop);
			}
		}

		// Return how many bytes were used
		return bytesPassed;
	}

