	/**
	 * Internal constructor and initializer
	 */
	private TextRun(TextHeaderAtom tha, TextBytesAtom tba, TextCharsAtom tca, StyleTextPropAtom sta) {
		_headerAtom = tha;
		_styleAtom = sta;
		if(tba != null) {
			_byteAtom = tba;
			_isUnicode = false;
		} else {
			_charAtom = tca;
			_isUnicode = true;
		}
		String runRawText = getText();
		
		// Figure out the rich text runs
		// Assumes the paragraph styles are never shorter than the character ones
		LinkedList pStyles = new LinkedList();
		LinkedList cStyles = new LinkedList();
		if(_styleAtom != null) {
			_styleAtom.setParentTextSize(runRawText.length());
			pStyles = _styleAtom.getParagraphStyles();
			cStyles = _styleAtom.getCharacterStyles();
		}

		// Handle case of no current style, with a default
		if(pStyles.size() == 0 || cStyles.size() == 0) { 
			_rtRuns = new RichTextRun[1];
			_rtRuns[0] = new RichTextRun(this, 0, runRawText.length());
		} else {
			// Build up Rich Text Runs, one for each 
			//  character/paragraph style pair
			Vector rtrs = new Vector();

			int pos = 0;
			
			int curP = 0;
			int curC = 0;
			int pLenRemain = -1;
			int cLenRemain = -1;
			
			// Build one for each run with the same style
			while(pos <= runRawText.length() && curP < pStyles.size() && curC < cStyles.size()) {
				// Get the Props to use
				TextPropCollection pProps = (TextPropCollection)pStyles.get(curP);
				TextPropCollection cProps = (TextPropCollection)cStyles.get(curC);
				
				int pLen = pProps.getCharactersCovered();
				int cLen = cProps.getCharactersCovered();
				
				// Handle new pass
				boolean freshSet = false;
				if(pLenRemain == -1 && cLenRemain == -1) { freshSet = true; }
				if(pLenRemain == -1) { pLenRemain = pLen; }
				if(cLenRemain == -1) { cLenRemain = cLen; }
				
				// So we know how to build the eventual run
				int runLen = -1;
				boolean pShared = false;
				boolean cShared = false;
				
				// Same size, new styles - neither shared
				if(pLen == cLen && freshSet) {
					runLen = cLen;
					pShared = false;
					cShared = false;
					curP++;
					curC++;
					pLenRemain = -1;
					cLenRemain = -1;
				} else {
					// Some sharing
					
					// See if we are already in a shared block
					if(pLenRemain < pLen) {
						// Existing shared p block
						pShared = true;
						
						// Do we end with the c block, or either side of it?
						if(pLenRemain == cLenRemain) {
							// We end at the same time
							cShared = false;
							runLen = pLenRemain;
							curP++;
							curC++;
							pLenRemain = -1;
							cLenRemain = -1;
						} else if(pLenRemain < cLenRemain) {
							// We end before the c block
							cShared = true;
							runLen = pLenRemain;
							curP++;
							cLenRemain -= pLenRemain;
							pLenRemain = -1;
						} else {
							// We end after the c block
							cShared = false;
							runLen = cLenRemain;
							curC++;
							pLenRemain -= cLenRemain;
							cLenRemain = -1;
						}
					} else if(cLenRemain < cLen) {
						// Existing shared c block
						cShared = true;
						
						// Do we end with the p block, or either side of it?
						if(pLenRemain == cLenRemain) {
							// We end at the same time
							pShared = false;
							runLen = cLenRemain;
							curP++;
							curC++;
							pLenRemain = -1;
							cLenRemain = -1;
						} else if(cLenRemain < pLenRemain) {
							// We end before the p block
							pShared = true;
							runLen = cLenRemain;
							curC++;
							pLenRemain -= cLenRemain;
							cLenRemain = -1;
						} else {
							// We end after the p block
							pShared = false;
							runLen = pLenRemain;
							curP++;
							cLenRemain -= pLenRemain;
							pLenRemain = -1;
						}
					} else {
						// Start of a shared block
						if(pLenRemain < cLenRemain) {
							// Shared c block
							pShared = false;
							cShared = true;
							runLen = pLenRemain;
							curP++;
							cLenRemain -= pLenRemain;
							pLenRemain = -1;
						} else {
							// Shared p block
							pShared = true;
							cShared = false;
							runLen = cLenRemain;
							curC++;
							pLenRemain -= cLenRemain;
							cLenRemain = -1;
						}
					}
				}
				
				// Wind on
				int prevPos = pos;
				pos += runLen;
				// Adjust for end-of-run extra 1 length
				if(pos > runRawText.length()) {
					runLen--; 
				}
				
				// Save
				RichTextRun rtr = new RichTextRun(this, prevPos, runLen, pProps, cProps, pShared, cShared);
				rtrs.add(rtr);
			}
			
			// Build the array
			_rtRuns = new RichTextRun[rtrs.size()];
			rtrs.copyInto(_rtRuns);
		}
	}

