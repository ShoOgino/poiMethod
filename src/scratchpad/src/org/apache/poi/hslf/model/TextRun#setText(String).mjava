	/**
	 * Changes the text, and sets it all to have the same styling
	 *  as the the first character has. 
	 * If you care about styling, do setText on a RichTextRun instead 
	 */
	public synchronized void setText(String s) {
		// Save the new text to the atoms
		storeText(s);
		
		// Finally, zap and re-do the RichTextRuns
		for(int i=0; i<_rtRuns.length; i++) { _rtRuns[i] = null; }
		_rtRuns = new RichTextRun[1];

		// Now handle record stylings:
		// If there isn't styling
		//  no change, stays with no styling
		// If there is styling:
		//  everthing gets the same style that the first block has
		if(_styleAtom != null) {
			LinkedList pStyles = _styleAtom.getParagraphStyles();
			while(pStyles.size() > 1) { pStyles.removeLast(); }
			
			LinkedList cStyles = _styleAtom.getCharacterStyles();
			while(cStyles.size() > 1) { cStyles.removeLast(); }
			
			// Note - TextPropCollection's idea of the text length must
			//         be one larger than it actually is!
			// (This indicates that new text added to the end should
			//   get the same styling as the current text)
			TextPropCollection pCol = (TextPropCollection)pStyles.getFirst();
			TextPropCollection cCol = (TextPropCollection)cStyles.getFirst();
			pCol.updateTextSize(s.length()+1);
			cCol.updateTextSize(s.length()+1);
			
			// Recreate rich text run with first styling
			_rtRuns[0] = new RichTextRun(this,0,s.length(), pCol, cCol, false, false);
		} else {
			// Recreate rich text run with no styling
			_rtRuns[0] = new RichTextRun(this,0,s.length());
		}
	}

