	/**
	 * Writes out to disk the header, and then all the properties
	 */
	public void writeOut(OutputStream o) throws IOException {
		// First goes the number of characters we affect
		StyleTextPropAtom.writeLittleEndian(charactersCovered,o);

		// Then we have the reserved field if required
		if(reservedField > -1) {
			StyleTextPropAtom.writeLittleEndian(reservedField,o);
		}

		// Then the mask field
		int mask = maskSpecial;
		for(TextProp textProp : textPropList) {
            //sometimes header indicates that the bitmask is present but its value is 0
            if (textProp instanceof BitMaskTextProp) {
                if(mask == 0) mask |=  textProp.getWriteMask();
            }
            else {
                mask |= textProp.getWriteMask();
            }
        }
		StyleTextPropAtom.writeLittleEndian(mask,o);

		// Then the contents of all the properties
		for (TextProp potProp : potentialPropList) {
    		for(TextProp textProp : textPropList) {
    		    if (!textProp.getName().equals(potProp.getName())) continue;
                int val = textProp.getValue();
                if (textProp instanceof BitMaskTextProp && val == 0
                    && !(textProp instanceof ParagraphFlagsTextProp)
//                    && !(textProp instanceof CharFlagsTextProp)
                ) {
                    // don't add empty properties, as they can't be recognized while reading
                    // strangely this doesn't apply for ParagraphFlagsTextProp in contrast
                    // to the documentation in 2.9.20 TextPFException
                    continue;
                } else if (textProp.getSize() == 2) {
    				StyleTextPropAtom.writeLittleEndian((short)val,o);
    			} else if (textProp.getSize() == 4) {
    				StyleTextPropAtom.writeLittleEndian(val,o);
    			}
    		}
		}
	}

