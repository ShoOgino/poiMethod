  /**
   * Build up model level Slide and Notes objects, from the underlying
   *  records.
   */
  private void buildSlidesAndNotes() {
	// For holding the Slide Records
	Vector slidesV = new Vector(10);
	// For holding the Notes Records
	Vector notesV = new Vector(10);
	// For holding the Meta Sheet Records
	Vector metaSheetsV = new Vector(10);
	// For holding SlideListWithText Records
	Vector slwtV = new Vector(10);
	// For holding the Document record we're going to use
	Record documentRecord = null;

	// Look for Notes, Slides and Documents
	for(int i=0; i<_mostRecentCoreRecords.length; i++) {
		if(_mostRecentCoreRecords[i] instanceof org.apache.poi.hslf.record.Notes) {
			notesV.add(_mostRecentCoreRecords[i]);
		}
		if(_mostRecentCoreRecords[i] instanceof org.apache.poi.hslf.record.Slide) {
			slidesV.add(_mostRecentCoreRecords[i]);
		}
		if(_records[i].getRecordType() == RecordTypes.Document.typeID) {
			documentRecord = _mostRecentCoreRecords[i];
		}
	}

	// Ensure we really found a Document record
	// If we didn't, then the file is probably corrupt
	if(documentRecord == null) {
		throw new IllegalStateException("The PowerPoint file didn't contain a Document Record in its PersistPtr blocks. It is probably corrupt.");
	}


	// Now look for SlideListWithTexts in the most up-to-date Document Record
	//
	// Need to get the SlideAtomsSets for all of these. Then, query the
	//  SlidePersistAtom, and group stuff together between SLWT blocks
	//  based on the refID/slideID
	//
	// If a notes sheet exists, can normally match the Notes sheet ID
	//  to the slide ID in the SlidePersistAtom. Since there isn't always,
	//  and we can't find the ID in the slide, just order on the slide ID,
	//  and hand off to the Slides in turn. 
	// (Based on output from dev.SLWTTextListing and dev.SlideAndNotesAtomListing)
	//
	// We're trusting that the ordering of slides from the persistence
	//  layer will match the ordering found here. However, we should
	//  really find a PPT file with random sheets inserted to check with
	//
	// There shouldn't be any text duplication - only using the most
	//  record Document record's SLWTs should see to that

	Record[] docChildren = documentRecord.getChildRecords();
	for(int i=0; i<docChildren.length; i++) {
		// Look for SlideListWithText
		if(docChildren[i] instanceof SlideListWithText) {
			slwtV.add(docChildren[i]);
		}
		// Look for FontCollection under Environment
		if(docChildren[i].getRecordType() == RecordTypes.Environment.typeID) {
			Record[] envChildren = docChildren[i].getChildRecords();
			for(int j=0; j<envChildren.length; j++) {
				if(envChildren[j] instanceof FontCollection) {
					_fonts = (FontCollection)envChildren[j];
				}
			}
		}
	}

	// For now, grab out all the sets of Atoms in the SlideListWithText's
	// Only store those which aren't empty
	// Also, get the list of IDs while we're at it
	HashSet uniqueSlideIDs = new HashSet();
	Vector setsV = new Vector();
	for(int i=0; i<slwtV.size(); i++) {
		SlideListWithText slwt = (SlideListWithText)slwtV.get(i);
		SlideAtomsSet[] thisSets = slwt.getSlideAtomsSets();
		for(int j=0; j<thisSets.length; j++) {
			SlideAtomsSet thisSet = thisSets[j];
			setsV.add(thisSet);

			int id = thisSet.getSlidePersistAtom().getSlideIdentifier();
			Integer idI = new Integer(id);
			if(! uniqueSlideIDs.contains(idI) ) {
				uniqueSlideIDs.add(idI);
			} else {
				System.err.println("** WARNING - Found two SlideAtomsSets for a given slide (" + id + ") - only using the first one **");
			}
		}
	}


	// Now, order the SlideAtomSets by their slide's ID
	int[] slideIDs = new int[uniqueSlideIDs.size()];
	int pos = 0;
	for(Iterator getIDs = uniqueSlideIDs.iterator(); getIDs.hasNext(); pos++) {
		Integer id = (Integer)getIDs.next();
		slideIDs[pos] = id.intValue();
	}
	// Sort
	Arrays.sort(slideIDs);
	// Group
	SlideAtomsSet[] slideAtomSets = new SlideAtomsSet[slideIDs.length];
	for(int i=0; i<setsV.size(); i++) {
		SlideAtomsSet thisSet = (SlideAtomsSet)setsV.get(i);
		int id = thisSet.getSlidePersistAtom().getSlideIdentifier();
		int arrayPos = -1;
		for(int j=0; j<slideIDs.length; j++) {
			if(slideIDs[j] == id) { arrayPos = j; }
		}
		slideAtomSets[arrayPos] = thisSet;
	}



	// ******************* Do the real model layer creation ****************


	// Create our Notes
	// (Need to create first, as passed to the Slides)
	_notes = new Notes[notesV.size()];
	for(int i=0; i<_notes.length; i++) {
		_notes[i] = new Notes((org.apache.poi.hslf.record.Notes)notesV.get(i));
	}


	// Create our Slides
	_slides = new Slide[slidesV.size()];
	for(int i=0; i<_slides.length; i++) {
		// Grab the slide Record
		org.apache.poi.hslf.record.Slide slideRecord = (org.apache.poi.hslf.record.Slide)slidesV.get(i);

		// Decide if we've got a SlideAtomSet to use
		SlideAtomsSet atomSet = null;
		if(i < slideAtomSets.length) {
			atomSet = slideAtomSets[i];
		}

		// Do they have a Notes?
		Notes thisNotes = null;
		// Find their SlideAtom, and use this to check for a Notes
		SlideAtom sa = slideRecord.getSlideAtom();
		int notesID = sa.getNotesID();
		if(notesID != 0) {
			for(int k=0; k<_notes.length; k++) {
				if(_notes[k].getSheetNumber() == notesID) {
					thisNotes = _notes[k];
				}
			}
		}

		// Create the Slide model layer
		_slides[i] = new Slide(slideRecord,thisNotes,atomSet);
	}
  }

