  /**
   * Constructs a Powerpoint document from the underlying 
   * HSLFSlideShow object. Finds the model stuff from this
   *
   * @param hslfSlideShow the HSLFSlideShow to base on
   */
  public SlideShow(HSLFSlideShow hslfSlideShow) throws IOException
  {
	// Get useful things from our base slideshow
    _hslfSlideShow = hslfSlideShow;
	_records = _hslfSlideShow.getRecords();
	byte[] _docstream = _hslfSlideShow.getUnderlyingBytes();


	// For holding the Slide Records
	Vector slidesV = new Vector(10);
	// For holding the Notes Records
	Vector notesV = new Vector(10);
	// For holding the Meta Sheet Records
	Vector metaSheetsV = new Vector(10);
	// For holding Document Records
	Vector documentsV = new Vector(10);
	// For holding SlideListWithText Records
	Vector slwtV = new Vector(10);

	// Look for Notes, Slides and Documents
	for(int i=0; i<_records.length; i++) {
		if(_records[i] instanceof org.apache.poi.hslf.record.Notes) {
			notesV.add(_records[i]);
		}
		if(_records[i] instanceof org.apache.poi.hslf.record.Slide) {
			slidesV.add(_records[i]);
		}
		if(_records[i].getRecordType() == 1000l) {
			documentsV.add(_records[i]);
		}
	}


	// Also look for SlideListWithTexts in Documents
	//
	// Need to get the SlideAtomsSets for all of these. Then, query the
	//  SlidePersistAtom, and group stuff together between SLWT blocks
	//  based on the refID/slideID. Finally, build up a list of all the
	//  SlideAtomsSets for a given refID / slideID, and pass them on to
	//  the Slide when creating
	//
	// If a notes sheet exists, can normally match the Notes sheet ID
	//  to the slide ID in the SlidePersistAtom. Since there isn't always,
	//  and we can't find the ID in the slide, just order on the slide ID,
	//  and hand off to the Slides in turn.
	// (Based on output from dev.SLWTTextListing and dev.SlideAndNotesAtomListing)
	//
	// There is often duplicate text, especially for the first few
	//  Slides. Currently, it's up to the Slide model code to detect
	//  and ignore those

	for(int i=0; i<documentsV.size(); i++) {
		Record docRecord = (Record)documentsV.get(i);
		Record[] docChildren = docRecord.getChildRecords();
		for(int j=0; j<docChildren.length; j++) {
			if(docChildren[j] instanceof SlideListWithText) {
				//System.out.println("Found SLWT in document " + i);
				//System.out.println("  Has " + docChildren[j].getChildRecords().length + " children");
				slwtV.add(docChildren[j]);
			}
		}
	}

	// For now, grab out all the sets of Atoms in the SlideListWithText's
	// Only store those which aren't empty
	Vector setsV = new Vector();
	for(int i=0; i<slwtV.size(); i++) {
		SlideListWithText slwt = (SlideListWithText)slwtV.get(i);
		SlideAtomsSet[] thisSets = slwt.getSlideAtomsSets();
		for(int j=0; j<thisSets.length; j++) {
			setsV.add(thisSets[j]);
		}
	}


	// Now, sort the SlideAtomSets together into groups for the same slide ID,
	//  and order them by the slide ID

	// Find the unique IDs
	HashSet uniqueSlideIDs = new HashSet();
	for(int i=0; i<setsV.size(); i++) {
		SlideAtomsSet thisSet = (SlideAtomsSet)setsV.get(i);
		int id = thisSet.getSlidePersistAtom().getSlideIdentifier();
		Integer idI = new Integer(id);
		if(! uniqueSlideIDs.contains(idI) ) {
			uniqueSlideIDs.add(idI);
		}
	}
	int[] slideIDs = new int[uniqueSlideIDs.size()];
	int pos = 0;
	for(Iterator getIDs = uniqueSlideIDs.iterator(); getIDs.hasNext(); pos++) {
		Integer id = (Integer)getIDs.next();
		slideIDs[pos] = id.intValue();
	}
	// Sort
	Arrays.sort(slideIDs);
	// Group
	Vector[] sortedSetsV = new Vector[slideIDs.length];
	for(int i=0; i<setsV.size(); i++) {
		SlideAtomsSet thisSet = (SlideAtomsSet)setsV.get(i);
		int id = thisSet.getSlidePersistAtom().getSlideIdentifier();
		int arrayPos = -1;
		for(int j=0; j<slideIDs.length; j++) {
			if(slideIDs[j] == id) { arrayPos = j; }
		}
		if(sortedSetsV[arrayPos] == null) { sortedSetsV[arrayPos] = new Vector(); }
		sortedSetsV[arrayPos].add(thisSet);
	}


	// ******************* Do the real model layer creation ****************


	// Create our Notes
	// (Need to create first, as passed to the Slides)
	_notes = new Notes[notesV.size()];
	for(int i=0; i<_notes.length; i++) {
		_notes[i] = new Notes((org.apache.poi.hslf.record.Notes)notesV.get(i));
	}


	// Create our Slides
	_slides = new Slide[slidesV.size()];
	for(int i=0; i<_slides.length; i++) {
		// Grab the slide Record
		org.apache.poi.hslf.record.Slide slideRecord = (org.apache.poi.hslf.record.Slide)slidesV.get(i);

		// Do they have a Notes?
		Notes thisNotes = null;
		// Find their SlideAtom, and use this to check for a Notes
		Record[] slideRecordChildren = slideRecord.getChildRecords();		
		for(int j=0; j<slideRecordChildren.length; j++) {
			if(slideRecordChildren[j] instanceof SlideAtom) {
				SlideAtom sa = (SlideAtom)slideRecordChildren[j];
				int notesID = sa.getNotesID();
				if(notesID != 0) {
					for(int k=0; k<_notes.length; k++) {
						if(_notes[k].getSheetNumber() == notesID) {
							thisNotes = _notes[k];
						}
					}
				}
			}
		}

		// Grab the (hopefully) corresponding block of Atoms
		SlideAtomsSet[] sets;
		if(sortedSetsV.length > i) {
			Vector thisSetsV = sortedSetsV[i];
			sets = new SlideAtomsSet[thisSetsV.size()];
			for(int j=0; j<sets.length; j++) {
				sets[j] = (SlideAtomsSet)thisSetsV.get(j);
			}
			//System.out.println("For slide " + i + ", found " + sets.length + " Sets of text");
		} else {
			// Didn't find enough SlideAtomSets to give any to this sheet
			sets = new SlideAtomsSet[0];
		}

			// Create the Slide model layer
		_slides[i] = new Slide(slideRecord,thisNotes,sets);
	}

  }

