    /**
     * Returns a double array that contains values for the numeric cells
     * from among the list of operands. Blanks and Blank equivalent cells
     * are ignored. Error operands or cells containing operands of type
     * that are considered invalid and would result in #VALUE! error in 
     * excel cause this function to return null.
     */
    private static double[][] getNumberArray(Eval[] xops, Eval[] yops) throws EvaluationException {
    	
    	// check for errors first: size mismatch, value errors in x, value errors in y
    	
    	int nArrayItems = xops.length;
		if(nArrayItems != yops.length) {
    		throw new EvaluationException(ErrorEval.NA);
    	}
		for (int i = 0; i < xops.length; i++) {
			Eval eval = xops[i];
			if (eval instanceof ErrorEval) {
				throw new EvaluationException((ErrorEval) eval);
			}
		}
		for (int i = 0; i < yops.length; i++) {
			Eval eval = yops[i];
			if (eval instanceof ErrorEval) {
				throw new EvaluationException((ErrorEval) eval);
			}
		}
		
        double[] xResult = new double[nArrayItems];
        double[] yResult = new double[nArrayItems];
    	
        int count = 0;
        
		for (int i=0, iSize=nArrayItems; i<iSize; i++) {
		    Eval xEval = xops[i];
		    Eval yEval = yops[i];
		    
		    if (isNumberEval(xEval) && isNumberEval(yEval)) {
		    	xResult[count] = getDoubleValue(xEval);
		    	yResult[count] = getDoubleValue(yEval);
		        if (Double.isNaN(xResult[count]) || Double.isNaN(xResult[count])) {
		            throw new EvaluationException(ErrorEval.NUM_ERROR);
		        }
		        count++;
		    }
		}
        
		return new double[][] {
        	trimToSize(xResult, count),
            trimToSize(yResult, count),
		};
    }

