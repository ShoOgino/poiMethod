	public Eval evaluate(Eval[] args, int srcCellRow, short srcCellCol) {
		switch(args.length) {
			case 3:
				break;
			case 2:
				// complex rules to choose lookupVector and resultVector from the single area ref
				throw new RuntimeException("Two arg version of LOOKUP not supported yet");
			default:
				return ErrorEval.VALUE_INVALID;
		}
		
		
		try {
			ValueEval lookupValue = OperandResolver.getSingleValue(args[0], srcCellRow, srcCellCol);
			AreaEval aeLookupVector = LookupUtils.resolveTableArrayArg(args[1]);
			AreaEval aeResultVector = LookupUtils.resolveTableArrayArg(args[2]);
			
			ValueVector lookupVector = createVector(aeLookupVector);
			ValueVector resultVector = createVector(aeResultVector);
			if(lookupVector.getSize() > resultVector.getSize()) {
				// Excel seems to handle this by accessing past the end of the result vector.
				throw new RuntimeException("Lookup vector and result vector of differing sizes not supported yet");
			}
			int index = LookupUtils.lookupIndexOfValue(lookupValue, lookupVector, true);
			
			return resultVector.getItem(index);
		} catch (EvaluationException e) {
			return e.getErrorEval();
		}
	}

