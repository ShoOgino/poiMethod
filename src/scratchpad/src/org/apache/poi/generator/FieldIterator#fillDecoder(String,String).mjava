    /**
     * This utility function returns a fill method entry for a given field
     *
     * @param size - how big of an "int" or the name of the size field for a string
     * @param type - int or string
     */
    public String fillDecoder(String size, String type)
    {
        String javaType = RecordUtil.getType(size, type, 0);

        String result = "";
        if (javaType.equals("short"))
            result = "LittleEndian.getShort(data, pos + 0x" + Integer.toHexString(offset) + " + offset)";
        else if (javaType.equals("short[]"))
            result = "LittleEndian.getShortArray(data, pos + 0x" + Integer.toHexString(offset) + " + offset)";
        else if (javaType.equals("int"))
            result = "LittleEndian.getInt(data, pos + 0x" + Integer.toHexString(offset) + " + offset)";
        else if (javaType.equals("byte"))
            result = "data[ pos + 0x" + Integer.toHexString(offset) + " + offset ]";
        else if (javaType.equals("double"))
            result = "LittleEndian.getDouble(data, pos + 0x" + Integer.toHexString(offset) + " + offset)";
        else if (javaType.equals("String") && !type.equals("hbstring"))
            result = "StringUtil.getFromUnicode(data, pos + 0x" + Integer.toHexString(offset) + " + offset,("+ size + "-1)/2)";
        else if (javaType.equals("String") && type.equals("hbstring"))
            result = "StringUtil.getFromUnicodeHigh(data, pos + 0x" + Integer.toHexString(offset) + " + offset, ("+ size+"/2))";

        try
        {
            offset += Integer.parseInt(size);
        }
        catch (NumberFormatException ignore)
        {
        }
        return result;
    }

