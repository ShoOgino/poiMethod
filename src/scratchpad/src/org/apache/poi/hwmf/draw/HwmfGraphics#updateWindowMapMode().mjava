    public void updateWindowMapMode() {
        GraphicsConfiguration gc = graphicsCtx.getDeviceConfiguration();
        Rectangle2D win = prop.getWindow();
        HwmfMapMode mapMode = prop.getMapMode();
        graphicsCtx.setTransform(initialAT);

        switch (mapMode) {
        default:
        case MM_ANISOTROPIC:
            // scale output bounds to image bounds
            graphicsCtx.scale(gc.getBounds().getWidth()/bbox.getWidth(), gc.getBounds().getHeight()/bbox.getHeight());
            graphicsCtx.translate(-bbox.getX(), -bbox.getY());

            // scale window bounds to output bounds
            graphicsCtx.translate(win.getCenterX(), win.getCenterY());
            graphicsCtx.scale(bbox.getWidth()/win.getWidth(), bbox.getHeight()/win.getHeight());
            graphicsCtx.translate(-win.getCenterX(), -win.getCenterY());
            break;
        case MM_ISOTROPIC:
            // TODO: to be validated ...
            // like anisotropic, but use x-axis as reference
            graphicsCtx.scale(gc.getBounds().getWidth()/bbox.getWidth(), gc.getBounds().getWidth()/bbox.getWidth());
            graphicsCtx.translate(-bbox.getX(), -bbox.getY());
            graphicsCtx.translate(win.getCenterX(), win.getCenterY());
            graphicsCtx.scale(bbox.getWidth()/win.getWidth(), bbox.getWidth()/win.getWidth());
            graphicsCtx.translate(-win.getCenterX(), -win.getCenterY());
            break;
        case MM_LOMETRIC:
        case MM_HIMETRIC:
        case MM_LOENGLISH:
        case MM_HIENGLISH:
        case MM_TWIPS:
            // TODO: to be validated ...
            graphicsCtx.transform(gc.getNormalizingTransform());
            graphicsCtx.scale(1./mapMode.scale, -1./mapMode.scale);
            graphicsCtx.translate(-bbox.getX(), -bbox.getY());
            break;
        case MM_TEXT:
            // TODO: to be validated ...
            break;
        }
    }

