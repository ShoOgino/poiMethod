    public void drawString(byte[] text, Rectangle2D bounds, List<Integer> dx, boolean isUnicode) {

        HwmfFont font = getProperties().getFont();
        if (font == null || text == null || text.length == 0) {
            return;
        }
        
        double fontH = getFontHeight(font);
        // TODO: another approx. ...
        double fontW = fontH/1.8;
        
        Charset charset;
        if (isUnicode) {
            charset = Charsets.UTF_16LE;
        } else {
            charset = font.getCharset().getCharset();
            if (charset == null) {
                charset = DEFAULT_CHARSET;
            }
        }

        String textString = new String(text, charset).trim();
        AttributedString as = new AttributedString(textString);
        if (dx == null || dx.isEmpty()) {
            addAttributes(as, font);
        } else {
            //for multi-byte encodings (e.g. Shift_JIS), the byte length
            //might not equal the string length().
            //The x information is stored in dx[], an array parallel to the
            //byte array text[].  dx[] stores the x info in the
            //first byte of a multibyte character, but dx[] stores 0
            //for the other bytes in that character.
            //We need to map this information to the String offsets
            //dx[0] = 13 text[0] = -125
            //dx[1] = 0  text[1] = 118
            //dx[2] = 14 text[2] = -125
            //dx[3] = 0  text[3] = -115
            // needs to be remapped as:
            //dxNormed[0] = 13 textString.get(0) = U+30D7
            //dxNormed[1] = 14 textString.get(1) = U+30ED

            final List<Integer> dxNormed;
            if (textString.length() == text.length) {
                dxNormed = new ArrayList<>(dx);
            } else {
                dxNormed = new ArrayList<>(dx.size());
                int dxPosition = 0;
                int[] chars = {0};
                for (int offset = 0; offset < textString.length(); ) {
                    dxNormed.add(dx.get(dxPosition));
                    chars[0] = textString.codePointAt(offset);
                    //now figure out how many bytes it takes to encode that
                    //code point in the charset
                    int byteLength = new String(chars, 0, chars.length).getBytes(charset).length;
                    dxPosition += byteLength;
                    offset += Character.charCount(chars[0]);
                }
            }

            int cps = textString.codePointCount(0, textString.length());
            for (int i = 0; i < Math.min(dxNormed.size(),cps-1); i++) {
                addAttributes(as, font);
                // Tracking works as a prefix/advance space on characters whereas
                // dx[...] is the complete width of the current char
                // therefore we need to add the additional/suffix width to the next char
                as.addAttribute(TextAttribute.TRACKING, (dxNormed.get(i) - fontW) / fontH, i + 1, i + 2);
            }
        }
        
        
        double angle = Math.toRadians(-font.getEscapement()/10.);

        final AffineTransform at = graphicsCtx.getTransform();
        try {
            graphicsCtx.translate(bounds.getX(), bounds.getY());
            graphicsCtx.rotate(angle);
            graphicsCtx.translate(0, fontH);
            if (getProperties().getBkMode() == HwmfBkMode.OPAQUE) {
                // TODO: validate bounds
                graphicsCtx.setBackground(getProperties().getBackgroundColor().getColor());
                graphicsCtx.fill(new Rectangle2D.Double(0, 0, bounds.getWidth(), bounds.getHeight()));
            }
            graphicsCtx.setColor(getProperties().getTextColor().getColor());
            graphicsCtx.drawString(as.getIterator(), 0, 0); // (float)bounds.getX(), (float)bounds.getY());
        } finally {
            graphicsCtx.setTransform(at);
        }
    }

