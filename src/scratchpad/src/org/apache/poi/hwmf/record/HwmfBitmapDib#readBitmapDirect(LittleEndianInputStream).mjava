    protected int readBitmapDirect(LittleEndianInputStream leis) throws IOException {
        assert(colorTable == null);
        
        BufferedImage bi = new BufferedImage(headerWidth, headerHeight, BufferedImage.TYPE_INT_RGB);
        WritableRaster wr = bi.getRaster();
        
        int bitShiftRed=0,bitShiftGreen=0,bitShiftBlue=0;
        if (headerCompression == Compression.BI_BITFIELDS) {
            bitShiftGreen = 32-Integer.numberOfLeadingZeros(this.colorMaskBlue);
            bitShiftRed = 32-Integer.numberOfLeadingZeros(this.colorMaskGreen);
        }
        
        int pixelCount = headerWidth*headerHeight;
        int size = 0;
        int rgb[] = new int[3];
        for (int pixel=0; pixel<pixelCount; pixel++) {
            int v;
            switch (headerBitCount) {
            default:
                throw new RuntimeException("invalid bitcount for indexed image");
            case BI_BITCOUNT_4:
                v = leis.readUShort();
                rgb[0] = (v & colorMaskRed) >> bitShiftRed;
                rgb[1] = (v & colorMaskGreen) >> bitShiftGreen;
                rgb[2] = (v & colorMaskBlue) >> bitShiftBlue;
                size += LittleEndianConsts.SHORT_SIZE;
                break;
            case BI_BITCOUNT_5:
                rgb[2] = leis.readUByte();
                rgb[1] = leis.readUByte();
                rgb[0] = leis.readUByte();
                size += 3*LittleEndianConsts.BYTE_SIZE;
                break;
            case BI_BITCOUNT_6:
                v = leis.readInt();
                rgb[0] = (v & colorMaskRed) >> bitShiftRed;
                rgb[1] = (v & colorMaskGreen) >> bitShiftGreen;
                rgb[2] = (v & colorMaskBlue) >> bitShiftBlue;
                size += LittleEndianConsts.INT_SIZE;
                break;
            }
            wr.setPixel(pixel/headerWidth,pixel%headerWidth,rgb);
        }
        
        return size;
    }

