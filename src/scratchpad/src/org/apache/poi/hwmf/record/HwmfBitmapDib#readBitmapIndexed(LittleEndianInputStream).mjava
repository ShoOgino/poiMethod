    protected int readBitmapIndexed(LittleEndianInputStream leis) throws IOException {
        assert(colorTable != null);
        byte r[] = new byte[colorTable.length];
        byte g[] = new byte[colorTable.length];
        byte b[] = new byte[colorTable.length];
        for (int i=0; i<colorTable.length; i++) {
            r[i] = (byte)colorTable[i].getRed();
            g[i] = (byte)colorTable[i].getGreen();
            b[i] = (byte)colorTable[i].getBlue();
        }
        int bits = 32-Integer.numberOfLeadingZeros(colorTable.length);
        IndexColorModel cm = new IndexColorModel(bits,colorTable.length,r,g,b);
        
        BufferedImage bi = new BufferedImage(headerWidth, headerHeight, BufferedImage.TYPE_BYTE_INDEXED, cm);
        WritableRaster wr = bi.getRaster();
        
        int pixelCount = headerWidth*headerHeight;
        int size = 0;
        for (int pixel=0; pixel<pixelCount; size++) {
            int v = leis.readUByte();
            switch (headerBitCount) {
            default:
                throw new RuntimeException("invalid bitcount for indexed image");
            case BI_BITCOUNT_1:
                for (int j=0; j<8 && pixel<pixelCount; j++,pixel++) {
                    wr.setSample(pixel/headerWidth,pixel%headerWidth,0,(v>>(7-j))&1);
                }
                break;
            case BI_BITCOUNT_2:
                wr.setSample(pixel/headerWidth, pixel%headerWidth, 0, (v>>4)&15);
                pixel++;
                if (pixel<pixelCount) {
                    wr.setSample(pixel/headerWidth, pixel%headerWidth, 0, v&15);
                    pixel++;
                }
                break;
            case BI_BITCOUNT_3:
                wr.setSample(pixel/headerWidth, pixel%headerWidth, 0, v);
                pixel++;
                break;
            }
        }
        return size;
    }

