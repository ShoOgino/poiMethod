    public String fillDecoder( String size, String type )
    {

        String result = "";

        if ( type.equals( "short[]" ) )
            result = "LittleEndian.getSimpleShortArray(data, 0x"
                    + Integer.toHexString( offset ) + " + offset," + size + ")";
        else if ( type.equals( "byte[]" ) )
            result = "LittleEndian.getByteArray(data, 0x"
                    + Integer.toHexString( offset ) + " + offset," + size + ")";
        else if ( type.equals( "BorderCode" ) )
            result = "new BorderCode(data, 0x" + Integer.toHexString( offset )
                    + " + offset)";
        else if ( type.equals( "DateAndTime" ) )
            result = "new DateAndTime(data, 0x" + Integer.toHexString( offset )
                    + " + offset)";
        else if ( size.equals( "2" ) )
            result = "LittleEndian.getShort(data, 0x"
                    + Integer.toHexString( offset ) + " + offset)";
        else if ( size.equals( "4" ) )
            result = "LittleEndian.getInt(data, 0x"
                    + Integer.toHexString( offset ) + " + offset)";
        else if ( size.equals( "1" ) )
            result = "data[ 0x" + Integer.toHexString( offset ) + " + offset ]";
        else if ( type.equals( "double" ) )
            result = "LittleEndian.getDouble(data, 0x"
                    + Integer.toHexString( offset ) + " + offset)";

        try
        {
            offset += Integer.parseInt( size );
        }
        catch ( NumberFormatException ignore )
        {
        }
        return result;
    }

