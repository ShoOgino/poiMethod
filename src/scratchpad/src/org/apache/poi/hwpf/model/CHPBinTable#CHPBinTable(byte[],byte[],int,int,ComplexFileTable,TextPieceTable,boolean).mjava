    /**
     * Constructor used to read a binTable in from a Word document.
     */
    public CHPBinTable( byte[] documentStream, byte[] tableStream, int offset,
            int size, ComplexFileTable complexFileTable, TextPieceTable tpt,
            boolean reconstructChpxTable )
    {
        /*
         * Page 35:
         * 
         * "Associated with each interval is a BTE. A BTE holds a four-byte PN
         * (page number) which identifies the FKP page in the file which
         * contains the formatting information for that interval. A CHPX FKP
         * further partitions an interval into runs of exception text."
         */
        PlexOfCps bte = new PlexOfCps( tableStream, offset, size, 4 );
        this.tpt = tpt;

    int length = bte.length();
    for (int x = 0; x < length; x++)
    {
      GenericPropertyNode node = bte.getProperty(x);

      int pageNum = LittleEndian.getInt(node.getBytes());
      int pageOffset = POIFSConstants.SMALLER_BIG_BLOCK_SIZE * pageNum;

      CHPFormattedDiskPage cfkp = new CHPFormattedDiskPage(documentStream,
        pageOffset, tpt, reconstructChpxTable);

      int fkpSize = cfkp.size();

      for (int y = 0; y < fkpSize; y++)
      {
        final CHPX chpx = cfkp.getCHPX(y);
        if (chpx != null)
            _textRuns.add(chpx);
      }
    }

        if ( !reconstructChpxTable )
        {
            Collections.sort( _textRuns );
            return;
        }

        if ( complexFileTable != null )
        {
            SprmBuffer[] sprmBuffers = complexFileTable.getGrpprls();

            // adding CHPX from fast-saved SPRMs
            for ( TextPiece textPiece : tpt.getTextPieces() )
            {
                PropertyModifier prm = textPiece.getPieceDescriptor().getPrm();
                if ( !prm.isComplex() )
                    continue;
                int igrpprl = prm.getIgrpprl();

                if ( igrpprl < 0 || igrpprl >= sprmBuffers.length )
                {
                    logger.log( POILogger.WARN, textPiece
                            + "'s PRM references to unknown grpprl" );
                    continue;
                }

                boolean hasChp = false;
                SprmBuffer sprmBuffer = sprmBuffers[igrpprl];
                for ( SprmIterator iterator = sprmBuffer.iterator(); iterator
                        .hasNext(); )
                {
                    SprmOperation sprmOperation = iterator.next();
                    if ( sprmOperation.getType() == SprmOperation.TYPE_CHP )
                    {
                        hasChp = true;
                        break;
                    }
                }

                if ( hasChp )
                {
                    SprmBuffer newSprmBuffer;
                    try
                    {
                        newSprmBuffer = (SprmBuffer) sprmBuffer.clone();
                    }
                    catch ( CloneNotSupportedException e )
                    {
                        // shall not happen
                        throw new Error( e );
                    }

                    CHPX chpx = new CHPX( textPiece.getStart(),
                            textPiece.getEnd(), newSprmBuffer );
                    _textRuns.add( chpx );
                }
            }
        }

        // rebuild document paragraphs structure
        StringBuilder docText = new StringBuilder();
        for ( TextPiece textPiece : tpt.getTextPieces() )
        {
            String toAppend = textPiece.getStringBuffer().toString();
            int toAppendLength = toAppend.length();

            if ( toAppendLength != textPiece.getEnd() - textPiece.getStart() )
            {
                logger.log(
                        POILogger.WARN,
                        "Text piece has boundaries [",
                        Integer.valueOf( textPiece.getStart() ),
                        "; ",
                        Integer.valueOf( textPiece.getEnd() ),
                        ") but length ",
                        Integer.valueOf( textPiece.getEnd()
                                - textPiece.getStart() ) );
            }

            docText.replace( textPiece.getStart(), textPiece.getStart()
                    + toAppendLength, toAppend );
        }

        Set<Integer> textRunsBoundariesSet = new HashSet<Integer>();
        for ( CHPX chpx : _textRuns )
        {
            textRunsBoundariesSet.add( Integer.valueOf( chpx.getStart() ) );
            textRunsBoundariesSet.add( Integer.valueOf( chpx.getEnd() ) );
        }
        textRunsBoundariesSet.remove( Integer.valueOf( 0 ) );
        List<Integer> textRunsBoundariesList = new ArrayList<Integer>(
                textRunsBoundariesSet );
        Collections.sort( textRunsBoundariesList );

        List<CHPX> newChpxs = new LinkedList<CHPX>();
        int lastTextRunStart = 0;
        for ( Integer boundary : textRunsBoundariesList )
        {
            final int startInclusive = lastTextRunStart;
            final int endExclusive = boundary.intValue();
            lastTextRunStart = endExclusive;

            List<CHPX> chpxs = new LinkedList<CHPX>();
            for ( CHPX chpx : _textRuns )
            {
                int left = Math.max( startInclusive, chpx.getStart() );
                int right = Math.min( endExclusive, chpx.getEnd() );

                if ( left < right )
                {
                    chpxs.add( chpx );
                }
            }

            if ( chpxs.size() == 0 )
            {
                logger.log( POILogger.WARN, "Text piece [",
                        Integer.valueOf( startInclusive ), "; ",
                        Integer.valueOf( endExclusive ),
                        ") has no CHPX. Creating new one." );
                // create it manually
                CHPX chpx = new CHPX( startInclusive, endExclusive,
                        new SprmBuffer( 0 ) );
                newChpxs.add( chpx );
                continue;
            }

            if ( chpxs.size() == 1 )
            {
                // can we reuse existing?
                CHPX existing = chpxs.get( 0 );
                if ( existing.getStart() == startInclusive
                        && existing.getEnd() == endExclusive )
                {
                    newChpxs.add( existing );
                    continue;
                }
            }

            SprmBuffer sprmBuffer = new SprmBuffer( 0 );
            for ( CHPX chpx : chpxs )
            {
                sprmBuffer.append( chpx.getGrpprl(), 0 );
            }
            CHPX newChpx = new CHPX( startInclusive, endExclusive, sprmBuffer );
            newChpxs.add( newChpx );

            continue;
        }
        this._textRuns = new ArrayList<CHPX>( newChpxs );
    }

