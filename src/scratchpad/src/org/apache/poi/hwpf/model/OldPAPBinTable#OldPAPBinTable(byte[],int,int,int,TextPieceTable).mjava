  public OldPAPBinTable(byte[] documentStream, int offset,
                     int size, int fcMin, TextPieceTable tpt)
  {
    PlexOfCps binTable = new PlexOfCps(documentStream, offset, size, 2);

    int length = binTable.length();
    for (int x = 0; x < length; x++)
    {
      GenericPropertyNode node = binTable.getProperty(x);

      int pageNum = LittleEndian.getShort(node.getBytes());
      int pageOffset = POIFSConstants.SMALLER_BIG_BLOCK_SIZE * pageNum;

      PAPFormattedDiskPage pfkp = new PAPFormattedDiskPage(documentStream,
        documentStream, pageOffset, fcMin, tpt);

      int fkpSize = pfkp.size();

      for (int y = 0; y < fkpSize; y++)
      {
    	PAPX papx = pfkp.getPAPX(y);
        if (papx != null && tpt.isIndexInTable( papx.getStartBytes(), papx.getEndBytes() )) {
            _paragraphs.add(papx);
        } else {
            logger.log( POILogger.WARN, "PAPX [", papx.getStartBytes(),
                    "; ", papx.getEndBytes(),
                    ") (bytes) doesn't have corresponding text pieces "
                            + "and will be skipped" );
        }
      }
    }
    Collections.sort( _paragraphs, PropertyNode.StartComparator.instance );
  }

