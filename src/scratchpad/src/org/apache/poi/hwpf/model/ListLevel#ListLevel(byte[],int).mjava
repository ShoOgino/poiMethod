    public ListLevel( final byte[] buf, final int originalOffset )
    {
        int offset = originalOffset;

        _iStartAt = LittleEndian.getInt( buf, offset );
        offset += LittleEndian.INT_SIZE;
        _nfc = buf[offset++];
        _info = buf[offset++];

        _rgbxchNums = new byte[RGBXCH_NUMS_SIZE];
        System.arraycopy( buf, offset, _rgbxchNums, 0, RGBXCH_NUMS_SIZE );
        offset += RGBXCH_NUMS_SIZE;

        _ixchFollow = buf[offset++];
        _dxaSpace = LittleEndian.getInt( buf, offset );
        offset += LittleEndian.INT_SIZE;
        _dxaIndent = LittleEndian.getInt( buf, offset );
        offset += LittleEndian.INT_SIZE;
        _cbGrpprlChpx = LittleEndian.getUnsignedByte( buf, offset++ );
        _cbGrpprlPapx = LittleEndian.getUnsignedByte( buf, offset++ );
        _reserved = LittleEndian.getShort( buf, offset );
        offset += LittleEndian.SHORT_SIZE;

        _grpprlPapx = new byte[_cbGrpprlPapx];
        _grpprlChpx = new byte[_cbGrpprlChpx];
        System.arraycopy( buf, offset, _grpprlPapx, 0, _cbGrpprlPapx );
        offset += _cbGrpprlPapx;
        System.arraycopy( buf, offset, _grpprlChpx, 0, _cbGrpprlChpx );
        offset += _cbGrpprlChpx;

        int numberTextLength = LittleEndian.getShort( buf, offset );
        /* sometimes numberTextLength<0 */
        /* by derjohng */
        if ( numberTextLength > 0 )
        {
            _numberText = new char[numberTextLength];
            offset += LittleEndian.SHORT_SIZE;
            for ( int x = 0; x < numberTextLength; x++ )
            {
                _numberText[x] = (char) LittleEndian.getShort( buf, offset );
                offset += LittleEndian.SHORT_SIZE;
            }
        }

    }

