  public StyleDescription(byte[] std, int baseLength, int offset, boolean word9)
  {
     _baseLength = baseLength;
     int nameStart = offset + baseLength;
     
     _stdfBase = new StdfBase(std, offset);
      offset += StdfBase.getSize();

      //first byte(s) of variable length section of std is the length of the
      //style name and aliases string
      int nameLength = 0;
      int multiplier = 1;
      if(word9)
      {
          nameLength = LittleEndian.getShort(std, nameStart);
          multiplier = 2;
          nameStart += LittleEndian.SHORT_SIZE;
      }
      else
      {
          nameLength = std[nameStart];
      }

      try
      {
        _name = new String(std, nameStart, nameLength * multiplier, "UTF-16LE");
      }
      catch (UnsupportedEncodingException ignore)
      {
        // ignore
      }

      //length then null terminator.
      int grupxStart = ((nameLength + 1) * multiplier) + nameStart;

      // the spec only refers to two possible upxs but it mentions
      // that more may be added in the future
      int varOffset = grupxStart;
      int countOfUPX = _stdfBase.getCupx();
      _upxs = new UPX[countOfUPX];
      for(int x = 0; x < countOfUPX; x++)
      {
          int upxSize = LittleEndian.getShort(std, varOffset);
          varOffset += LittleEndian.SHORT_SIZE;

          byte[] upx = new byte[upxSize];
          System.arraycopy(std, varOffset, upx, 0, upxSize);
          _upxs[x] = new UPX(upx);
          varOffset += upxSize;


          // the upx will always start on a word boundary.
          if(upxSize % 2 == 1)
          {
              ++varOffset;
          }

      }


  }

