    public byte[] toByteArray()
    {
        byte[] buf = new byte[getSizeInBytes()];
        int offset = 0;
        LittleEndian.putInt( buf, offset, _iStartAt );
        offset += LittleEndian.INT_SIZE;
        buf[offset++] = _nfc;
        buf[offset++] = _info;
        System.arraycopy( _rgbxchNums, 0, buf, offset, RGBXCH_NUMS_SIZE );
        offset += RGBXCH_NUMS_SIZE;
        buf[offset++] = _ixchFollow;
        LittleEndian.putInt( buf, offset, _dxaSpace );
        offset += LittleEndian.INT_SIZE;
        LittleEndian.putInt( buf, offset, _dxaIndent );
        offset += LittleEndian.INT_SIZE;

        buf[offset++] = (byte) _cbGrpprlChpx;
        buf[offset++] = (byte) _cbGrpprlPapx;
        LittleEndian.putShort( buf, offset, _reserved );
        offset += LittleEndian.SHORT_SIZE;

        System.arraycopy( _grpprlPapx, 0, buf, offset, _cbGrpprlPapx );
        offset += _cbGrpprlPapx;
        System.arraycopy( _grpprlChpx, 0, buf, offset, _cbGrpprlChpx );
        offset += _cbGrpprlChpx;

        if ( _numberText == null )
        {
            // TODO - write junit to test this flow
            LittleEndian.putUShort( buf, offset, 0 );
        }
        else
        {
            LittleEndian.putUShort( buf, offset, _numberText.length );
            offset += LittleEndian.SHORT_SIZE;
            for ( int x = 0; x < _numberText.length; x++ )
            {
                LittleEndian.putUShort( buf, offset, _numberText[x] );
                offset += LittleEndian.SHORT_SIZE;
            }
        }
        return buf;
    }

