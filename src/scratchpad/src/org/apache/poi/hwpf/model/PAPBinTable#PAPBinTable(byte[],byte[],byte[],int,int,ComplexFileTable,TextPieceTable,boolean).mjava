    public PAPBinTable( byte[] documentStream, byte[] tableStream,
            byte[] dataStream, int offset, int size,
            ComplexFileTable complexFileTable, TextPieceTable tpt,
            boolean reconstructPapxTable )
    {
        long start = System.currentTimeMillis();

        {
            PlexOfCps binTable = new PlexOfCps( tableStream, offset, size, 4 );
            this.tpt = tpt;

            int length = binTable.length();
            for ( int x = 0; x < length; x++ )
            {
                GenericPropertyNode node = binTable.getProperty( x );

                int pageNum = LittleEndian.getInt( node.getBytes() );
                int pageOffset = POIFSConstants.SMALLER_BIG_BLOCK_SIZE
                        * pageNum;

                PAPFormattedDiskPage pfkp = new PAPFormattedDiskPage(
                        documentStream, dataStream, pageOffset, tpt,
                        reconstructPapxTable );

                int fkpSize = pfkp.size();

                for ( int y = 0; y < fkpSize; y++ )
                {
                    PAPX papx = pfkp.getPAPX( y );

                    if ( papx != null )
                        _paragraphs.add( papx );
                }
            }
        }

        logger.log( POILogger.DEBUG, "PAPX tables loaded in ",
                Long.valueOf( System.currentTimeMillis() - start ), " ms (",
                Integer.valueOf( _paragraphs.size() ), " elements)" );
        start = System.currentTimeMillis();

        if ( !reconstructPapxTable )
        {
            Collections.sort( _paragraphs );

            logger.log( POILogger.DEBUG, "PAPX sorted in ",
                    Long.valueOf( System.currentTimeMillis() - start ), " ms" );
            return;
        }

        if ( complexFileTable != null )
        {
            SprmBuffer[] sprmBuffers = complexFileTable.getGrpprls();

            // adding PAPX from fast-saved SPRMs
            for ( TextPiece textPiece : tpt.getTextPieces() )
            {
                PropertyModifier prm = textPiece.getPieceDescriptor().getPrm();
                if ( !prm.isComplex() )
                    continue;
                int igrpprl = prm.getIgrpprl();

                if ( igrpprl < 0 || igrpprl >= sprmBuffers.length )
                {
                    logger.log( POILogger.WARN, textPiece
                            + "'s PRM references to unknown grpprl" );
                    continue;
                }

                boolean hasPap = false;
                SprmBuffer sprmBuffer = sprmBuffers[igrpprl];
                for ( SprmIterator iterator = sprmBuffer.iterator(); iterator
                        .hasNext(); )
                {
                    SprmOperation sprmOperation = iterator.next();
                    if ( sprmOperation.getType() == SprmOperation.TYPE_PAP )
                    {
                        hasPap = true;
                        break;
                    }
                }

                if ( hasPap )
                {
                    SprmBuffer newSprmBuffer = new SprmBuffer( 2 );
                    newSprmBuffer.append( sprmBuffer.toByteArray() );

                    PAPX papx = new PAPX( textPiece.getStart(),
                            textPiece.getEnd(), newSprmBuffer, dataStream );
                    _paragraphs.add( papx );
                }
            }

            logger.log( POILogger.DEBUG,
                    "Merged (?) with PAPX from complex file table in ",
                    Long.valueOf( System.currentTimeMillis() - start ),
                    " ms (", Integer.valueOf( _paragraphs.size() ),
                    " elements in total)" );
            start = System.currentTimeMillis();
        }

        // rebuild document paragraphs structure
        StringBuilder docText = new StringBuilder();
        for ( TextPiece textPiece : tpt.getTextPieces() )
        {
            String toAppend = textPiece.getStringBuffer().toString();
            int toAppendLength = toAppend.length();

            if ( toAppendLength != textPiece.getEnd() - textPiece.getStart() )
            {
                logger.log(
                        POILogger.WARN,
                        "Text piece has boundaries [",
                        Integer.valueOf( textPiece.getStart() ),
                        "; ",
                        Integer.valueOf( textPiece.getEnd() ),
                        ") but length ",
                        Integer.valueOf( textPiece.getEnd()
                                - textPiece.getStart() ) );
            }

            docText.replace( textPiece.getStart(), textPiece.getStart()
                    + toAppendLength, toAppend );
        }
        logger.log( POILogger.DEBUG, "Document text rebuilded in ",
                Long.valueOf( System.currentTimeMillis() - start ), " ms (",
                Integer.valueOf( docText.length() ), " chars)" );
        start = System.currentTimeMillis();

        List<PAPX> oldPapxSortedByEndPos = new ArrayList<PAPX>( _paragraphs );
        Collections.sort( oldPapxSortedByEndPos,
                PropertyNode.EndComparator.instance );

        logger.log( POILogger.DEBUG, "PAPX sorted by end position in ",
                Long.valueOf( System.currentTimeMillis() - start ), " ms" );
        start = System.currentTimeMillis();

        final Map<PAPX, Integer> papxToFileOrder = new IdentityHashMap<PAPX, Integer>();
        {
        int counter = 0;
        for ( PAPX papx : _paragraphs )
        {
            papxToFileOrder.put( papx, Integer.valueOf( counter++ ) );
        }
        }

        logger.log( POILogger.DEBUG, "PAPX's order map created in ",
                Long.valueOf( System.currentTimeMillis() - start ), " ms" );
        start = System.currentTimeMillis();

        List<PAPX> newPapxs = new LinkedList<PAPX>();
        int lastParStart = 0;
        int lastPapxIndex = 0;
        for ( int charIndex = 0; charIndex < docText.length(); charIndex++ )
        {
            final char c = docText.charAt( charIndex );
            if ( c != 13 && c != 7 && c != 12 )
                continue;

            final int startInclusive = lastParStart;
            final int endExclusive = charIndex + 1;

            List<PAPX> papxs = new LinkedList<PAPX>();
            for ( int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos
                    .size(); papxIndex++ )
            {
                PAPX papx = oldPapxSortedByEndPos.get( papxIndex );

                assert papx.getEnd() > startInclusive;
                if ( papx.getEnd() - 1 > charIndex )
                {
                    lastPapxIndex = papxIndex;
                    break;
                }

                papxs.add( papx );
            }

            if ( papxs.size() == 0 )
            {
                logger.log( POILogger.WARN, "Paragraph [",
                        Integer.valueOf( startInclusive ), "; ",
                        Integer.valueOf( endExclusive ),
                        ") has no PAPX. Creating new one." );
                // create it manually
                PAPX papx = new PAPX( startInclusive, endExclusive,
                        new SprmBuffer( 2 ), dataStream );
                newPapxs.add( papx );

                lastParStart = endExclusive;
                continue;
            }

            if ( papxs.size() == 1 )
            {
                // can we reuse existing?
                PAPX existing = papxs.get( 0 );
                if ( existing.getStart() == startInclusive && existing.getEnd() == endExclusive )
                {
                    newPapxs.add( existing );
                    lastParStart = endExclusive;
                    continue;
                }
            }

            // restore file order of PAPX
            Collections.sort( papxs, new Comparator<PAPX>()
            {
                public int compare( PAPX o1, PAPX o2 )
                {
                    Integer i1 = papxToFileOrder.get( o1 );
                    Integer i2 = papxToFileOrder.get( o2 );
                    return i1.compareTo( i2 );
                }
            } );

            SprmBuffer sprmBuffer = null;
            for ( PAPX papx : papxs )
            {
                if ( sprmBuffer == null )
                    try
                    {
                        sprmBuffer = (SprmBuffer) papx.getSprmBuf().clone();
                    }
                    catch ( CloneNotSupportedException e )
                    {
                        // can't happen
                        throw new Error( e );
                    }
                else
                    sprmBuffer.append( papx.getGrpprl(), 2 );
            }
            PAPX newPapx = new PAPX( startInclusive, endExclusive, sprmBuffer,
                    dataStream );
            newPapxs.add( newPapx );

            lastParStart = endExclusive;
            continue;
        }
        this._paragraphs = new ArrayList<PAPX>( newPapxs );

        _dataStream = dataStream;
    }

