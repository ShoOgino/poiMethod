    public HWPFOldDocument(DirectoryNode directory)
            throws IOException {
        super(directory);
        
        // Where are things?
        int sedTableOffset = LittleEndian.getInt(_mainStream, 0x88);
        int sedTableSize   = LittleEndian.getInt(_mainStream, 0x8c);
        int chpTableOffset = LittleEndian.getInt(_mainStream, 0xb8);
        int chpTableSize   = LittleEndian.getInt(_mainStream, 0xbc);
        int papTableOffset = LittleEndian.getInt(_mainStream, 0xc0);
        int papTableSize   = LittleEndian.getInt(_mainStream, 0xc4);
        int fontTableOffset = LittleEndian.getInt(_mainStream, 0xd0);
        int fontTableSize = LittleEndian.getInt(_mainStream, 0xd4);

        fontTable = new OldFontTable(_mainStream, fontTableOffset, fontTableSize);
        //TODO: figure out how to map runs/text pieces to fonts
        //for now, if there's a non standard codepage in one of the fonts
        //assume that the doc is in that codepage.
        guessedCharset = guessCodePage(fontTable);

        int complexTableOffset = LittleEndian.getInt(_mainStream, 0x160);
        
        // We need to get hold of the text that makes up the
        //  document, which might be regular or fast-saved
        ComplexFileTable cft = null;
        if(_fib.getFibBase().isFComplex()) {
            cft = new OldComplexFileTable(
                    _mainStream, _mainStream,
                    complexTableOffset, _fib.getFibBase().getFcMin(), guessedCharset
            );
            tpt = (OldTextPieceTable)cft.getTextPieceTable();
            
        } else {
            // TODO Discover if these older documents can ever hold Unicode Strings?
            //  (We think not, because they seem to lack a Piece table)
            // TODO Build the Piece Descriptor properly
            //  (We have to fake it, as they don't seem to have a proper Piece table)
            PieceDescriptor pd = new PieceDescriptor(new byte[] {0,0, 0,0,0,127, 0,0}, 0, guessedCharset);
            pd.setFilePosition(_fib.getFibBase().getFcMin());

            // Generate a single Text Piece Table, with a single Text Piece
            //  which covers all the (8 bit only) text in the file
            tpt = new OldTextPieceTable();
            byte[] textData = new byte[_fib.getFibBase().getFcMac()-_fib.getFibBase().getFcMin()];
            System.arraycopy(_mainStream, _fib.getFibBase().getFcMin(), textData, 0, textData.length);

            int numChars = textData.length;
            if (CodePageUtil.VARIABLE_BYTE_CHARSETS.contains(guessedCharset)) {
                numChars /= 2;
            }

            TextPiece tp = new TextPiece(
                    0, numChars, textData, pd
            );
            tpt.add(tp);
            
        }
        _text = tpt.getText();

        // Now we can fetch the character and paragraph properties
        _cbt = new OldCHPBinTable(
                _mainStream, chpTableOffset, chpTableSize,
                _fib.getFibBase().getFcMin(), tpt
        );
        _pbt = new OldPAPBinTable(
                _mainStream, papTableOffset, papTableSize,
                _fib.getFibBase().getFcMin(), tpt
        );
        _st = new OldSectionTable(
                _mainStream, sedTableOffset, sedTableSize,
                _fib.getFibBase().getFcMin(), tpt
        );

        /*
         * in this mode we preserving PAPX/CHPX structure from file, so text may
         * miss from output, and text order may be corrupted
         */
        boolean preserveBinTables = false;
        try
        {
            preserveBinTables = Boolean.parseBoolean( System
                    .getProperty( HWPFDocument.PROPERTY_PRESERVE_BIN_TABLES ) );
        }
        catch ( Exception exc )
        {
            // ignore;
        }

        if ( !preserveBinTables )
        {
            _cbt.rebuild( cft );
            _pbt.rebuild( _text, cft );
        }
    }

