    protected void processTable( HWPFDocumentCore hwpfDocument, Element flow,
            Table table )
    {
        Element tableHeader = htmlDocumentFacade.createTableHeader();
        Element tableBody = htmlDocumentFacade.createTableBody();

        final int[] tableCellEdges = WordToHtmlUtils
                .buildTableCellEdgesArray( table );
        final int tableRows = table.numRows();

        int maxColumns = Integer.MIN_VALUE;
        for ( int r = 0; r < tableRows; r++ )
        {
            maxColumns = Math.max( maxColumns, table.getRow( r ).numCells() );
        }

        for ( int r = 0; r < tableRows; r++ )
        {
            TableRow tableRow = table.getRow( r );

            Element tableRowElement = htmlDocumentFacade.createTableRow();
            StringBuilder tableRowStyle = new StringBuilder();
            WordToHtmlUtils.addTableRowProperties( tableRow, tableRowStyle );

            // index of current element in tableCellEdges[]
            int currentEdgeIndex = 0;
            final int rowCells = tableRow.numCells();
            for ( int c = 0; c < rowCells; c++ )
            {
                TableCell tableCell = tableRow.getCell( c );

                if ( tableCell.isVerticallyMerged()
                        && !tableCell.isFirstVerticallyMerged() )
                    continue;

                Element tableCellElement;
                if ( tableRow.isTableHeader() )
                {
                    tableCellElement = htmlDocumentFacade
                            .createTableHeaderCell();
                }
                else
                {
                    tableCellElement = htmlDocumentFacade.createTableCell();
                }
                StringBuilder tableCellStyle = new StringBuilder();
                WordToHtmlUtils.addTableCellProperties( tableRow, tableCell,
                        r == 0, r == tableRows - 1, c == 0, c == rowCells - 1,
                        tableCellStyle );

                int colSpan = 0;
                int cellRightEdge = tableCell.getLeftEdge()
                        + tableCell.getWidth();
                while ( tableCellEdges[currentEdgeIndex] < cellRightEdge )
                {
                    colSpan++;
                    currentEdgeIndex++;
                }

                if ( colSpan == 0 )
                    continue;

                if ( colSpan != 1 )
                {
                    tableCellElement.setAttribute( "colspan",
                            String.valueOf( colSpan ) );
                }

                if ( tableCell.isFirstVerticallyMerged() )
                {
                    int count = 1;
                    for ( int r1 = r + 1; r1 < tableRows; r1++ )
                    {
                        TableRow nextRow = table.getRow( r1 );
                        if ( nextRow.numCells() < c )
                            break;
                        TableCell nextCell = nextRow.getCell( c );
                        if ( !nextCell.isVerticallyMerged()
                                || nextCell.isFirstVerticallyMerged() )
                            break;
                        count++;
                    }
                    if ( count > 1 )
                        tableCellElement.setAttribute( "rowspan",
                                String.valueOf( count ) );
                }

                processParagraphes( hwpfDocument, tableCellElement, tableCell,
                        table.getTableLevel() );

                if ( !tableCellElement.hasChildNodes() )
                {
                    tableCellElement.appendChild( htmlDocumentFacade
                            .createParagraph() );
                }
                if ( tableCellStyle.length() > 0 )
                    tableCellElement.setAttribute( "class", htmlDocumentFacade
                            .getOrCreateCssClass(
                                    tableCellElement.getTagName(),
                                    tableCellElement.getTagName(),
                                    tableCellStyle.toString() ) );

                tableRowElement.appendChild( tableCellElement );
            }

            if ( tableRowStyle.length() > 0 )
                tableRowElement.setAttribute( "class", htmlDocumentFacade
                        .getOrCreateCssClass( "tr", "r",
                                tableRowStyle.toString() ) );

            if ( tableRow.isTableHeader() )
            {
                tableHeader.appendChild( tableRowElement );
            }
            else
            {
                tableBody.appendChild( tableRowElement );
            }
        }

        final Element tableElement = htmlDocumentFacade.createTable();
        tableElement
                .setAttribute(
                        "class",
                        htmlDocumentFacade.getOrCreateCssClass(
                                tableElement.getTagName(), "t",
                                "table-layout:fixed;border-collapse:collapse;border-spacing:0;" ) );
        if ( tableHeader.hasChildNodes() )
        {
            tableElement.appendChild( tableHeader );
        }
        if ( tableBody.hasChildNodes() )
        {
            tableElement.appendChild( tableBody );
            flow.appendChild( tableElement );
        }
        else
        {
            logger.log( POILogger.WARN, "Table without body starting at [",
                    Integer.valueOf( table.getStartOffset() ), "; ",
                    Integer.valueOf( table.getEndOffset() ), ")" );
        }
    }

