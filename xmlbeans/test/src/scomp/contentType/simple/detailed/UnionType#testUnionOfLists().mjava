  /**
     * values allolwed here are either a list of (small, med, large, 1-3,-1,-2,-3}
     * or     (lstsmall, lstmed, lstlarge)
     */

    public void testUnionOfLists() throws Throwable {
        UnionOfListsDocument doc = UnionOfListsDocument.Factory.newInstance();
        List vals = new ArrayList();
        vals.add("small");
        vals.add(new Integer(-1));
        vals.add(new Integer(-2));
        vals.add(new Integer(-3));
        vals.add(new Integer(3));
        vals.add("medium");
        doc.setUnionOfLists(vals);
        try {
            assertTrue(doc.validate(validateOptions));
        }
        catch (Throwable t) {
            showErrors();
            throw t;
        }

        vals.clear();
        vals.add("lstsmall");
        vals.add("lstlarge");

        doc.setUnionOfLists(vals);
        try {
            assertTrue(doc.validate(validateOptions));
        }
        catch (Throwable t) {
            showErrors();
            throw t;
        }

        vals.clear();

        //mixing and matching should not be allowed
        //the list shoudl have exactly one of the 2 union types
        vals.add("lstsmall");
        vals.add(new Integer(-1));

        // if the type in a union and cannot be converted into any of the union types, and in this case
        // since the list have enumerations, an exception is expected irrespective of validateOnSet XmlOption
        // being set. Refer testUnionOfUnions comment also
        boolean voeThrown = false;
        try{
            doc.setUnionOfLists( vals );
        }
        catch (XmlValueOutOfRangeException voe){
            voeThrown = true;
        }
        finally{
            if(!voeThrown)
                fail("Expected XmlValueOutOfRangeException here");
        }

    }

