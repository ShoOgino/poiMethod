    public void testThreadedRoundtripPerf()
        throws Exception
    {
        //crank up these numbers to see real perf testing
        //the test still has some value aside from perf
        //in that it can test large stack depths.
        final int trials = getTrials(30);
        final int depth = 12;
        final int thread_cnt = 3;
        final int boolean_array_size = 30;

        Random rnd = new Random();

        com.mytest.MyClass top_obj = new com.mytest.MyClass();

        com.mytest.MyClass curr = top_obj;

        boolean[] bools = createRandomBooleanArray(rnd, boolean_array_size);

        for (int i = 0; i < depth; i++) {
            com.mytest.YourClass myelt = new com.mytest.YourClass();
            myelt.setAttrib(rnd.nextFloat());
            myelt.setMyFloat(rnd.nextFloat());
            myelt.setBooleanArray(bools);
            final com.mytest.MyClass my_c = new com.mytest.MyClass();
            myelt.setMyClass(my_c);
            curr.setMyelt(myelt);
            curr.setMyatt("STR" + rnd.nextInt());
            curr = my_c;
        }

        //inform("top_obj = " + top_obj);

        BindingContext bindingContext = getBindingContext(getBindingConfigDocument());

        final String javaType = "com.mytest.MyClass";
        final QName schemaType = MYCLASS_NAME;
        final QName elem_name = DFLT_ELEM_NAME;
        final String class_name = top_obj.getClass().getName();

        final Marshaller msh = bindingContext.createMarshaller();
        Assert.assertNotNull(msh);
        final Unmarshaller umsh = bindingContext.createUnmarshaller();
        Assert.assertNotNull(umsh);

        Object out_obj = null;
        final XmlOptions options = new XmlOptions();
        final LinkedList errors = new LinkedList();
        options.setErrorListener(errors);

        final long before_millis = System.currentTimeMillis();

        RoundTripRunner[] runners = new RoundTripRunner[thread_cnt];
        for (int i = 0; i < thread_cnt; i++) {
            runners[i] = new RoundTripRunner(top_obj, msh, umsh, elem_name,
                                             schemaType, class_name, javaType, options, trials);
        }

        inform("starting " + thread_cnt + " threads...");

        for (int i = 0; i < thread_cnt; i++) {
            runners[i].start();
        }

        inform("trials=" + trials + "\tjoining " + thread_cnt + " threads...");

        for (int i = 0; i < thread_cnt; i++) {
            runners[i].join();
        }

        inform("joined " + thread_cnt + " threads.");


        final long after_millis = System.currentTimeMillis();
        final long diff = (after_millis - before_millis);
//        inform(" perf_out_obj = " + top_obj);


        reportErrors(errors, "thread-perf");
        Assert.assertTrue(errors.isEmpty());
        //Assert.assertEquals(top_obj, out_obj);
        inform("milliseconds: " + diff + " trials: " + trials +
               " threads=" + thread_cnt);
        inform("milliseconds PER trial: " + (diff / (double)trials));
        inform("milliseconds PER roundtrip: " + (diff / ((double)trials * thread_cnt)));
    }

