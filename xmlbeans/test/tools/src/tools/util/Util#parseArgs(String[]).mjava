    /**
     * @deprecated This is really overkill.
     *
     *             Parses command-line arguments into a Hashtable.
     *             <pre>
     *             command-line : ( arg-assignment )* the-rest
     *             arg-assignment : option-name option-value?
     *             option-name : "any string with a leading '-' "
     *             option-value : "any string without a leading '-' "
     *             the-rest : "any args after options ended"
     *
     *             The following rules are used:
     *             - If an option appears multiple times, then its value is OVERWRITTEN!
     *             - If no value is given for an option, then the Hashtable entry contains a Boolean object TRUE
     *             - the rest of the arguments are stored as an array under the special key @REST
     *             - @REST value is always filled, at least with an EMPTY ARRAY (and not a null!!!)
     *             - An option of "-" ends option parsing.  Use this when a value-less option is followed by the-rest
     *
     *             Examples: (1) "-foo bar -goo zabba -boo -hoo" is parsed as
     *                           {foo -> bar, goo -> zabba, -boo -> TRUE, -hoo -> TRUE}
     *                       (2) "-foo bar -foo bar2 aaa bbb ccc" is parsed as { foo -> bar2, @REST -> [aaa,bbb,ccc] }
     *
     *             Rationale:
     *               The above grammar and rules are less powerful than those given by gnu.getopt, but
     *               are easier to use for our purposes
     *             </pre>
     */
    public static HashMap parseArgs(String args[])
    {
        HashMap ht = new HashMap();
        int k;
        int n = args.length;

        for (k = 0; k < n; k++)
        {
            // Stop option processing if not an option or is the single character '-'
            if (args[k].startsWith("-"))
            {
                // eat the '-' and end option processing if it's just a '-'
                if (args[k].length() == 1)
                {
                    k++;
                    break;
                }

                String opt = args[k].substring(1); // skip -
                String optarg = null;
                if ((k < n - 1) && !args[k + 1].startsWith("-"))
                {
                    // got an option value
                    optarg = args[k + 1];
                    k++;
                }

                ht.put(opt,
                       (null != optarg) ?
                       (Object) optarg :
                       (Object) Boolean.TRUE);
            } else
            {
                break;
            }
        }

        // either we have run out of options or
        // we have hit the first non-option argument
        //
        int n_rest = n - k;
        String rest[] = new String[n_rest];
        int j;

        for (j = 0; k < n; j++, k++)
        {
            rest[j] = args[k];
        }

        ht.put("@REST", rest);

        return ht;
    }

