    /**
     * @deprecated This is really overkill.
     *
     *             This is a subset of the above parser.  It assumes only boolean options, but
     *             allows arguments to be interspersed with options.
     *
     *             Parses command-line arguments into a Hashtable using the following grammar:
     *             command-line : ( option-name | argument )*
     *             option-name : "any string with a leading '-' "
     *             argument : "any string without a leading '-' "
     *
     *             The following rules are used:
     *             - If an option appears multiple times, then its value is OVERWRITTEN!
     *             - The Hashtable entry for any option contains a Boolean object TRUE
     *             - the rest of the arguments are stored as an array under the special key @REST
     *             - @REST value is always filled, at least with an EMPTY ARRAY (and not a null!!!)
     *             - An option of "-" ends option parsing.  Use this before an argument that must begin with a '-'
     *
     *             Examples: (1) "-foo bar -goo zabba -boo -hoo" is parsed as
     *             {foo -> TRUE, goo -> TRUE, -boo -> TRUE, -hoo -> TRUE, @REST -> [bar,zabba]}
     *             (2) "-foo bar -foo bar2 aaa - -bbb -ccc"
     *             is parsed as { foo -> TRUE, @REST -> [bar,bar2,aaa,-bbb,-ccc] }
     *
     *             Rationale:
     *             parseArgs does not have a way of specifying a trailing boolean option followed by an
     *             argument except through the '-' hack.  It is unable to implement, for example, the argument scanning of
     *             SystemSchemaBooter without forcing a change in the command-line syntax
     */
    public static HashMap parseOptions(String args[])
    {
        HashMap ht = new HashMap();
        int k;
        int n = args.length;
        int nOptions = 0;

        for (k = 0; k < n; k++)
        {
            // Stop option processing if not an option or is the single character '-'
            if (args[k].startsWith("-"))
            {
                nOptions++;
                // eat the '-' and end option processing if it's just a '-'
                if (args[k].length() == 1)
                {
                    k++;
                    break;
                }

                String opt = args[k].substring(1); // skip -
                ht.put(opt, (Object) Boolean.TRUE);
            }
        }

        // either we have run out of options or
        // we have hit a single '-'
        //
        int n_rest = n - nOptions;
        String rest[] = new String[n_rest];
        boolean bIgnoreOptions = false;
        int j = 0;
        // Rescan the args and put non-options in the rest array
        for (k = 0; k < n; k++)
        {
            if (bIgnoreOptions || !args[k].startsWith("-"))
            {
                rest[j++] = args[k];
            } else if (args[k].length() == 1)
            {
                bIgnoreOptions = true;
            }
        }

        ht.put("@REST", rest);

        return ht;
    }

