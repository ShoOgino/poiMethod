    private void findDetailedErrorEnd(Event event, State state)
    {
        SchemaProperty[] eltProperties  = state._type.getElementProperties();

        ArrayList expectedNames = new ArrayList();
        ArrayList optionalNames = new ArrayList();

        for (int ii = 0; ii < eltProperties.length; ii++)
        {
            //Get the element from the schema
            SchemaProperty sProp = eltProperties[ii];

            // test if the element is valid
            if (state.test(sProp.getName()))
            {
                if (0 == BigInteger.ZERO.compareTo(sProp.getMinOccurs()))
                    optionalNames.add(sProp.getName());
                else
                    expectedNames.add(sProp.getName());
            }
        }

        List names = (expectedNames.size() > 0 ? expectedNames : optionalNames);

        if (names.size() > 0)
        {
            StringBuffer buf = new StringBuffer();
            for (Iterator iter = names.iterator(); iter.hasNext();)
            {
                QName qname = (QName) iter.next();
                buf.append(QNameHelper.pretty(qname));
                if (iter.hasNext())
                    buf.append(" ");
            }

            emitFieldError( event, XmlErrorCodes.ELEM_COMPLEX_TYPE_LOCALLY_VALID$MISSING_ELEMENT,
                new Object[] { new Integer(names.size()), buf.toString() },
                null, null, names, XmlValidationError.INCORRECT_ELEMENT, state._type);
        }
        else
        {
            emitFieldError( event, XmlErrorCodes.ELEM_COMPLEX_TYPE_LOCALLY_VALID$EXPECTED_ELEMENT,
                null, null, null, null, XmlValidationError.ELEMENT_NOT_ALLOWED, state._type);
        }
    }

