    /**
     * Checkes the regular expression of URI, defined by RFC2369 http://www.ietf.org/rfc/rfc2396.txt Appendix B.
     * Note: The whitespace normalization rule collapse must be applied priot to calling this method.
     * @param lexical_value the lexical value
     * @return same input value if input value is in the lexical space
     * @throws InvalidLexicalValueException
     */
    public static CharSequence lexAnyURI(CharSequence lexical_value)
    {
        /*  // Reg exp from RFC2396, but it's too forgiving for XQTS
        Pattern p = Pattern.compile("^([^:/?#]+:)?(//[^/?#]*)?([^?#]*)(\\?[^#]*)?(#.*)?");
        Matcher m = p.matcher(lexical_value);
        if ( !m.matches() )
            throw new InvalidLexicalValueException("invalid anyURI value");
        else
        {
            for ( int i = 0; i<= m.groupCount(); i++ )
            {
                System.out.print("  " + i + ": " + m.group(i));
            }
            System.out.println("");
            return lexical_value;
        } */

        // Per XMLSchema spec allow spaces inside URIs
        StringBuffer s = new StringBuffer(lexical_value.toString());
        for (int ic = 0; ic<URI_CHARS_TO_BE_REPLACED.length; ic++)
        {
            int i = 0;
            while ((i = s.indexOf(URI_CHARS_TO_BE_REPLACED[ic], i)) >= 0)
            {
                s.replace(i, i + 1, URI_CHARS_REPLACED_WITH[ic]);
                i += 3;
            }
        }

        try
        {
            URI.create(s.toString());
        }
        catch (IllegalArgumentException e)
        {
            throw new InvalidLexicalValueException("invalid anyURI value: " + lexical_value, e);
        }

        return lexical_value;
    }

