    static void resolveUnionType(SchemaTypeImpl sImpl, UnionDocument.Union parseUnion, List anonTypes)
    {
        sImpl.setSimpleTypeVariety(SchemaType.UNION);
        sImpl.setBaseTypeRef(BuiltinSchemaTypeSystem.ST_ANY_SIMPLE.getRef());
        sImpl.setBaseDepth(BuiltinSchemaTypeSystem.ST_ANY_SIMPLE.getBaseDepth() + 1);
        sImpl.setDerivationType(SchemaType.DT_RESTRICTION);

        StscState state = StscState.get();
        
        if (sImpl.isRedefinition())
        {
            state.error(XmlErrorCodes.SCHEMA_REDEFINE$EXTEND_OR_RESTRICT,
                new Object[] { "union" }, parseUnion);
            // recovery: oh well.
        }
        
        List memberTypes = parseUnion.getMemberTypes();
        SimpleType[] simpleTypes = parseUnion.getSimpleTypeArray();

        List memberImplList = new ArrayList();
        
        if (simpleTypes.length == 0 && (memberTypes == null || memberTypes.size() == 0))
        {
            state.error(XmlErrorCodes.SCHEMA_SIMPLE_TYPE$UNION_HAS_MEMBER_TYPES_OR_SIMPLE_TYPES, null, parseUnion);
            // recovery: oh well, zero member types is fine.
        }

        if (memberTypes != null)
        {
            for (Iterator mNames = memberTypes.iterator(); mNames.hasNext(); )
            {
                QName mName = (QName)mNames.next();
                SchemaTypeImpl memberImpl = state.findGlobalType(mName, sImpl.getChameleonNamespace(), sImpl.getTargetNamespace());
                if (memberImpl == null)
                    // recovery: skip member
                    state.notFoundError(mName, SchemaType.TYPE, parseUnion.xgetMemberTypes(), true);
                else
                    memberImplList.add(memberImpl);
            }
        }

        for (int i = 0; i < simpleTypes.length; i++)
        {
            // BUGBUG: see if non<simpleType> children can leak through
            SchemaTypeImpl mImpl = StscTranslator.translateAnonymousSimpleType(simpleTypes[i],
                sImpl.getTargetNamespace(), sImpl.getChameleonNamespace() != null,
                sImpl.getElemFormDefault(), sImpl.getAttFormDefault(), anonTypes, sImpl);
            memberImplList.add(mImpl);
            mImpl.setAnonymousUnionMemberOrdinal(i + 1);
        }

        // Recurse and resolve all member types
        for (Iterator mImpls = memberImplList.iterator(); mImpls.hasNext(); )
        {
            SchemaTypeImpl mImpl = (SchemaTypeImpl)mImpls.next();
            if (!StscResolver.resolveType(mImpl))
            {
                // KHK: review
                String memberName = "";
                XmlObject errorLoc;
                if (mImpl.getOuterType().equals(sImpl))
                {
                    errorLoc = mImpl.getParseObject();
                }
                else
                {
                    memberName = QNameHelper.pretty(mImpl.getName()) + " ";
                    errorLoc = parseUnion.xgetMemberTypes();
                }

                state.error(XmlErrorCodes.SCHEMA_SIMPLE_TYPE$CYCLIC_UNION, new Object[] { memberName }, errorLoc);

                // recovery: ignore the errant union member
                mImpls.remove();
                continue;
            }
        }

        // Now verify members
        boolean isUnionOfLists = false;

        for (Iterator mImpls = memberImplList.iterator(); mImpls.hasNext(); )
        {
            SchemaTypeImpl mImpl = (SchemaTypeImpl)mImpls.next();

            if (!mImpl.isSimpleType())
            {
                // KHK: review
                String memberName = "";
                XmlObject errorLoc;
                if (mImpl.getOuterType() != null && mImpl.getOuterType().equals(sImpl))
                {
                    errorLoc = mImpl.getParseObject();
                }
                else
                {
                    memberName = QNameHelper.pretty(mImpl.getName()) + " ";
                    errorLoc = parseUnion.xgetMemberTypes();
                }

                state.error(XmlErrorCodes.SIMPLE_TYPE_RESTRICTION$UNION_MEMBER_NOT_SIMPLE, new Object[] { memberName }, errorLoc);

                // recovery: ignore the errant union member
                mImpls.remove();
                continue;
            }

            if (mImpl.getSimpleVariety() == SchemaType.LIST ||
                mImpl.getSimpleVariety() == SchemaType.UNION && mImpl.isUnionOfLists())
                isUnionOfLists = true;
        }

        // Verify any final restrictions
        for (int i = 0 ; i < memberImplList.size() ; i++)
        {
            SchemaTypeImpl mImpl = (SchemaTypeImpl)memberImplList.get(i);
            if (mImpl.finalUnion())
                state.error(XmlErrorCodes.SIMPLE_TYPE_PROPERTIES$UNION_FINAL, null, parseUnion);
        }

        sImpl.setUnionOfLists(isUnionOfLists);

        sImpl.setUnionMemberTypeRefs(makeRefArray(memberImplList));

        // now deal with facets
        sImpl.setBasicFacets(StscState.FACETS_UNION, StscState.FIXED_FACETS_UNION);

        // now compute our intrinsic properties
        resolveFundamentalFacets(sImpl);
    }

