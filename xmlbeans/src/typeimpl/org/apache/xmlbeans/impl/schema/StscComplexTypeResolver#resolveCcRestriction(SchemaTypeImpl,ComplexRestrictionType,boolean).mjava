    static void resolveCcRestriction(SchemaTypeImpl sImpl, ComplexRestrictionType parseTree, boolean mixed)
    {
        StscState state = StscState.get();
        String targetNamespace = sImpl.getTargetNamespace();
        boolean chameleon = (sImpl.getChameleonNamespace() != null);

        // BUGBUG: NOT YET REALLY IMPLEMENTED
        // throw new RuntimeException("Not yet implemented.");

        SchemaType baseType;
        if (parseTree.getBase() == null)
        {
            // KHK: s4s
            state.error("A complexContent must define a base type", XmlErrorCodes.MISSING_BASE, parseTree);
            baseType = null; // recovery: no inheritance.
        }
        else
        {
            if (sImpl.isRedefinition())
            {
                baseType = state.findRedefinedGlobalType(parseTree.getBase(), sImpl.getChameleonNamespace(), sImpl);
                if (baseType != null && !baseType.getName().equals(sImpl.getName()))
                {
                    state.error(XmlErrorCodes.SCHEMA_REDEFINE$SAME_TYPE,
                        new Object[] { "<complexType>",
                                       QNameHelper.pretty(baseType.getName()),
                                       QNameHelper.pretty(sImpl.getName())
                        },
                        parseTree);
                }
            }
            else
            {
                baseType = state.findGlobalType(parseTree.getBase(), sImpl.getChameleonNamespace(), targetNamespace);
            }

            if (baseType == null)
                state.notFoundError(parseTree.getBase(), SchemaType.TYPE, parseTree.xgetBase(), true);
        }

        if (baseType == null)
            baseType = BuiltinSchemaTypeSystem.ST_ANY_TYPE;

        if (baseType != null && baseType.finalRestriction())
        {
            state.error(XmlErrorCodes.COMPLEX_TYPE_RESTRICTION$FINAL,
                new Object[] { QNameHelper.pretty(baseType.getName()), QNameHelper.pretty(sImpl.getName()) },
                parseTree.xgetBase());
            // recovery: just keep going
        }

        // Recursion
        if (baseType != null)
        {
            if (!StscResolver.resolveType((SchemaTypeImpl)baseType))
                baseType = null; // circular dependency: no inheritance
        }

        List anonymousTypes = new ArrayList();
        Group parseEg = getContentModel(parseTree);

        // detect the "all" case
        int particleCode = translateParticleCode(parseEg);

        // used to ensure consistency (doesn't become part of the result)
        Map elementModel = new LinkedHashMap();

        // build content model and anonymous types
        SchemaParticle contentModel = translateContentModel( sImpl,
            parseEg, targetNamespace, chameleon,
            sImpl.getElemFormDefault(), sImpl.getAttFormDefault(),
            particleCode, anonymousTypes, elementModel, false, null);

        // detect the nonempty "all" case (empty <all> doesn't count - it needs to be eliminated to match XSD test cases)
        boolean isAll = contentModel != null && contentModel.getParticleType() == SchemaParticle.ALL;

        // build attr model and anonymous types
        SchemaAttributeModelImpl attrModel;
        if (baseType == null)
            attrModel = new SchemaAttributeModelImpl();
        else
            attrModel = new SchemaAttributeModelImpl(baseType.getAttributeModel());
        translateAttributeModel(parseTree, targetNamespace, chameleon, sImpl.getAttFormDefault(),
            anonymousTypes, sImpl, null, attrModel, baseType, false, null);

        // summarize wildcard information
        WildcardResult wcElt = summarizeEltWildcards(contentModel);
        WildcardResult wcAttr = summarizeAttrWildcards(attrModel);

        // build state machine and verify that content model is deterministic
        if (contentModel != null)
        {
            buildStateMachine(contentModel);
            if (!StscState.get().noUpa() && !((SchemaParticleImpl)contentModel).isDeterministic())
                StscState.get().error(XmlErrorCodes.UNIQUE_PARTICLE_ATTRIBUTION, null, parseEg);
        }

        // build property model
        // emitDBG("Building content Model for " + sImpl);
        Map elementPropertyModel = buildContentPropertyModelByQName(contentModel, sImpl);

        // add attribute property model
        Map attributePropertyModel = buildAttributePropertyModelByQName(attrModel, sImpl);

        // compute empty/element/mixed
        // fix for XMLBEANS-414
        int complexVariety = (mixed ? SchemaType.MIXED_CONTENT :
            (contentModel == null ? SchemaType.EMPTY_CONTENT : SchemaType.ELEMENT_CONTENT));

        // now fill in the actual schema type implementation
        sImpl.setBaseTypeRef(baseType.getRef());
        sImpl.setBaseDepth(((SchemaTypeImpl)baseType).getBaseDepth() + 1);
        sImpl.setDerivationType(SchemaType.DT_RESTRICTION);
        sImpl.setComplexTypeVariety(complexVariety);
        sImpl.setContentModel(contentModel, attrModel, elementPropertyModel, attributePropertyModel, isAll);
        sImpl.setAnonymousTypeRefs(makeRefArray(anonymousTypes));
        sImpl.setWildcardSummary(wcElt.typedWildcards, wcElt.hasWildcards, wcAttr.typedWildcards, wcAttr.hasWildcards);
    }

