    static void resolveScRestriction(SchemaTypeImpl sImpl, SimpleRestrictionType parseTree)
    {
        SchemaType baseType;
        SchemaType contentType = null;
        StscState state = StscState.get();
        String targetNamespace = sImpl.getTargetNamespace();
        boolean chameleon = (sImpl.getChameleonNamespace() != null);
        List anonymousTypes = new ArrayList();
        if (parseTree.getSimpleType() != null)
        {
            LocalSimpleType typedef = parseTree.getSimpleType();
            SchemaTypeImpl anonType = StscTranslator.
                translateAnonymousSimpleType(typedef, targetNamespace, chameleon,
                    sImpl.getElemFormDefault(), sImpl.getAttFormDefault(),
                    anonymousTypes, sImpl);
            contentType = anonType;
        }
        if (parseTree.getBase() == null)
        {
            state.error("A simpleContent restriction must define a base type", XmlErrorCodes.MISSING_BASE, parseTree);
            // recovery: extends ANY_SIMPLE type
            baseType = BuiltinSchemaTypeSystem.ST_ANY_SIMPLE;
        }
        else
        {
            if (sImpl.isRedefinition())
            {
                baseType = state.findRedefinedGlobalType(parseTree.getBase(), sImpl.getChameleonNamespace(), sImpl);
                if (baseType != null && !baseType.getName().equals(sImpl.getName()))
                {
                    state.error(XmlErrorCodes.SCHEMA_REDEFINE$SAME_TYPE,
                        new Object[] { "<simpleType>",
                                       QNameHelper.pretty(baseType.getName()),
                                       QNameHelper.pretty(sImpl.getName())
                        },
                        parseTree);
                }
            }
            else
            {
                baseType = state.findGlobalType(parseTree.getBase(), sImpl.getChameleonNamespace(), targetNamespace);
            }
            if (baseType == null)
            {
                state.notFoundError(parseTree.getBase(), SchemaType.TYPE, parseTree.xgetBase(), true);
                // recovery: extends ANY_SIMPLE type
                baseType = BuiltinSchemaTypeSystem.ST_ANY_SIMPLE;
            }
        }

        // Recursion
        StscResolver.resolveType((SchemaTypeImpl)baseType);
        if (contentType != null)
            StscResolver.resolveType((SchemaTypeImpl)contentType);
        else
            contentType = baseType;

        if (baseType.isSimpleType())
        {
            // src-ct.2: complex types with simple content cannot restrict simple types
            state.recover(XmlErrorCodes.COMPLEX_TYPE_PROPERTIES$SIMPLE_TYPE_EXTENSION,
                new Object[] { QNameHelper.pretty(baseType.getName()) },
                parseTree);
            // recovery: extends ANY_SIMPLE type
            baseType = BuiltinSchemaTypeSystem.ST_ANY_SIMPLE;
        }
        else if (baseType.getContentType() != SchemaType.SIMPLE_CONTENT &&
                 contentType == null)
        {
            // recovery: extends ANY_SIMPLE type
            baseType = BuiltinSchemaTypeSystem.ST_ANY_SIMPLE;
        }

        if (baseType != null && baseType.finalRestriction())
        {
            state.error(XmlErrorCodes.COMPLEX_TYPE_RESTRICTION$FINAL,
                    new Object[] { QNameHelper.pretty(baseType.getName()), QNameHelper.pretty(sImpl.getName()) },
                    parseTree.xgetBase());
            // recovery: just keep going
        }

        // build attr model and anonymous types
        SchemaAttributeModelImpl attrModel;
        if (baseType == null)
            attrModel = new SchemaAttributeModelImpl();
        else
            attrModel = new SchemaAttributeModelImpl(baseType.getAttributeModel());
        translateAttributeModel(parseTree, targetNamespace, chameleon, sImpl.getAttFormDefault(),
            anonymousTypes, sImpl, null, attrModel, baseType, false, null);

        // summarize wildcard information
        WildcardResult wcAttr = summarizeAttrWildcards(attrModel);

        // add attribute property model
        Map attributePropertyModel = buildAttributePropertyModelByQName(attrModel, sImpl);

        // now fill in the actual schema type implementation
        sImpl.setBaseTypeRef(baseType.getRef());
        sImpl.setBaseDepth(((SchemaTypeImpl)baseType).getBaseDepth() + 1);
        sImpl.setContentBasedOnTypeRef(contentType.getRef());
        sImpl.setDerivationType(SchemaType.DT_RESTRICTION);
        sImpl.setAnonymousTypeRefs(makeRefArray(anonymousTypes));
        sImpl.setWildcardSummary(QNameSet.EMPTY, false, wcAttr.typedWildcards, wcAttr.hasWildcards);
        sImpl.setComplexTypeVariety(SchemaType.SIMPLE_CONTENT);
        sImpl.setContentModel(null, attrModel, null, attributePropertyModel, false);
        sImpl.setSimpleTypeVariety(contentType.getSimpleVariety());
        sImpl.setPrimitiveTypeRef(contentType.getPrimitiveType() == null ? null : contentType.getPrimitiveType().getRef());
        switch (sImpl.getSimpleVariety())
        {
            case SchemaType.LIST:
                sImpl.setListItemTypeRef(contentType.getListItemType().getRef());
                break;

            case SchemaType.UNION:
                sImpl.setUnionMemberTypeRefs(makeRefArray(Arrays.asList(contentType.getUnionMemberTypes())));
                break;
        }

        // deal with facets
        StscSimpleTypeResolver.resolveFacets(sImpl, parseTree, (SchemaTypeImpl) contentType);

        // now compute our intrinsic properties
        StscSimpleTypeResolver.resolveFundamentalFacets(sImpl);
    }

