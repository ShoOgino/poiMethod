    static void resolveBasicComplexType(SchemaTypeImpl sImpl)
    {
        List anonymousTypes = new ArrayList();
        ComplexType parseTree = (ComplexType)sImpl.getParseObject();
        String targetNamespace = sImpl.getTargetNamespace();
        boolean chameleon = (sImpl.getChameleonNamespace() != null);
        Group parseGroup = getContentModel(parseTree);

        if (sImpl.isRedefinition())
        {
            StscState.get().error(XmlErrorCodes.SCHEMA_REDEFINE$EXTEND_OR_RESTRICT,
                new Object[] { "<complexType>" }, parseTree);
            // recovery: oh well.
        }

        int particleCode = translateParticleCode(parseGroup);

        // used to ensure consistency (doesn't become part of the result)
        Map elementModel = new LinkedHashMap();

        // build content model and anonymous types
        SchemaParticle contentModel = translateContentModel(sImpl,
            parseGroup, targetNamespace, chameleon,
            sImpl.getElemFormDefault(), sImpl.getAttFormDefault(),
            particleCode, anonymousTypes, elementModel, false, null);

        // detect the nonempty "all" case (empty <all> doesn't count - it needs to be eliminated to match XSD test cases)
        boolean isAll = contentModel != null && contentModel.getParticleType() == SchemaParticle.ALL;

        // build attr model and anonymous types
        SchemaAttributeModelImpl attrModel = new SchemaAttributeModelImpl();
        translateAttributeModel(parseTree, targetNamespace, chameleon, sImpl.getAttFormDefault(),
            anonymousTypes, sImpl, null, attrModel, null, true, null);

        // summarize wildcard information
        WildcardResult wcElt = summarizeEltWildcards(contentModel);
        WildcardResult wcAttr = summarizeAttrWildcards(attrModel);

        // build state machine and verify that content model is deterministic
        if (contentModel != null)
        {
            buildStateMachine(contentModel);
            if (!StscState.get().noUpa() && !((SchemaParticleImpl)contentModel).isDeterministic())
                StscState.get().error(XmlErrorCodes.UNIQUE_PARTICLE_ATTRIBUTION, null, parseGroup);
        }

        // build property model
        // emitDBG("Building content Model for " + sImpl);
        Map elementPropertyModel = buildContentPropertyModelByQName(contentModel, sImpl);

        // add attribute property model
        Map attributePropertyModel = buildAttributePropertyModelByQName(attrModel, sImpl);

        // figure out content type
        int complexVariety =
            parseTree.getMixed()
                ? SchemaType.MIXED_CONTENT
                : contentModel == null
                    ? SchemaType.EMPTY_CONTENT
                    : SchemaType.ELEMENT_CONTENT;

        // now fill in the actual schema type implementation
        sImpl.setBaseTypeRef(BuiltinSchemaTypeSystem.ST_ANY_TYPE.getRef());
        sImpl.setBaseDepth(BuiltinSchemaTypeSystem.ST_ANY_TYPE.getBaseDepth() + 1);
        sImpl.setDerivationType(SchemaType.DT_EXTENSION);
        sImpl.setComplexTypeVariety(complexVariety);
        sImpl.setContentModel(contentModel, attrModel, elementPropertyModel, attributePropertyModel, isAll);
        sImpl.setAnonymousTypeRefs(makeRefArray(anonymousTypes));
        sImpl.setWildcardSummary(wcElt.typedWildcards, wcElt.hasWildcards, wcAttr.typedWildcards, wcAttr.hasWildcards);
    }

