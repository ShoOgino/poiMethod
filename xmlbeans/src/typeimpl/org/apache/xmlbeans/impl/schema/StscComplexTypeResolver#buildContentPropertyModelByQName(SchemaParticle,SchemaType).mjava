    static Map buildContentPropertyModelByQName(SchemaParticle part, SchemaType owner)
    {
        if (part == null)
            return Collections.EMPTY_MAP;

        boolean asSequence = false;
        Map model = null;

        switch (part.getParticleType())
        {
            case SchemaParticle.ALL:
            case SchemaParticle.SEQUENCE:
                asSequence = true;
                break;
            case SchemaParticle.CHOICE:
                asSequence = false;
                break;
            case SchemaParticle.ELEMENT:
                model = buildElementPropertyModel((SchemaLocalElement)part, owner);
                break;
            case SchemaParticle.WILDCARD:
                model = Collections.EMPTY_MAP;
                break;
            default:
                assert(false);
                throw new IllegalStateException();
        }

        if (model == null)
        {
            // build model for children
            model = new LinkedHashMap();
            SchemaParticle[] children = part.getParticleChildren();

            for (int i = 0; i < children.length; i++)
            {
                // indentDBG();
                Map childModel = buildContentPropertyModelByQName(children[i], owner);
                // outdentDBG();
                for (Iterator j = childModel.values().iterator(); j.hasNext(); )
                {
                    SchemaProperty iProp = (SchemaProperty)j.next();
                    SchemaPropertyImpl oProp = (SchemaPropertyImpl)model.get(iProp.getName());
                    if (oProp == null)
                    {
                        if (!asSequence)
                            ((SchemaPropertyImpl)iProp).setMinOccurs(BigInteger.ZERO);
                        model.put(iProp.getName(), iProp);
                        continue;
                    }
                    // consistency verified in an earlier step
                    assert(oProp.getType().equals(iProp.getType()));

                    mergeProperties(oProp, iProp, asSequence);
                }
            }

            // finally deal with minOccurs, maxOccurs over whole group
            BigInteger min = part.getMinOccurs();
            BigInteger max = part.getMaxOccurs();

            for (Iterator j = model.values().iterator(); j.hasNext(); )
            {
                SchemaProperty oProp = (SchemaProperty)j.next();
                BigInteger minOccurs = oProp.getMinOccurs();
                BigInteger maxOccurs = oProp.getMaxOccurs();

                minOccurs = minOccurs.multiply(min);
                if (max != null && max.equals(BigInteger.ZERO))
                    maxOccurs = BigInteger.ZERO;
                else if (maxOccurs != null && !maxOccurs.equals(BigInteger.ZERO))
                    maxOccurs = max == null ? null : maxOccurs.multiply(max);

                ((SchemaPropertyImpl)oProp).setMinOccurs(minOccurs);
                ((SchemaPropertyImpl)oProp).setMaxOccurs(maxOccurs);
            }
        }

        return model;
    }

