        private RedefinitionHolder[] doTopologicalSort(List genericRedefines,
            StscImporter.SchemaToProcess schema, String name, short componentType)
        {
            // We have a list of files that redefine this name
            // Filter out the ones that don't redefine this file in particular
            RedefinitionHolder[] specificRedefines = new RedefinitionHolder[genericRedefines.size()];
            int n = 0;
            for (int i = 0; i < genericRedefines.size(); i++)
            {
                RedefinitionHolder h = (RedefinitionHolder) genericRedefines.get(i);
                if (h.schemaRedefined == schema ||
                    h.schemaRedefined.indirectIncludes(schema))
                    specificRedefines[n++] = h;
            }
            // Now we have the list of files that specifically redefine the
            // name in the file that we are looking for
            // Sort this list into topological order to get the right order
            // and figure out if there are multiple redefinitions involved
            RedefinitionHolder[] sortedRedefines = new RedefinitionHolder[n];
            int[] numberOfIncludes = new int[n];
            // Just count the number of inclusions for each redefinition
            for (int i = 0; i < n-1; i++)
            {
                RedefinitionHolder current = specificRedefines[i];
                for (int j = i + 1; j < n; j++)
                {
                    if (current.schemaRedefined.indirectIncludes(specificRedefines[j].schemaRedefined))
                        numberOfIncludes[i]++;
                    if (specificRedefines[j].schemaRedefined.indirectIncludes(current.schemaRedefined))
                        numberOfIncludes[j]++;
                }
            }
            // Eliminate members one by one, according to the number of schemas
            // that they include, to complete the sort
            int position = 0;
            boolean errorReported = false;
            while (position < n)
            {
                int index = -1;
                for (int i = 0; i < numberOfIncludes.length; i++)
                    if (numberOfIncludes[i] == 0)
                    {
                        if (index < 0)
                            index = i;
                    }
                if (index < 0)
                {
                    // Error! Circular redefinition
                    if (!errorReported)
                    {
                        StringBuffer fileNameList = new StringBuffer();
                        XmlObject location = null;
                        for (int i = 0; i < n; i++)
                            if (specificRedefines[i] != null)
                            {
                                fileNameList.append(specificRedefines[i].schemaLocation).
                                    append(',').append(' ');
                                if (location == null)
                                    location = locationFromRedefinitionAndCode(
                                        specificRedefines[i], name, componentType);
                            }
                        StscState.get().error("Detected circular redefinition of " +
                            componentNameFromCode(componentType) + " \"" + name +
                            "\"; Files involved: " + fileNameList.toString(),
                            XmlErrorCodes.GENERIC_ERROR, location);
                        errorReported = true;
                    }
                    int min = n;
                    for (int i = 0; i < n; i++)
                        if (numberOfIncludes[i] > 0 && numberOfIncludes[i] < min)
                        {
                            min = numberOfIncludes[i];
                            index = i;
                        }
                    numberOfIncludes[index]--;
                }
                else
                {
                    assert specificRedefines[index] != null;
                    sortedRedefines[position++] = specificRedefines[index];
                    for (int i = 0; i < n; i++)
                        if (specificRedefines[i] != null &&
                            specificRedefines[i].schemaRedefined.
                                indirectIncludes(specificRedefines[index].
                                    schemaRedefined))
                            numberOfIncludes[i]--;
                    specificRedefines[index] = null;
                    numberOfIncludes[index]--;
                }
            }
            // Nice. We now have all the redefinitions of this name in the list
            // Each one has to transitively redefine the one before, otherwise
            // it means we are attepting two different redefinitions for the same
            // component
            for (int i = 1; i < n; i++)
            {
                // Find the previous index with non-null Schema
                // Since i is never 0, such index always exists
                int j;
                for (j = i-1; j >= 0; j--)
                    if (sortedRedefines[j] != null)
                        break;

                if (!sortedRedefines[i].schemaRedefined.indirectIncludes(
                        sortedRedefines[j].schemaRedefined))
                {
                    StscState.get().error("Detected multiple redefinitions of " +
                        componentNameFromCode(componentType) +
                        " \"" + name + "\"; Files involved: " +
                        sortedRedefines[j].schemaRedefined.getSourceName() + ", " +
                        sortedRedefines[i].schemaRedefined.getSourceName(),
                        XmlErrorCodes.DUPLICATE_GLOBAL_TYPE,
                        locationFromRedefinitionAndCode(sortedRedefines[i], name, componentType));
                    // Ignore this redefinition
                    switch (componentType)
                    {
                    case SIMPLE_TYPE:
                        sortedRedefines[i].redefineSimpleType(name); break;
                    case COMPLEX_TYPE:
                        sortedRedefines[i].redefineComplexType(name); break;
                    case ATTRIBUTE_GROUP:
                        sortedRedefines[i].redefineAttributeGroup(name); break;
                    case MODEL_GROUP:
                        sortedRedefines[i].redefineModelGroup(name); break;
                    }
                    sortedRedefines[i] = null;
                }
            }

            return sortedRedefines;
        }

