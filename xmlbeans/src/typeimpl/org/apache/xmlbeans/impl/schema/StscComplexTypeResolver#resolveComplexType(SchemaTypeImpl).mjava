    public static void resolveComplexType(SchemaTypeImpl sImpl)
    {
        ComplexType parseCt = (ComplexType)sImpl.getParseObject();
        StscState state = StscState.get();
        Schema schema = getSchema(parseCt);

        // Set abstract & final flags
        boolean abs = parseCt.isSetAbstract() ? parseCt.getAbstract() : false;
        boolean finalExt = false;
        boolean finalRest = false;
        boolean finalList = false;
        boolean finalUnion = false;

        Object ds = null;
        if (parseCt.isSetFinal())
        {
            ds = parseCt.getFinal();
        }
        // Inspect the final default attribute on the schema
        else if (schema != null && schema.isSetFinalDefault())
        {
            ds = schema.getFinalDefault();
        }

        if (ds != null)
        {
            if (ds instanceof String && ds.equals("#all"))
            {
                // #ALL value
                finalExt = finalRest = finalList = finalUnion = true;
            }
            else if (ds instanceof List)
            {
                if (((List)ds).contains("extension"))
                    finalExt = true;

                if (((List)ds).contains("restriction"))
                    finalRest = true;

// Since complex types don't participate in list and unions, these can remain
// false.  Perhaps we should throw an error.

//                if (((List)ds).contains("list"))
//                    finalList = true;
//
//                if (((List)ds).contains("union"))
//                    finalUnion = true;
            }
        }

        sImpl.setAbstractFinal(abs, finalExt, finalRest, finalList, finalUnion);

        // Set block flags
        boolean blockExt = false;
        boolean blockRest = false;
        Object block = null;

        if (parseCt.isSetBlock())
            block = parseCt.getBlock();
        else if (schema != null && schema.isSetBlockDefault())
            block = schema.getBlockDefault();

        if (block != null)
        {
            if (block instanceof String && block.equals("#all"))
            {
                // #ALL value
                blockExt = blockRest = true;
            }
            else if (block instanceof List)
            {
                if (((List)block).contains("extension"))
                    blockExt = true;
                if (((List)block).contains("restriction"))
                    blockRest = true;
            }
        }

        sImpl.setBlock(blockExt, blockRest);

        // Verify: have simpleContent, complexContent, or direct stuff
        ComplexContentDocument.ComplexContent parseCc = parseCt.getComplexContent();
        SimpleContentDocument.SimpleContent parseSc = parseCt.getSimpleContent();
        Group parseGroup = getContentModel(parseCt);
        int count =
                (parseCc != null ? 1 : 0) +
                (parseSc != null ? 1 : 0) +
                (parseGroup != null ? 1 : 0);
        if (count > 1)
        {
            // KHK: s4s should catch this?
            state.error("A complex type must define either a content model, " +
                      "or a simpleContent or complexContent derivation: " +
                      "more than one found.",
                    XmlErrorCodes.REDUNDANT_CONTENT_MODEL, parseCt);
            // recovery: treat it as the first of complexContent, simpleContent, model
            parseGroup = null;
            if (parseCc != null && parseSc != null)
                parseSc = null;
        }

        if (parseCc != null)
        {
            // KHK: s4s should catch this?
            if (parseCc.getExtension() != null && parseCc.getRestriction() != null)
                state.error("Restriction conflicts with extension", XmlErrorCodes.REDUNDANT_CONTENT_MODEL, parseCc.getRestriction());

            // Mixed can be specified in two places: the rules are that Cc wins over Ct if present
            // http://www.w3.org/TR/xmlschema-1/#c-mve
            boolean mixed = parseCc.isSetMixed() ? parseCc.getMixed() : parseCt.getMixed();

            if (parseCc.getExtension() != null)
                resolveCcExtension(sImpl, parseCc.getExtension(), mixed);
            else if (parseCc.getRestriction() != null)
                resolveCcRestriction(sImpl, parseCc.getRestriction(), mixed);
            else
            {
                // KHK: s4s should catch this?
                state.error("Missing restriction or extension", XmlErrorCodes.MISSING_RESTRICTION_OR_EXTENSION, parseCc);
                resolveErrorType(sImpl);
            }
            return;
        }
        else if (parseSc != null)
        {
            // KHK: s4s should catch this?
            if (parseSc.getExtension() != null && parseSc.getRestriction() != null)
                state.error("Restriction conflicts with extension", XmlErrorCodes.REDUNDANT_CONTENT_MODEL, parseSc.getRestriction());

            if (parseSc.getExtension() != null)
                resolveScExtension(sImpl, parseSc.getExtension());
            else if (parseSc.getRestriction() != null)
                resolveScRestriction(sImpl, parseSc.getRestriction());
            else
            {
                // KHK: s4s should catch this?
                state.error("Missing restriction or extension", XmlErrorCodes.MISSING_RESTRICTION_OR_EXTENSION, parseSc);
                resolveErrorType(sImpl);
            }
            return;
        }
        else
            resolveBasicComplexType(sImpl);
    }

