    private static void particlesMatchingStart(SchemaParticle part, QNameSetSpecification suspectSet, Map result, QNameSetBuilder eliminate)
    {
        switch (part.getParticleType())
        {
            case SchemaParticle.ELEMENT:
                if (!suspectSet.contains(part.getName()))
                    return;
                result.put(part, null);
                eliminate.add(part.getName());
                return;
                
            case SchemaParticle.WILDCARD:
                if (suspectSet.isDisjoint(part.getWildcardSet()))
                    return;
                result.put(part, part.getWildcardSet().intersect(suspectSet));
                eliminate.addAll(part.getWildcardSet());
                return;
                
            case SchemaParticle.CHOICE:
            case SchemaParticle.ALL:
                {
                    SchemaParticle[] children = part.getParticleChildren();
                    for (int i = 0; i < children.length; i++)
                        particlesMatchingStart(children[i], suspectSet, result, eliminate);
                    return;
                }
                
            case SchemaParticle.SEQUENCE:
                {
                    SchemaParticle[] children = part.getParticleChildren();
                    if (children.length == 0)
                        return;
                    if (!children[0].isSkippable())
                    {
                        particlesMatchingStart(children[0], suspectSet, result, eliminate);
                        return;
                    }
                    QNameSetBuilder remainingSuspects = new QNameSetBuilder(suspectSet);
                    QNameSetBuilder suspectsToEliminate = new QNameSetBuilder();
                    for (int i = 0; i < children.length; i++)
                    {
                        particlesMatchingStart(children[i], remainingSuspects, result, suspectsToEliminate);
                        eliminate.addAll(suspectsToEliminate);
                        if (!children[i].isSkippable())
                            return;
                        remainingSuspects.removeAll(suspectsToEliminate);
                        if (remainingSuspects.isEmpty())
                            return;
                        suspectsToEliminate.clear();
                    }
                    return;
                }
        }
    }

