    /**
     * Generates an XPath pointing to the position in the document indicated by <code>node</code>.
     * <p>If the <code>context</code> parameter is null, the XPath is absolute, otherwise the
     * XPath will be relative to the position indicated by <code>context</code>.</p>
     * <p>Note: the cursor position for the <code>node</code> parameter is not preserved</p>
     * @param node the position in the document that the generated path will point to
     * @param context the context node; the generated path will be relative to it if not null and if
     * pointing to an element on the path from the document root to <code>node</code>
     * @param nsctx a namespace context that will be used to obtain prefixes; a (non-default)
     * namespace mapping must be available for all required namespace URIs
     * @return the generated path as a <code>String</code>
     * @throws XPathGenerationException if the path could not be generated: the cursor is in a bad
     * position (like over a comment) or no prefix mapping was found for one of the namespace URIs
     */
    public static String generateXPath(XmlCursor node, XmlCursor context, NamespaceContext nsctx)
        throws XPathGenerationException
    {
        if (node == null)
            throw new IllegalArgumentException("Null node");
        if (nsctx == null)
            throw new IllegalArgumentException("Null namespace context");
        TokenType tt = node.currentTokenType();
        if (context != null && node.isAtSamePositionAs(context))
            return ".";
        switch (tt.intValue())
        {
            case TokenType.INT_ATTR:
                QName name = node.getName();
                node.toParent();
                String pathToParent = generateInternal(node, context, nsctx);
                return pathToParent + '/' + '@' + qnameToString(name, nsctx);
            case TokenType.INT_NAMESPACE:
                name = node.getName();
                node.toParent();
                pathToParent = generateInternal(node, context, nsctx);
                String prefix = name.getLocalPart();
                if (prefix.length() == 0)
                    return pathToParent + "/@xmlns";
                else
                    return pathToParent + "/@xmlns:" + prefix;
            case TokenType.INT_START:
            case TokenType.INT_STARTDOC:
                return generateInternal(node, context, nsctx);
            case TokenType.INT_TEXT:
                int nrOfTextTokens = countTextTokens(node);
                node.toParent();
                pathToParent = generateInternal(node, context, nsctx);
                if (nrOfTextTokens == 0)
                    return pathToParent + "/text()";
                else
                    return pathToParent + "/text()[position()=" + nrOfTextTokens + ']';
            default:
                throw new XPathGenerationException("Cannot generate XPath for cursor position: " +
                    tt.toString());
        }
    }

