    protected void combineElementsOfTypes(Type into, Type from, boolean makeElementsOptional, Inst2XsdOptions options)
    {
        boolean needsUnboundedChoice = false;

        if (into.getTopParticleForComplexOrMixedContent()!=Type.PARTICLE_SEQUENCE ||
            from.getTopParticleForComplexOrMixedContent()!=Type.PARTICLE_SEQUENCE)
            needsUnboundedChoice = true;

        List res = new ArrayList();

        int fromStartingIndex = 0;
        int fromMatchedIndex = -1;
        int intoMatchedIndex = -1;

        // for each element in into
        for (int i = 0; !needsUnboundedChoice && i < into.getElements().size(); i++)
        {
            // try to find one with same name in from
            Element intoElement = (Element) into.getElements().get(i);
            for (int j = fromStartingIndex; j < from.getElements().size(); j++)
            {
                Element fromElement = (Element) from.getElements().get(j);
                if (intoElement.getName().equals(fromElement.getName()))
                {
                    fromMatchedIndex = j;
                    break;
                }
            }

            // if not found, it's safe to add this one to result 'res' (as optional) and continue
            if ( fromMatchedIndex < fromStartingIndex )
            {
                res.add(intoElement);
                intoElement.setMinOccurs(0);
                continue;
            }

            // else try out all from elemens between fromStartingIndex to fromMatchedIndex
            // to see if they match one of the into elements
            intoMatchingLoop:
            for (int j2 = fromStartingIndex; j2 < fromMatchedIndex; j2++)
            {
                Element fromCandidate = (Element) from.getElements().get(j2);

                for (int i2 = i+1; i2 < into.getElements().size(); i2++)
                {
                    Element intoCandidate = (Element) into.getElements().get(i2);
                    if (fromCandidate.getName().equals(intoCandidate.getName()))
                    {
                        intoMatchedIndex = i2;
                        break intoMatchingLoop;
                    }
                }
            }

            if (intoMatchedIndex<i)
            {
                // if none matched they are safe to be added to res as optional
                for (int j3 = fromStartingIndex; j3 < fromMatchedIndex; j3++)
                {
                    Element fromCandidate = (Element) from.getElements().get(j3);
                    res.add(fromCandidate);
                    fromCandidate.setMinOccurs(0);
                }
                // also since into[i] == from[fromMatchedIndex] add it only once
                res.add(intoElement);
                Element fromMatchedElement = (Element)from.getElements().get(fromMatchedIndex);

                if (fromMatchedElement.getMinOccurs()<=0)
                    intoElement.setMinOccurs(0);
                if (fromMatchedElement.getMaxOccurs()==Element.UNBOUNDED)
                    intoElement.setMaxOccurs(Element.UNBOUNDED);

                combineTypes(intoElement.getType(), fromMatchedElement.getType(), options);
                combineElementComments(intoElement, fromMatchedElement);

                fromStartingIndex = fromMatchedIndex + 1;
                continue;
            }
            else
            {
                // if matched it means into type will transform into a choice unbounded type
                needsUnboundedChoice = true;
            }
        }

        for (int j = fromStartingIndex; j < from.getElements().size(); j++)
        {
            Element remainingFromElement = (Element) from.getElements().get(j);
            res.add(remainingFromElement);
            remainingFromElement.setMinOccurs(0);
        }

        // if choice was detected
        if (needsUnboundedChoice)
        {
            into.setTopParticleForComplexOrMixedContent(Type.PARTICLE_CHOICE_UNBOUNDED);

            outterLoop:
            for (int j = 0; j < from.getElements().size(); j++)
            {
                Element fromElem = (Element) from.getElements().get(j);
                for (int i = 0; i < into.getElements().size(); i++)
                {
                    Element intoElem = (Element)into.getElements().get(i);
                    intoElem.setMinOccurs(1);
                    intoElem.setMaxOccurs(1);

                    if (intoElem==fromElem)
                        continue outterLoop;

                    if (intoElem.getName().equals(fromElem.getName()))
                    {
                        combineTypes(intoElem.getType(), fromElem.getType(), options);
                        combineElementComments(intoElem, fromElem);

                        continue outterLoop;
                    }
                }

                // fromElem doesn't exist in into type, will add it right now
                into.addElement(fromElem);
                fromElem.setMinOccurs(1);
                fromElem.setMaxOccurs(1);
            }
            return;
        }
        else
        {
            // into remains sequence but will contain the new list of elements res
            into.setElements(res);
            return;
        }
    }

