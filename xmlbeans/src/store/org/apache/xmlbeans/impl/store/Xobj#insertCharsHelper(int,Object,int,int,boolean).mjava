    final void insertCharsHelper ( int p, Object src, int off, int cch, boolean invalidate )
    {
        assert p > 0;
        assert p >= posAfter() || isOccupied();

        int pa = posAfter();

        // Here I shuffle bookmarks and cursors affected by the insertion of the new text.  Because
        // getting the embedded cursors is non-trivial, I avoid getting them if I don't need to.
        // Basically, I need to know if p is before any text in the node as a whole.  If it is,
        // then there may be cursors/marks I need to shift right.

        if (p - (p < pa ? 1 : 2) < _cchValue + _cchAfter)
        {
            for ( Cur c = getEmbedded() ; c != null ; c = c._next )
                if (c._pos >= p)
                    c._pos += cch;

            for ( Bookmark b = _bookmarks ; b != null ; b = b._next )
                if (b._pos >= p)
                    b._pos += cch;
        }

        // Now, stuff the new characters in!  Also invalidate the proper container and if the
        // value of an attribute is changing, check for special attr invalidation.  Note that
        // I do not assume that inserting after text will have a parent.  There are use cases
        // from moveNodesContents which excersize this.

        CharUtil cu = _locale.getCharUtil();

        if (p < pa)
        {
            _srcValue = cu.insertChars( p - 1, _srcValue, _offValue, _cchValue, src, off, cch );
            _offValue = cu._offSrc;
            _cchValue = cu._cchSrc;

            if (invalidate)
            {
                invalidateUser();
                invalidateSpecialAttr( null );
            }
        }
        else
        {
            _srcAfter = cu.insertChars( p - pa, _srcAfter, _offAfter, _cchAfter, src, off, cch );
            _offAfter = cu._offSrc;
            _cchAfter = cu._cchSrc;

            if (invalidate && _parent != null)
                _parent.invalidateUser();
        }
    }

