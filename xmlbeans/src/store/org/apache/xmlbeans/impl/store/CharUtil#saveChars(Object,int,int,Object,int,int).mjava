    public Object saveChars (
        Object srcSave, int offSave, int cchSave,
        Object srcPrev, int offPrev, int cchPrev )
    {
        // BUGBUG (ericvas)
        //
        // There is a severe degenerate situation which can deveol here.  The cases is where
        // there is a long strings of calls to saveChars, where the caller passes in prev text
        // to be prepended.  In this cases, the buffer breaks and a join is made, but because the
        // join is created, subsequent calls willproduce additional joins.  I need to figure
        // out a way that a whole bunch of joins are not created.  I really only want to create
        // joins in situations where large amount of text is manipulated.

        assert isValid( srcSave, offSave, cchSave );
        assert isValid( srcPrev, offPrev, cchPrev );

        // Allocate some space to save the text and copy it there.  This may not allocate all
        // the space I need.  This happens when I run out of buffer space.  Deal with this later.
        
        char[] srcAlloc = allocate( cchSave );
        int offAlloc = _offSrc;
        int cchAlloc = _cchSrc;

        assert cchAlloc <= cchSave;

        getChars( srcAlloc, offAlloc, srcSave, offSave, cchAlloc );

        Object srcNew;
        int offNew;

        int cchNew = cchAlloc + cchPrev;
        
        // The prev arguments specify a chunk of text which the caller wants prepended to the
        // text to be saved.  The optimization here is to detect the case where the prev text
        // and the newly allcoated and saved text are adjacent, so that I can avoid copying
        // or joining the two pieces.  The situation where this happens most is when a parser
        // reports a big piece of text in chunks, perhaps because there are entities in the
        // big chunk of text.

        CharJoin j;

        if (cchPrev == 0)
        {
            srcNew = srcAlloc;
            offNew = offAlloc;
        }
        else if (srcPrev == srcAlloc && offPrev + cchPrev == offAlloc)
        {
            assert srcPrev instanceof char[];
            
            srcNew = srcPrev;
            offNew = offPrev;
        }
        else if (srcPrev instanceof CharJoin && (j = (CharJoin) srcPrev)._srcRight == srcAlloc &&
                    offPrev + cchPrev - j._cchLeft + j._offRight == offAlloc)
        {
            assert j._srcRight instanceof char[];

            srcNew = srcPrev;
            offNew = offPrev;
        }
        else
        {
            j = new CharJoin( srcPrev, offPrev, cchPrev, srcAlloc, offAlloc );

            srcNew = j;
            offNew = 0;
            srcNew = j._depth > CharJoin.MAX_DEPTH ? saveChars( j, 0, cchNew ) : j;
        }

        // Now, srcNew and offNew specify the two parts of the triple which has the prev text and
        // part of the text to save (if not all of it).  Here I compute cchMore which is any
        // remaining text which was not allocated for earlier.  Effectively, this code deals with
        // the case where the text to save was greater than the remaining space in the buffer and
        // I need to allocate another buffer to save away the second part and then join the two.
        
        int cchMore = cchSave - cchAlloc;
        
        if (cchMore > 0)
        {
            // If we're here the the buffer got consumed.  So, this time it must allocate a new
            // buffer capable of containing all of the remaining text (no matter how large) and
            // return the beginning part of it.
            
            srcAlloc = allocate( cchMore );
            offAlloc = _offSrc;
            cchAlloc = _cchSrc;

            assert cchAlloc == cchMore;
            assert offAlloc == 0;

            getChars( srcAlloc, offAlloc, srcSave, offSave + (cchSave - cchMore), cchMore );

            j = new CharJoin( srcNew, offNew, cchNew, srcAlloc, offAlloc );
            
            offNew = 0;
            cchNew += cchMore;
            srcNew = j._depth > CharJoin.MAX_DEPTH ? saveChars( j, 0, cchNew ) : j;
        }

        _offSrc = offNew;
        _cchSrc = cchNew;
        
        assert isValid( srcNew, _offSrc, _cchSrc );
        
        return srcNew;
    }

