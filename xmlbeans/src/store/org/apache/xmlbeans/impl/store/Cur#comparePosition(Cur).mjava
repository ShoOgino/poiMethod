    int comparePosition ( Cur that )
    {
        assert isPositioned() && that.isPositioned();

        // If in differnet locales, then can't comapre

        if (_locale != that._locale)
            return 2;

        // No need to denormalize, but I want positions which I can compare (no END_POS)

        Xobj xThis = _xobj;
        int  pThis = _pos == END_POS ? xThis.posAfter() - 1 : _pos;

        Xobj xThat = that._xobj;
        int  pThat = that._pos == END_POS ? xThat.posAfter() - 1 : that._pos;

        // There are several cases:
        //
        // 1. Cursors are on the same xobj
        // 2. One cursor is a child of the other
        // 3. Cursors share a common parent
        // 4. Cursors are not in the same trees
        //
        // Check for the first, trivial, case.  Then, compute the depths of the nodes the
        // cursors are on, checkin for case 2
        //

        if (xThis == xThat)
            return pThis < pThat ? -1 : pThis == pThat ? 0 : 1;

        // Compute the depth of xThis.  See if I hit xThat (case 2)

        int dThis = 0;

        for ( Xobj x = xThis._parent ; x != null ; x = x._parent )
        {
            dThis++;

            if (x == xThat)
                return pThat < xThat.posAfter() - 1 ? 1 : -1;
        }

        // Compute the depth of xThat.  See if I hit xThis (case 2)

        int dThat = 0;

        for ( Xobj x = xThat._parent ; x != null ; x = x._parent )
        {
            dThat++;

            if (x == xThis)
                return pThis < xThis.posAfter() - 1 ? -1 : 1;
        }

        // Must be case 3 or 4 now.  Find a common parent.  If none, then it's case 4

        while ( dThis > dThat ) { dThis--; xThis = xThis._parent; }
        while ( dThat > dThis ) { dThat--; xThat = xThat._parent; }

        assert dThat == dThis;

        if (dThat == 0)
            return 2;

        assert xThis._parent != null && xThat._parent != null;

        while ( xThis._parent != xThat._parent )
        {
            if ((xThis = xThis._parent) == null)
                return 2;

            xThat = xThat._parent;
        }

        // Now, see where xThis and XThat are relative to eachother in the childlist.  Apply
        // some quick common checks before iterating.

        if (xThis._prevSibling == null || xThat._nextSibling == null)
            return -1;

        if (xThis._nextSibling == null || xThat._prevSibling == null)
            return 1;

        while ( xThis != null )
            if ((xThis = xThis._prevSibling) == xThat)
                return 1;

        return -1;
    }

